<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ataraxia</title>
  
  <subtitle>Hi, I&#39;m Jiang.</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://jiangxj.top/blog/"/>
  <updated>2021-12-14T08:12:53.377Z</updated>
  <id>https://jiangxj.top/blog/</id>
  
  <author>
    <name>jiangxj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VuePress使用教程</title>
    <link href="https://jiangxj.top/blog/2021/12/14/vuepress%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/"/>
    <id>https://jiangxj.top/blog/2021/12/14/vuepress配置使用/</id>
    <published>2021-12-13T16:00:00.000Z</published>
    <updated>2021-12-14T08:12:53.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vuepress"><a href="#Vuepress" class="headerlink" title="Vuepress"></a>Vuepress</h1><p>Vue 作者尤雨溪于 2018 年 4 月 13 日推出基于 Vue、围绕 markdown 生成静态页面的 VuePress 框架。</p><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>1、快速搭建一个个人博客</p><p>2、帮助专注写一个好看的文档，关注内容，样式简约</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li>内置 markdown 扩展，针对技术文档进行了优化</li><li>能够利用内嵌在 markdown 文件中的 Vue 代码</li><li>以 Vue 驱动的自定义主题系统</li><li>PWA 支持</li><li>Google Analytics 集成</li><li>内置强大插件</li></ul><p>​            back-to-top 插件（回到头部）</p><p>​            页面滚动时自动激活侧边栏链接的插件</p><p>​           @vuepress/plugin-blog 博客插件</p><p>​           last-updated 插件</p><p>​           medium-zoom 插件</p><p>​           PWA 插件</p><p>​           Google Analytics 插件</p><p>​           一个基于 nprogress 的进度条插件</p><p>​           register-components plugin for VuePress</p><p>​           基于 Headers 的搜索插件</p><ul><li>一个默认主题：</li></ul><p>​           响应式布局</p><p>​          可选的主页</p><p>​          简单、开箱即用、基于标题的搜索功能</p><p>​          可定制的导航栏和侧边栏</p><p>​          自动生成的 GitHub 链接和页面编辑链接</p><p>Vuepress具体的介绍参见：<a href="https://vuepress.vuejs.org/zh/guide/#%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84" target="_blank" rel="noopener">https://vuepress.vuejs.org/zh/guide/#%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84</a></p><h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><p><strong>安装node.js，版本≥8</strong></p><p><strong>安装vuepress</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g vuepress</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意，npm的源在国外，可能会出现网络连接不上问题，可更改npm源或翻墙</span></span><br></pre></td></tr></table></figure><p><strong>初始化项目</strong></p><p>在创建的vuepress文件夹内：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> init 或 <span class="built_in">npm</span> init -y</span><br></pre></td></tr></table></figure><p>创建的工程文件内容</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vuepress       <span class="meta">#根目录</span></span><br><span class="line">├─── src       <span class="meta">#源文件   </span></span><br><span class="line">│   ├── README.md <span class="meta">#首页内容</span></span><br><span class="line">|   ├── wpme <span class="meta">#存放markdown文件</span></span><br><span class="line">│   └── .vuepress  <span class="meta">#存放全局的配置、组件、静态资源等</span></span><br><span class="line">│       └── config.js  <span class="meta">#配置文件入口文件，网站标题、描述、主题等信息</span></span><br><span class="line">├─── docs   <span class="meta">#静态资源目录</span></span><br><span class="line">├─── node_modules </span><br><span class="line">└── <span class="keyword">package</span>.json</span><br></pre></td></tr></table></figure><p>具体目录结构参考：<a href="https://vuepress.vuejs.org/zh/guide/directory-structure.html#%E9%BB%98%E8%AE%A4%E7%9A%84%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">https://vuepress.vuejs.org/zh/guide/directory-structure.html#%E9%BB%98%E8%AE%A4%E7%9A%84%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1</a></p><p><strong>在package.json添加如下启动命令</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"src:dev"</span>: <span class="string">"vuepress dev src"</span>,</span><br><span class="line">    <span class="attr">"src:build"</span>: <span class="string">"vuepress build src"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vuepress"</span>: <span class="string">"^1.0.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>README.md文件内容（该部分是网站首页）</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">home: true</span><br><span class="line">heroImage: </span><br><span class="line">actionText: 开始学习 →</span><br><span class="line">actionLink: /wpme/</span><br><span class="line">features:</span><br><span class="line"><span class="bullet">- </span>title: 文字笔记</span><br><span class="line">  details: 文字笔记包含了书中重点单词构成的单词表</span><br><span class="line"><span class="bullet">- </span>title: 思维导图</span><br><span class="line">  details: 提供了在线交互式思维导图，方便进行探索和复习</span><br><span class="line"><span class="bullet">- </span>title: 音频资源</span><br><span class="line">  details: 点击顶部导航栏中的资源按钮</span><br><span class="line">footer: MIT Licensed | Copyright © 2018-present Jiangxj</span><br></pre></td></tr></table></figure><p><strong>默认主题config.js配置</strong></p><p>参考：<a href="https://v2.vuepress.vuejs.org/zh/reference/default-theme/config.html#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">https://v2.vuepress.vuejs.org/zh/reference/default-theme/config.html#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE</a></p><p><strong>运行本地开发环境</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> src:dev</span></span><br></pre></td></tr></table></figure><p><strong>构建线上静态文件</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> src:build</span></span><br></pre></td></tr></table></figure><p>该命令会生成名为docs文件夹（静态文件），具体来自config.js设置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#config</span>.js</span><br><span class="line"></span><br><span class="line">module<span class="selector-class">.exports</span> = &#123;</span><br><span class="line">    title: <span class="string">'Hello VuePress'</span>,</span><br><span class="line">    description: <span class="string">'Just playing around'</span>,</span><br><span class="line">    dest: <span class="string">'docs'</span>, <span class="comment">//build后生成的文件地址</span></span><br></pre></td></tr></table></figure><p><strong>部署到Github Pages</strong></p><p>新建名为vuepress仓库存放静态文件，设定该仓库的github pages网址。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//<span class="symbol">&lt;TOKEN&gt;</span>@github.<span class="keyword">com</span>/<span class="symbol">&lt;user_name&gt;</span>/<span class="symbol">&lt;repo_name&gt;</span>.git </span><br><span class="line"></span><br><span class="line">//token指令在github设置中生成</span><br></pre></td></tr></table></figure><p>将生成的docs文件夹内容放到clone下的文件，并新建了package文件，存放markdown源文件用于在github在线编辑。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git <span class="keyword">commit</span> -m <span class="string">"deploy"</span></span><br><span class="line">git pull  //Already up <span class="keyword">to</span> <span class="built_in">date</span>保持远程与本地更新</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      基于Vuepress搭建个人文档
    
    </summary>
    
      <category term="教程" scheme="https://jiangxj.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>如何撰写高质量科技论文</title>
    <link href="https://jiangxj.top/blog/2021/06/28/%E5%A6%82%E4%BD%95%E6%92%B0%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E7%A7%91%E6%8A%80%E8%AE%BA%E6%96%87/"/>
    <id>https://jiangxj.top/blog/2021/06/28/如何撰写高质量科技论文/</id>
    <published>2021-06-28T14:13:53.000Z</published>
    <updated>2021-08-05T08:39:04.753Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>根据刘洋教授做的报告整理</strong></p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>确定方向→确定问题→确定思路→确定方法→实验验证→撰写论文→发表文章</p></blockquote><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/attention.PNG" title="科技论文写作要求"></div><p>图中左边是论文写作的pipeline，右边是对应的一般评审标准，包括思路新颖（novelty）、影响重大（impact）、表达清晰（clarity）等。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/R_W.PNG" title="阅读与写作"></div><p>信息是表象，内部逻辑是骨架，传递的思想是灵魂。</p><p>写作和阅读可以看成是两个互逆过程，写作是先有一个思想，通过逻辑来组织，最后通过信息来呈现。</p><p>观念的一个转变：<strong>以作者为核心整理工作→以读者为核心阐述工作</strong>。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/原则.PNG" title="写作原则"></div><h2 id="摘要的写作技巧"><a href="#摘要的写作技巧" class="headerlink" title="摘要的写作技巧"></a>摘要的写作技巧</h2><p>几句话概括工作【起到广告作用】，避免要把所有细节都说清楚、用很专业的术语来描述、出现数学符号。</p><p>一个原则：<strong>用语要简单，让外行能看懂</strong>。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/abstract.PNG" title="摘要范例"></div><h2 id="介绍的写作技巧"><a href="#介绍的写作技巧" class="headerlink" title="介绍的写作技巧"></a>介绍的写作技巧</h2><p>Introduction比题目和摘要更进一步，用几段话说清楚你的工作。</p><p>要点是充分论证所作工作的必要性、重要性和紧迫性，让审稿人认同并迫不及待想往下看。</p><p>行文逻辑严密，论证充分。</p><h3 id="常见的逻辑"><a href="#常见的逻辑" class="headerlink" title="常见的逻辑"></a>常见的逻辑</h3><ol><li>说明问题是什么</li><li>简单罗列相关工作，说明当前工作的挑战</li><li>描述我们的工作，我们的工作对当前的一些挑战的处理，效果能更好</li></ol><p>需要说清楚这个方向上的state-of-art，还没有解决的问题是什么，然后我们的工作解决这个问题。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/段落.PNG" title="段落的写法"></div><p>每一句都是很重要的，不要存在废话。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/范例2.PNG" title="中心句与支撑句写法"></div><p>在这个范例中，红色标出的是中心句论点，表达一个观点。然后分为两个方面，包括计算生物学和计算语言学，然后分别提供著名学者提供的论据，是经典的总分结构。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/范例3.PNG" title="中心句与支撑句写法"></div><p>这是另一个范例，首先是陈述句给出观点，认为什么是重要的，然后从两个方面去论证，On one hand，On the other hand，给出一些学者的观点和数据来支撑。</p><p>此外，有时候也会加入一些衔接句，上一段和下一段有很好的连贯性。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/衔接句.PNG" title="加入衔接句保证连贯性"></div><h3 id="一般写的流程"><a href="#一般写的流程" class="headerlink" title="一般写的流程"></a><strong>一般写的流程</strong></h3><ol><li>首先几句话列出这个领域很重要，这个问题很重要；</li><li>然后是在这个问题上有哪些主要的方法，当前最好效果的一些方法；</li><li>接着是这些方法有哪些挑战；</li><li>再然后是我们要解决这些挑战；</li><li>最后是我们的贡献。</li></ol><p>大概可以分为五段，每一段中心句，然后列出响应的论据来支持中心句，段落之间需要有连贯性。</p><h3 id="中心句（支撑句）论证严密"><a href="#中心句（支撑句）论证严密" class="headerlink" title="中心句（支撑句）论证严密"></a><strong>中心句（支撑句）论证严密</strong></h3><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/支撑句.PNG" title="支撑句要论证严密"></div><p>文中红色部分提出一个论点，下面跟出一些论据。论据基本分为两类，一类是前人的观点，第二类是实验数据。文中两类都给出了，非常有说服力的一些论据。</p><h3 id="小技巧1-首页加图表"><a href="#小技巧1-首页加图表" class="headerlink" title="小技巧1-首页加图表"></a><strong>小技巧1-首页加图表</strong></h3><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/新技巧.PNG" title="一些写作新技巧"></div><p>首先需要了解的是信息元素理解的难易程度，一般图最好理解，直观，证明最难看懂。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/信息理解.PNG" title="信息元素理解难易程度"></div><p>读者潜意识里优先选择易理解度高的信息元素。需要精心对信息元素进行布局，引导一个接收信息时走一条“舒服”路径。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/小技巧1.PNG" title="小技巧：首页加图表"></div><p>文章在Introduction的右上放一个图表，讲清楚自己做的工作，这样就会产生一个信息流的变化：</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/信息流变化.PNG" title="信息流变化"></div><p>看完标题，先看图表，直接能读懂自己的工作，加速审稿人对本文工作的了解。</p><p>在应用类的论文中，图和表的重要性很高，争取能让读者按照顺序看图和表就能理解论文的主要思想，而不用通过看正文才能懂。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/图和表.PNG" title="图和表的重要性"></div><h3 id="小技巧2-直接列出自己的贡献"><a href="#小技巧2-直接列出自己的贡献" class="headerlink" title="小技巧2-直接列出自己的贡献"></a><strong>小技巧2-直接列出自己的贡献</strong></h3><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/列出贡献.PNG" title="直接列出自己的贡献"></div><p>以前都是paper organization，讲诉文章内容下面是怎么组织的。现在很多都在讲contribution，在这里面加上节标号，相当于是一个快捷方式，便于读者找到相应的内容。</p><h3 id="全局连贯性"><a href="#全局连贯性" class="headerlink" title="全局连贯性"></a><strong>全局连贯性</strong></h3><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/全局连贯性.PNG" title="全局连贯性"></div><p>提出的问题和方法需要有对应的实验验证，不要有落空，每一段都要环环相扣。</p><h2 id="方法的写作技巧"><a href="#方法的写作技巧" class="headerlink" title="方法的写作技巧"></a>方法的写作技巧</h2><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/方法.PNG" title="如何描述自己的方法"></div><p>可以先介绍背景知识（baseline）。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/方法例子.PNG" title="方法例子"></div><p>在第2节可以给出一个Background，在上面给出一个例子，这一块主要是在讲目前最好的方法是怎么做的。</p><p>在第3节给出我们自己的方法，同时也在上面给出一个例子，这两个例子进行对比。双面打印时，第2-3页是可以同时看到对比。</p><h3 id="英语不好说清楚，用例子！"><a href="#英语不好说清楚，用例子！" class="headerlink" title="英语不好说清楚，用例子！"></a><strong>英语不好说清楚，用例子！</strong></h3><div style="width:70%;margin:auto"></div><p>看懂例子，再看我们的方法，可以更容易理解我们的方法。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/pic.PNG" title="一图胜千言"></div><p>这个文章中，用了图和文生成描述，使用了attention方法，发现之前的关联性。需要精心设计例子。</p><h3 id="方法描述的逻辑顺序"><a href="#方法描述的逻辑顺序" class="headerlink" title="方法描述的逻辑顺序"></a><strong>方法描述的逻辑顺序</strong></h3><p>一个错误的描述顺序：形式化描述+解释数学符号的意义。</p><p>每个公式都有语言学意义，都来自你的直觉和想法，直接告诉审稿人，不要让去揣摩。直觉是一个high level的idea，公式是一个technique detail，先说清楚自己的想法motivation，然后再给出公式，这个顺序不能颠倒。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/方法例子2.PNG" title="方法描述逻辑顺序"></div><p>首先是用一个例子阐述我们的核心idea，通过这个例子，Intuitively（从直觉上）我们这么做应该会有更好的效果，最后是Formally，对于整个思路做出一个形式化的描述，给出严格的数学上的表达。</p><h3 id="描述的准确性和形式化的能力"><a href="#描述的准确性和形式化的能力" class="headerlink" title="描述的准确性和形式化的能力"></a><strong>描述的准确性和形式化的能力</strong></h3><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/形式化能力.PNG" title="描述准确和形式化能力"></div><p>图中右边是修改版本，数学符号怎么使用会有很多区别，小写字母$a$是一个数，$\pmb {a}$是一个向量，$\pmb A$是一个矩阵，空心体$\mathbb{E}$表示期望。</p><p>多参考领域相关文章的形式化写法，参考模仿。</p><h2 id="实验的写作技巧"><a href="#实验的写作技巧" class="headerlink" title="实验的写作技巧"></a>实验的写作技巧</h2><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/实验设计.PNG" title="实验设计"></div><p>一个注意的是：要使用公认的标准数据和最好的（state-of -the-art）系统，应用类的研究，实验很重要。</p><p>maximum是实验做的很充分，审稿人想到的和没想到的都做了实验。证明方法的优越性，需要统计性显著检验。</p><p>一般是先进行辅助实验，然后进行主实验。在测试集上，不要调参，严格来说，测试集上只能跑一次实验。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/先辅后主.PNG" title="先辅后主进行实验"></div><h3 id="用表技巧"><a href="#用表技巧" class="headerlink" title="用表技巧"></a><strong>用表技巧</strong></h3><p>在实验部分，会大量使用到表格。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/用表.PNG" title="表格设计"></div><p>一般是将baseline放在上面，我们的方法放在最下面。</p><p>把多个指标中，最重要的放在最右面。</p><p>对于复杂的表格，利用单双线等进行区分。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/表格线使用.PNG" title="用表技巧"></div><p>左边两列是讲实验的设置，右边列是实验结果。单线分开，MT02是在验证集上的结果，后面都是在测试集上的结果。最后给一个总体的结果，即看最后一列的结果即可。把一些好的结果加粗显示。</p><h3 id="用图技巧"><a href="#用图技巧" class="headerlink" title="用图技巧"></a><strong>用图技巧</strong></h3><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/用图误区.PNG" title="用图误区"></div><p>曲线上下摆放位置和右上角示意图顺序不一致。</p><p>此外，尽量在图的Caption中包含充分信息，最好能直接看懂图，不用再去看正文。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/用图.PNG" title="Caption包含充分信息"></div><h2 id="相关工作的写作技巧"><a href="#相关工作的写作技巧" class="headerlink" title="相关工作的写作技巧"></a>相关工作的写作技巧</h2><p>Related work这一部分常见问题是漏掉重要的文章，攻击前人的工作，用词注意。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/related.PNG" title="正确写相关工作"></div><p>正确的思路：向审稿人显示对本领域具有全面深刻的把握和梳理。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/传承与创新.PNG" title="相关工作范例"></div><p>我们会说这个工作受到了哪些研究的启发，对前人的研究思想做了扩展，从哪里借鉴了一些idea。</p><p>但是一定要说明difference，每一个related work最后要讲的是我们的工作和前人的不同之处在哪。</p><h2 id="英文写作进阶"><a href="#英文写作进阶" class="headerlink" title="英文写作进阶"></a>英文写作进阶</h2><p>教授最后推荐了一本英文写作方面的书，面向的是英语母语者，会给出列子和改写的版本。</p><div style="width:70%;margin:auto"></div><h2 id="必须掌握的工具"><a href="#必须掌握的工具" class="headerlink" title="必须掌握的工具"></a>必须掌握的工具</h2><p>教授给出了一些写作方面要掌握的工具。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/工具.PNG" title="必须掌握的工具"></div><p>推荐使用MetaPost编程绘图。</p><h2 id="平时练习写论文"><a href="#平时练习写论文" class="headerlink" title="平时练习写论文"></a>平时练习写论文</h2><ul><li>研读和剖析公认的经典范文，学习写作技巧，“模拟写作”；</li><li>多做研究笔记，动笔写；</li><li>认真做好组会报告，练习和提高表达能力；</li><li>投稿过程多听取导师、同学和审稿人的意见。</li></ul><p>对于每段话，每个图和表都找到参考例子，撰写的更加professional。</p><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/匠心.PNG"></div><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/境界.PNG"></div><div style="width:70%;margin:auto"><img src="/blog/2021/06/28/如何撰写高质量科技论文/不仅仅是写作.PNG"></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>写论文的本质是分享信息，呈现信息。</li><li>信息的呈现符合读者的认知惯性。让堵住快速的了解你所做的工作。</li><li>降低阅读难度，提高愉悦感。</li><li>细节决定成败。</li><li>不要本末倒置：创新至上，技法为辅。</li></ul><p><a href="https://hub.baai.ac.cn/view/8658" target="_blank" rel="noopener">2021北京智源大会演讲视频回放</a></p><p><a href="/blog/download/学术论⽂写作方法和技巧_刘洋.pdf">机器翻译学术论文写作方法和技巧-刘洋教授</a></p>]]></content>
    
    <summary type="html">
    
      2021北京智源大会刘洋教授报告内容的整理
    
    </summary>
    
      <category term="会议报告" scheme="https://jiangxj.top/blog/categories/%E4%BC%9A%E8%AE%AE%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="学术会议" scheme="https://jiangxj.top/blog/tags/%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>理解Fourier变换（一）</title>
    <link href="https://jiangxj.top/blog/2020/11/10/%E7%90%86%E8%A7%A3Fourier%E5%8F%98%E6%8D%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://jiangxj.top/blog/2020/11/10/理解Fourier变换（一）/</id>
    <published>2020-11-10T03:58:49.000Z</published>
    <updated>2021-08-05T08:13:55.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="欧拉公式与旋转"><a href="#欧拉公式与旋转" class="headerlink" title="欧拉公式与旋转"></a>欧拉公式与旋转</h2><p>欧拉公式：<br>$$<br>e^{\pi i} +1 =0 \tag 1<br>$$</p><blockquote><p>$e^{\pi i}$表示在单位圆上逆时针旋转180°的变换。</p></blockquote><blockquote><p>公式里面涉及到<strong>指数函数（Exponentiation）</strong>。指数函数是加法和乘法运算的桥梁，在自变量包含复数时表示旋转。</p></blockquote><p>结合泰勒公式，欧拉公式会有一个十分优雅的变形：<br>$$<br>e^{x}=1+x+\frac{1}{2!}x^2 +\frac{1}{3!}x^3 +\dots \tag 2 \\<br>sin(x) = x-\frac{1}{3!} x^3 +\frac{1}{5!} x^5 +\dots \ <br>cos(x) = x-\frac{1}{2!} x^2 +\frac{1}{4!} x^4 +\dots<br>$$<br>令$x=i\theta$，$\theta$为自变量，则(2)式变为：<br>$$<br>\begin{align}<br>e^{i\theta}<br>&amp;= 1+i\theta +\frac{1}{2!}(i\theta)^2 +\dots \ <br>&amp;=(1-\frac{\theta^2}{2!}+\frac{\theta^4}{4!}+\dots) + i(\theta-\frac{\theta^3}{3!}+\frac{\theta^5}{5!}+\dots) \\<br>&amp;= cos(\theta)+isin(\theta)\tag{3}<br>\end{align}<br>$$</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/ei.svg" title="欧拉公式可视化"></div><blockquote><p>纵坐标自带虚数单位$i$（复平面），$sin(\theta)$为纵坐标（自带虚数单位），$cos(\theta)$为横坐标。</p><p>$e^{i\theta}$表示一个圆心在原点，半径为1的单位圆，图中$\alpha$即为（3）式中的$\theta$。</p></blockquote><p>$e^{i\theta}$等价于一种<strong>旋转</strong>，$\theta$为旋转角的度数（弧度制），$\theta = 2\pi$即是单位圆。</p><p>数字本身有两种表达方式（操作），加法和乘法。加法对应数轴的平移变换（一个操作），乘法对应数轴的伸缩变换（一个变换）。</p><p>还有一个旋转操作，旋转是沿着一个圆弧运动的过程，一个单位$i$表示旋转$90°$。如果$y$轴自带虚数单位，如$i,2i,3i,\dots,$就有了旋转操作，$y轴$的平移就可以表示旋转。</p><h2 id="指数函数（Exponentiation）"><a href="#指数函数（Exponentiation）" class="headerlink" title="指数函数（Exponentiation）"></a>指数函数（Exponentiation）</h2><p>指数函数的一个重要特性：加法变乘法，即$a^{x+y} = a^x \times a^y$。</p><p>可以通过指数函数，做到使用平移变换来描述伸缩变换。</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/A2T.gif" title="指数函数平移变换实现伸缩变换"></div><p>图中上面数轴，表示的是平移变换-1（右移一个单位）和+2（左移两个单位），图中下面数轴将上面这两个数作为输入，代入指数函数$f(x) = 2^x$，函数输出值就是两次伸缩变换（乘法），一次是收缩为原来的$\frac{1}{2}$，另一次是拉伸到原来的$2^2=4$倍。</p><h2 id="复平面（Complex-Plane）"><a href="#复平面（Complex-Plane）" class="headerlink" title="复平面（Complex Plane）"></a>复平面（Complex Plane）</h2><p>构造复平面，把虚数单位$i$加到纵轴上，同时拥有了伸缩和旋转。</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/A2Tall.gif" title="复平面"></div><p>横坐标红线表示，横向平移映射到伸缩操作的可视化</p><p>纵坐标虚数单位，纵向平移映射到旋转操作的可视化，正为逆时针旋转。</p><p>把底数换成$e$，更加方便表示圆的概念。</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/e.gif" title="复平面表示圆的概念"></div><p>每走一个单位的纵向位移，在圆周上旋转的圆弧长度为1，$e^{\pi i}$正好代表逆时针旋转180°，并且落在位置为（-1，0），这也就是欧拉公式的几何直观可视化。</p><blockquote><p>$e^x$在复平面，或者说$x=ai$（$a$为某个常数，即弧度制的圆周长度）表示：旋转</p></blockquote><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><blockquote><p>傅里叶变换（不加限定，表示连续傅里叶变换）</p><p>傅里叶级数</p></blockquote><p>傅里叶变换还包括：离散时间傅里叶变换、离散傅里叶变换、傅里叶逆变换、快速傅里叶变换等。还有进一步演化的拉普拉斯变换、小波变换、$z$变换等。</p><h3 id="公式表示"><a href="#公式表示" class="headerlink" title="公式表示"></a>公式表示</h3><p>$$<br>\hat{f}(\xi) = \int_{-\infty}^{+\infty} f(x) e^{-2\pi i x \xi}dx \quad \xi 为任意实数  \tag{4}<br>$$</p><p>一般，$\hat{f}(\xi)$写成$F(w)$或$F(f)$表示角速度或者频率，后面量纲对应修改；自变量$x$一般写成$t$表示时间。</p><h3 id="声音表示"><a href="#声音表示" class="headerlink" title="声音表示"></a>声音表示</h3><p>一个标准音A（下图黄色表示），频率为440 Hz，下图紫红色表示信号频率为294 Hz，两个信号所有时间点振幅叠加得到两个音同时发出的信号时域图。</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/soundAdd.gif" title="不同频率信号振幅叠加"></div><p>给一段任意时间的气压曲线，找到其中原有的组成音符。</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/soundD.gif" title="一段任意气压曲线组成音符"></div><h3 id="可视化方法"><a href="#可视化方法" class="headerlink" title="可视化方法"></a>可视化方法</h3><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/keyIdea.gif" title="绕圈记录法"></div><p>假设有一个每秒3拍子的声音信号，Intensity为强度，只取前面4.5秒（图像中画出来部分）。将黄色曲线缠绕到一个圆上，大小是原本信号的强度（可以理解为振幅）。</p><p>圆周围的图像由白色箭头绘制而成，速度可变，0.50 cycles/second表示白色箭头每秒钟转过半圆。</p><p>此时有两个频率在起作用，一个是<strong>信号频率</strong>：3拍/秒，固定值。另一个是白色箭头绘制缠绕中心圆图像的频率，图中是0.5圈/秒，是一个变量，不同缠绕频率变化时，中心圆周边绘制的曲线可视化表现为：</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/change.gif" title="不同缠绕速度变化时可视化"></div><p>注意到：当绕单位圆的白色箭头滑动速度为3拍/秒（和原始声音信号3拍/秒相同时），会出现一个稳定图像，该图像记录了原始信号幅值变化并且每一圈都相同（周期性）。</p><h3 id="质心记录法"><a href="#质心记录法" class="headerlink" title="质心记录法"></a>质心记录法</h3><p>上面绕单位圆以不同速度绘制周边曲线的可视化图中，自变量输入是可变化的转圈速度，可以看成$f(x)$中的$x$。</p><p>输出的圆圈图像基本关于原点对称，当稳定时，是“头重脚轻”的，描述“头重脚轻”的最好方法是用【质心】（质心描述了物体的空间分布特征）。取质心的横坐标来表示质心的特征。</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/质心.gif" title="每个缠绕频率（速度）对应的质心位置"></div><p>注意到一点：在横坐标等于0处有一个很大的值，原因是原来的图像没有关于横轴对称，有一个偏移量。</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/mass0.gif" title="零点处偏移"></div><p>得到的新图像的横坐标是【频率（Frequency）】，即缠绕圆圈的记录速度。频率可以抽象理解为围着圆圈跑的速度。</p><p>该工具应用到两个声音的组合图像中：</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/2mix.gif" title="2Hz+3Hz组合"></div><h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><p><strong>第一步：旋转表示</strong></p><p>旋转的桥梁是复平面，背后原理是指数函数结合泰勒公式：</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/fe.gif" title="旋转表示"></div><p>$\pi$单位的$e^{6.28i}$表示一个单位圆旋转一圈，$e^{2\pi i t}$表示一秒钟一圈的旋转方程，引入$f$频率，控制旋转的速度，$f=\frac{1}{10}$，合起来表示一秒钟十分之一圈。</p><p><strong>第二步：缠绕的表示</strong></p><p>依据下面动图，我们规定旋转是顺时针的（为了统一标准，也考虑到简洁和便于计算），所以先加一个符号。假设原来函数是$g(t)$，两者相乘就能得到缠绕图像，$g(t)e^{-2\pi i f t}$。</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/circle.gif" title="缠绕表示"></div><p><strong>第三步：质心表示</strong></p><p>以正方形的质心为例，在四周边框取$N$个等距离分布的点，计算这几个点的位置的平均值，推广到一般情况下：</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/sample2.gif" title="质心积分表示"></div><p>图中，紫红色的点为采样点，得到：$\frac{1}{N}\sum\limits_{k=1}^{N}g(t_k)e^{-2\pi i f t_k}$</p><p>随着采样点的增加，使用积分表示，可以得到：<br>$$<br>\frac{1}{t_2-t_1} \int_{t_1}^{t_2} g(t)e^{-2\pi i ft_k}dt \tag{5}<br>$$<br>常数项$\frac{1}{t_2-t_1}$值越大，表示质心位置偏移越大，去掉该常数项系数，几何直观动图（红色箭头为去掉系数后的常数表示）绘制的图像更集中在对应频率的附近，也就是说在对应的频率位置的值更大。</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/newpic.gif" title="去掉系数后公式可视化图"></div><p>一般傅里叶变换公式的上下限是正负无穷，其几何直观表示：</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/limit.gif" title="积分上下限为正负无穷"></div><p>其实，信号从开始到结束做傅里叶变换，对应于傅里叶变换积分上下限从负无穷到正无穷。</p><h3 id="相位"><a href="#相位" class="headerlink" title="相位"></a>相位</h3><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/Phase.gif" title="相位表示"></div><p>其中红色部分为质心，长度为振幅大小，对应的角度$\theta$表示相位</p><h3 id="原信号长度"><a href="#原信号长度" class="headerlink" title="原信号长度"></a>原信号长度</h3><p>假设信号时长很长，那么缠绕圆上的线更多，每次接近稳定图像质心的变化速度更快（即频率图像更加密集）</p><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/relation.gif" title="信号时长长短对频率图像影响"></div><p>同理，当信号时长较短时候，频率图像会更加稀疏，缠绕圆上的线更少，质心变化的速度相应变慢。</p><div style="width:70%;margin:auto"></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div style="width:70%;margin:auto"><img src="/blog/2020/11/10/理解Fourier变换（一）/seeF.gif" title="质心积分表示"></div><ul><li>$e^{2\pi i}$表示单位圆，添加自变量即表示旋转，乘以原函数$g(t)$即缠绕到单元圆上。</li><li>利用积分计算来求取质心的特征</li><li>一个逆时针旋转360°画成的圆→$e^{2\pi i}$</li><li>表示运动，需要原函数的自变量，时间$t\rightarrow e^{2\pi it}$</li><li>表示旋转速度，需要自变量，频率$f\rightarrow e^{2\pi ift}$</li><li>规定变换的采样方向为顺时针，加负号$\rightarrow e^{-2\pi ift}$</li><li>乘以原函数缠绕到单位圆并记录$\rightarrow g(t)e^{-2\pi ift}$（$g$标识原函数，与$f$区分）</li><li>计算质心特征，积分$\rightarrow \int_{-\infty}^{+\infty}g(t)e^{-2\pi ift}dt$</li><li>自变量为频率$f$，得到函数表达式$\rightarrow \hat{g}(f) = \int_{-\infty}^{+\infty}g(t)e^{-2\pi ift}dt$</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://charlesliuyx.github.io/2018/02/18/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E8%AE%A9%E4%BD%A0%E6%B0%B8%E8%BF%9C%E5%BF%98%E4%B8%8D%E4%BA%86%E7%9A%84%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">直观详解傅里叶变换</a></p><p><a href="https://www.bilibili.com/video/av19141078?from=search&amp;seid=9405358806566342039" target="_blank" rel="noopener">3Blue1Brown形象展示傅里叶变换-bilibili.com</a></p>]]></content>
    
    <summary type="html">
    
      傅里叶变换理解
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="信号处理" scheme="https://jiangxj.top/blog/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学和人工智能专业课程整理</title>
    <link href="https://jiangxj.top/blog/2020/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    <id>https://jiangxj.top/blog/2020/07/15/计算机科学/</id>
    <published>2020-07-14T16:00:00.000Z</published>
    <updated>2020-07-19T07:58:42.489Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机科学"><a href="#计算机科学" class="headerlink" title="计算机科学"></a>计算机科学</h1><p>该部分内容引用来源如下所述：</p><blockquote><p>本文档是对<a href="https://teachyourselfcs.com" target="_blank" rel="noopener">TeachYourselfCS</a>内容的中文翻译，原作者为<a href="https://twitter.com/oznova_" target="_blank" rel="noopener">Ozan Onay</a>和<a href="https://twitter.com/quackingduck" target="_blank" rel="noopener">Myles Byrne</a>。</p><p>This document is a Chinese translation of <a href="https://teachyourselfcs.com" target="_blank" rel="noopener">TeachYourselfCS</a>, which is written by <a href="https://twitter.com/oznova_" target="_blank" rel="noopener">Ozan Onay</a> and <a href="https://twitter.com/quackingduck" target="_blank" rel="noopener">Myles Byrne</a>. For more information about this translation, please refer to <a href="#这份指引是谁翻译的">the end of this document</a>.</p></blockquote><h2 id="课程索引"><a href="#课程索引" class="headerlink" title="课程索引"></a>课程索引</h2><table><thead><tr><th>科目</th><th>为何要学？</th><th>最佳书籍</th><th>最佳视频</th></tr></thead><tbody><tr><td><strong><a href="#编程">编程</a></strong></td><td>不要做一个“永远没彻底搞懂”诸如递归等概念的程序员。</td><td>_<a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">《计算机程序的构造和解释》</a>_</td><td>Brian Harvey’s Berkeley CS 61A</td></tr><tr><td><strong><a href="#计算机架构">计算机架构</a></strong></td><td>如果你对于计算机如何工作没有具体的概念，那么你所做出的所有高级抽象都是空中楼阁。</td><td>_<a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">《深入理解计算机系统》</a>_</td><td>Berkeley CS 61C</td></tr><tr><td><strong><a href="#算法和数据结构">算法与数据结构</a></strong></td><td>如果你不懂得如何使用栈、队列、树、图等常见数据结构，遇到有难度的问题时，你将束手无策。</td><td>_<a href="https://book.douban.com/subject/4048566/" target="_blank" rel="noopener">《算法设计手册》</a>_</td><td>Steven Skiena’s lectures</td></tr><tr><td><strong><a href="#数学知识">数学知识</a></strong></td><td>计算机科学基本上是应用数学的一个“跑偏的”分支，因此学习数学将会给你带来竞争优势。</td><td>_<a href="https://book.douban.com/subject/33396340/" target="_blank" rel="noopener">《计算机科学中的数学》</a>_</td><td>Tom Leighton’s MIT 6.042J</td></tr><tr><td><strong><a href="#操作系统">操作系统</a></strong></td><td>你所写的代码，基本上都由操作系统来运行，因此你应当了解其运作的原理。</td><td>_<a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">《操作系统导论》</a>_</td><td>Berkeley CS 162</td></tr><tr><td><strong><a href="#计算机网络">计算机网络</a></strong></td><td>互联网已然势不可挡：理解工作原理才能解锁全部潜力。</td><td>_<a href="https://book.douban.com/subject/30280001/" target="_blank" rel="noopener">《计算机网络：自顶向下方法》</a>_</td><td>Stanford CS 144</td></tr><tr><td><strong><a href="#数据库">数据库</a></strong></td><td>对于多数重要程序，数据是其核心，然而很少人理解数据库系统的工作原理。</td><td>_<a href="https://book.douban.com/subject/2256069/" target="_blank" rel="noopener">《Readings in Database Systems》</a> （暂无中译本）_</td><td>Joe Hellerstein’s Berkeley CS 186</td></tr><tr><td><strong><a href="#编程语言与编译器">编程语言与编译器</a></strong></td><td>若你懂得编程语言和编译器如何工作，你就能写出更好的代码，更轻松地学习新的编程语言。</td><td>_<a href="https://craftinginterpreters.com/" target="_blank" rel="noopener">《Crafting Interpreters》</a>_</td><td>Alex Aiken’s course on Lagunita</td></tr><tr><td><strong><a href="#分布式系统">分布式系统</a></strong></td><td>如今，_多数_ 系统都是分布式的。</td><td>_<a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">《数据密集型应用系统设计》</a>_</td><td>MIT 6.824</td></tr></tbody></table><p>如果花几年时间自学 9 门科目让人望而却步，我们建议你只专注于两本书：_《深入理解计算机系统》_ 和 _《数据密集型应用系统设计》_。根据我们的经验，投入到这两本书的时间可以获得极高的回报率，特别适合从事网络应用开发的自学工程师。这两本书也可以作为上面表格中其他科目的纲领。</p><h2 id="分科目指引"><a href="#分科目指引" class="headerlink" title="分科目指引"></a>分科目指引</h2><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p>大多数计算机专业本科教学以程序设计“导论”作为开始。这类课程的最佳版本不仅能满足初学者的需要，还适用于那些在初学编程阶段遗漏了某些有益的概念和程序设计模式的人。</p><p>对于这部分内容，我们的标准推荐是这部经典著作：<a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">《计算机程序的构造和解释》</a>。在网络上，这本书既可供<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html" target="_blank" rel="noopener">免费阅读（英文版）</a>，也作为<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/" target="_blank" rel="noopener">MIT的免费视频课程</a>。不过尽管这些视频课程很不错，我们对于视频课程的推荐实际上是<a href="https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter" target="_blank" rel="noopener">Brian Harvey 开设的 SICP 课程</a>（即 Berkeley 的 61A 课程）。比起MIT的课程，它更加完善，更适用于初学者。</p><p>我们建议至少学完SICP的前三章，并完成配套的习题。如果需要额外的练习，可以去解决一些小的程序设计问题，比如<a href="http://exercism.io" target="_blank" rel="noopener">exercism</a>。</p><blockquote><p><strong>中文翻译新增：</strong>  </p><ul><li>关于SICP国内视频观看地址  <ul><li><a href="https://www.bilibili.com/video/av8515129/" target="_blank" rel="noopener">MIT的免费视频课程（中英字幕）</a>  </li><li><a href="https://www.bilibili.com/video/av40460492/" target="_blank" rel="noopener">Brian Harvey 开设的 SICP 课程（英文字幕）</a>  </li></ul></li><li>Scheme 学习的相关资源参见：<a href="https://github.com/DeathKing/Learning-SICP" target="_blank" rel="noopener">https://github.com/DeathKing/Learning-SICP</a>  </li><li>更详细的补充说明：<a href="https://github.com/keithnull/TeachYourselfCS-CN/issues/3" target="_blank" rel="noopener">#3</a>  </li></ul></blockquote><p>自从 2016 年首次发布这份指南以来，最常被问到的一个问题是，我们是否推荐由 John DeNero 讲授的更新的 CS 61A 课程，以及配套的书籍 _<a href="https://composingprograms.com/" target="_blank" rel="noopener">《Composing Programs》</a>_，这本书“继承自 SICP” 但使用 Python 讲解。我们认为 DeNero 的课程也很不错，有的学生可能更喜欢，但我们还是建议把 SICP, Scheme 和 Brian Harvey 的视频课程作为首选。</p><p>为什么这么说呢？因为 SICP 是独一无二的，它可以——至少很有可能——改变你对计算机和编程的基本认识。不是每个人都有这样的体验。有的人讨厌这本书，有的人看了前几页就放弃了。但潜在的回报让它值得一读。</p><p>如果你觉得SICP过于难，试试 _《Composing Programs》_。如果还是不合适，那我们推荐 _《程序设计方法》（<a href="https://book.douban.com/subject/1140942/" target="_blank" rel="noopener">中文版</a>，<a href="http://www.htdp.org/" target="_blank" rel="noopener">英文版</a>）_ ；如果你觉得SICP过于简单，那我们推荐 _<a href="https://book.douban.com/subject/1782316/" target="_blank" rel="noopener">《Concepts, Techniques, and Models of Computer Programming》</a>_ 。如果读这些书让你觉得没有收获，也行你应该先学习其他科目，一两年后再重新审视编程的理念。</p><blockquote><p>新版原文删除了对 _《Concepts, Techniques, and Models of Computer Programming》_ 一书的推荐，但这本书对各种编程模型有深入的见解，值得一读。所以译文中依然保留。<br>— 译者注</p></blockquote><p>最后，有一点要说明的是：本指南<strong>不适用</strong>于完全不懂编程的新手。我们假定你是一个没有计算机专业背景的程序员，希望填补一些知识空白。事实上，我们把“编程”章节包括进来只是提醒你还有更多知识需要学习。对于那些从来没有学过编程，但又想学的人来说，这份<a href="https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_getting_started" target="_blank" rel="noopener">指南</a>更合适。</p><p><a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20233656/66758473-ef7bff80-eed0-11e9-944a-15ae5c8542ca.jpg" alt="计算机程序的构造和解释"></a> </p><h3 id="计算机架构"><a href="#计算机架构" class="headerlink" title="计算机架构"></a>计算机架构</h3><p>计算机架构——有时候又被称为“计算机系统”或者“计算机组成”——是了解软件底层的的重要视角。根据我们的经验，这是自学的软件工程师最容易忽视的领域。</p><p>我们最喜欢的入门书是 _<a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">《深入理解计算机系统》</a>_。典型的<a href="http://csapp.cs.cmu.edu/3e/courses.html" target="_blank" rel="noopener">计算机体系结构导论课程</a>会涵盖本书的 1 - 6 章。</p><p>我们喜爱《深入理解计算机系统》，因为它的实用性，并且站在程序员的视角。虽然计算机体系结构的内容比本书所涉及的内容多得多，但对于那些想了解计算机系统以求编写更快、更高效、更可靠的软件的人来说，这本书是很好的起点。</p><p>对于那些既想了解这个主题又想兼顾硬件和软件的知识的人来说，我们推荐 _<a href="https://book.douban.com/subject/1998341/" target="_blank" rel="noopener">《计算机系统要素》</a>_，又名“从与非门到俄罗斯方块”（“Nand2Tetris”），这本书规模宏大，让读者对计算机内的所有部分如何协同工作有完全的认识。这本书的每一章节对应如何构建计算机整体系统中的一小部分，从用HDL（硬件描述语言）写基本的逻辑门电路出发，途经CPU和汇编，最终抵达诸如俄罗斯方块这般规模的应用程序。</p><p>我们推荐把此书的前六章读完，并完成对应的项目练习。这么做，你将更加深入地理解，计算机架构和运行其上的软件之间的关系。</p><p>这本书的前半部分（包括所有对应的项目）均可从<a href="http://www.nand2tetris.org" target="_blank" rel="noopener">Nand2Tetris的网站上</a>免费获得。同时，在Coursera上，这是一门<a href="https://www.coursera.org/learn/build-a-computer" target="_blank" rel="noopener">视频课程</a>。</p><p>为了追求简洁和紧凑，这本书牺牲了内容上的深度。尤其值得注意的是，流水线和存储层次结构是现代计算机架构中极其重要的两个概念，然而这本书对此几乎毫无涉及。</p><p>当你掌握了Nand2Tetris的内容后，我们推荐要么回到《深入理解计算机系统》，或者考虑Patterson和Hennessy二人所著的 _<a href="https://book.douban.com/subject/26604008/" target="_blank" rel="noopener">《计算机组成与设计》</a>_，一本优秀的经典著作。这本书中的不同章节重要程度不一，因此我们建议根据Berkeley的<a href="http://inst.eecs.berkeley.edu/~cs61c/sp15/" target="_blank" rel="noopener">CS61C课程</a> “计算机架构中的伟大思想”来着重阅读一些章节。这门课的笔记和实验在网络上可以免费获得，并且在<a href="https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_" target="_blank" rel="noopener">互联网档案</a>中有这门课程的过往资料。</p><p><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20510068/82109944-12270d00-976d-11ea-85a9-774e4f762ec9.png" alt="深入理解计算机系统"></a> <a href="http://www.nand2tetris.org" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20233656/66758695-60231c00-eed1-11e9-8422-a4acfb10a390.jpg" alt="计算机系统要素"></a> </p><blockquote><p>硬件是平台。</p><p>— Mike Acton, Engine Director at Insomniac Games<br>(<a href="https://www.youtube.com/watch?v=rX0ItVEVjHc" target="_blank" rel="noopener">观看他在CppCon上的演说</a>)</p></blockquote><h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p>正如几十年来的共识，我们认为，计算机科学教育所赋予人们的最大能量在于对常见算法和数据结构的熟悉。此外，这也可以训练一个人对于各种问题的解决能力，有助于其他领域的学习。</p><p>关于算法与数据结构，有成百上千的书可供使用，但是我们的最爱是Steven Skiena编写的 _<a href="https://book.douban.com/subject/4048566/" target="_blank" rel="noopener">《算法设计手册》</a>_。显而易见，他对此充满热爱，迫不及待地想要帮助其他人理解。在我们看来，这本书给人一种焕然一新的体验，完全不同于那些更加经常被推荐的书（比如Cormen，Leiserson，Rivest 和 Stein，或者 Sedgewick的书，后两者充斥着过多的证明，不适合以 _解决问题_ 为导向的学习）。</p><p>如果你更喜欢视频课程，<a href="https://www.youtube.com/watch?v=A2bFN3MyNDA&amp;list=PLOtl7M3yp-DX32N0fVIyvn7ipWKNGmwpp" target="_blank" rel="noopener">Skiena慷慨地提供了他的课程</a>。此外，Tim Roughgarden的课程也很不错，<br>在Stanford的MOOC平台Lagunita，或者<a href="https://www.coursera.org/specializations/algorithms" target="_blank" rel="noopener">Coursera</a>上均可获得。Skiena和Roughgarden的这两门课程没有优劣之分，选择何者取决于个人品味。</p><p>至于练习，我们推荐学生在<a href="https://leetcode.com" target="_blank" rel="noopener">Leetcode</a>上解决问题。Leetcode上的问题往往有趣且带有良好的解法和讨论。此外，在竞争日益激烈的软件行业，这些问题可以帮助你评估自己应对技术面试中常见问题的能力。我们建议解决大约100道随机挑选的Leetcode问题，作为学习的一部分。</p><p>最后，我们强烈推荐 _<a href="https://book.douban.com/subject/2124114/" target="_blank" rel="noopener">《怎样解题》</a>_。这本书极为优秀且独特，指导人们解决广义上的问题，因而一如其适用于数学，它适用于计算机科学。</p><p><a href="https://book.douban.com/subject/4048566/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20233656/66759121-361e2980-eed2-11e9-913c-8fc48c67122a.jpg" alt="算法设计手册"></a> <a href="https://book.douban.com/subject/2124114/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20233656/66759282-8e552b80-eed2-11e9-89de-16b1f8d82e78.jpg" alt="怎样解题"></a> </p><blockquote><p>我可以广泛推荐的方法只有一个： 写之前先思考。</p><p>— Richard Hamming</p></blockquote><h3 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h3><p>从某个角度说，计算机科学是应用数学的一个“发育过度”的分支。尽管许多软件工程师试图——并且在不同程度上成功做到——忽视这一点，我们鼓励你用学习来拥抱数学。如若成功，比起那些没有掌握数学的人，你将获得巨大的竞争优势。</p><p>对于计算机科学，数学中最相关的领域是“离散数学”，其中的“离散”与“连续”相对立，大致上指的是应用数学中那些有趣的主题，而不是微积分之类的。由于定义比较含糊，试图掌握离散数学的全部内容是没有意义的。较为现实的学习目标是，了解逻辑、排列组合、概率论、集合论、图论以及密码学相关的一些数论知识。考虑到线性代数在计算机图形学和机器学习中的重要性，该领域同样值得学习。</p><p>学习离散数学，我们建议从<a href="http://www.cs.elte.hu/~lovasz/dmbook.ps" target="_blank" rel="noopener">László Lovász的课程笔记</a>开始。Lovász教授成功地让这些内容浅显易懂且符合直觉，因此，比起正式的教材，这更适合初学者。</p><p>对于更加高阶的学习，我们推荐 _<a href="https://book.douban.com/subject/33396340/" target="_blank" rel="noopener">《计算机科学中的数学》</a>_，MIT同名课程的课程笔记，篇幅与书籍相当（事实上，现已出版）。这门课程的视频同样<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/" target="_blank" rel="noopener">可免费获得</a>，是我们所推荐的学习视频。</p><p>对于线性代数，我们建议从<a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab" target="_blank" rel="noopener">Essence of linear algebra</a>系列视频开始，然后再去学习Gilbert Strang的<a href="https://book.douban.com/subject/34820335/" target="_blank" rel="noopener">《线性代数导论》</a>和<a href="https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/video-lectures/" target="_blank" rel="noopener">视频课程</a>。</p><p><a href="https://book.douban.com/subject/33396340/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20233656/66759673-4387e380-eed3-11e9-8469-3e677d108e91.jpg" alt="计算机科学中的数学"></a> </p><blockquote><p>如果人们不相信数学是简单的，那么只能是因为他们没有意识到生活有多么复杂。</p><p>— John von Neumann</p></blockquote><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>_<a href="https://book.douban.com/subject/30297919/" target="_blank" rel="noopener">《操作系统概念》</a>_ （“恐龙书”）和 _<a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">《现代操作系统》</a>_ 是操作系统领域的经典书籍。二者都因为写作风格和对学生不友好而招致了一些批评。</p><p>_<a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener">《操作系统导论》（Operating Systems: Three Easy Pieces）</a>_ 是一个不错的替代品，并且<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">可在网上免费获得（英文版）</a>。我们格外喜欢这本书的结构，并且认为这本书的习题很值得一做。</p><p>在读完《操作系统导论》后，我们鼓励你探索特定操作系统的设计。可以借助“{OS name} Internals”风格的书籍，比如 _<a href="https://www.amazon.com/Lions-Commentary-Unix-John/dp/1573980137/" target="_blank" rel="noopener">Lion’s commentary on Unix</a>_， _<a href="https://www.amazon.com/Design-Implementation-FreeBSD-Operating-System/dp/0321968972/" target="_blank" rel="noopener">The Design and Implementation of the FreeBSD Operating System</a>_，以及 _<a href="https://www.amazon.com/Mac-OS-Internals-Systems-Approach/dp/0321278542/" target="_blank" rel="noopener">Mac OS X Internals</a>_。对于 Linux ，我们推荐 Robert Love 的 _<a href="https://book.douban.com/subject/6097773/" target="_blank" rel="noopener">《Linux内核设计与实现》</a>_。</p><p>为了巩固对操作系统的理解，阅读小型系统内核的代码并且为其增加特性是一个很不错的方法。比如，<a href="https://pdos.csail.mit.edu/6.828/2016/xv6.html" target="_blank" rel="noopener">xv6</a>，由MIT的一门课程所维护的从Unix V6到ANSI C和x86的移植，就是一个很棒的选择。《操作系统导论》有一个附录，记载了一些可能的<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/lab-projects-xv6.pdf" target="_blank" rel="noopener">xv6实验项目</a>，其中充满了关于潜在项目的很棒想法。</p><p><a href="https://book.douban.com/subject/33463930/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20233656/66759780-78943600-eed3-11e9-8eb5-6472c318c265.jpg" alt="操作系统导论"></a> </p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>鉴于有那么多关于网络服务端和客户端的软件工程，计算机网络是计算机科学中价值最为“立竿见影”的领域之一。我们的学生，系统性地学习了计算机网络，最终能够理解那些曾困扰他们多年的术语、概念和协议。</p><p>在这一主题上，我们最爱的书籍是 _<a href="https://book.douban.com/subject/30280001/" target="_blank" rel="noopener">《计算机网络：自顶向下方法》</a>_。书中的小项目和习题相当值得练习，尤其是其中的“Wireshark labs”（<a href="http://www-net.cs.umass.edu/wireshark-labs/" target="_blank" rel="noopener">这部分在网上可以获得</a>）。</p><p>如果更喜欢视频课程，我们推荐Stanford的<a href="https://lagunita.stanford.edu/courses/Engineering/Networking-SP/SelfPaced/about" target="_blank" rel="noopener">_Introduction to Computer Networking_</a>，可在他们的MOOC平台Lagunita上免费观看。</p><p>对于计算机网络的学习，做项目比完成小的习题更有益。一些可能的项目有：HTTP服务器，基于UDP的聊天APP，<a href="http://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/" target="_blank" rel="noopener">迷你TCP栈</a>，代理，负载均衡器，或者分布式哈希表。</p><p><a href="https://book.douban.com/subject/30280001/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20233656/66760004-d9bc0980-eed3-11e9-9b3f-74bf54b9571f.jpg" alt="《计算机网络：自顶向下方法》"></a> </p><blockquote><p>你无法盯着水晶球预见未来，未来的互联网何去何从取决于社会。</p><p>— Bob Kahn</p></blockquote><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>比起其他主题，自学数据库系统需要更多的付出。这是一个相对年轻的研究领域，并且出于很强的商业动机，研究者把想法藏在紧闭的门后。此外，许多原本有潜力写出优秀教材的作者反而选择了加入或创立公司。</p><p>鉴于如上情况，我们鼓励自学者大体上抛弃教材，而是从<a href="https://archive.org/details/UCBerkeley_Course_Computer_Science_186" target="_blank" rel="noopener">2015年春季学期的CS 186课程</a>（Joe Hellerstein在Berkeley的数据库课程）开始，然后前往阅读论文。</p><p>对于初学者，有一篇格外值得提及的论文：“<a href="http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf" target="_blank" rel="noopener">Architecture of a Database System</a>”。这篇论文提供了独特的对关系型数据库管理系统（RDBMS）如何工作的高层次观点，是后续学习的实用梗概。</p><p>_<a href="https://book.douban.com/subject/2256069/" target="_blank" rel="noopener">《Readings in Database Systems》</a>_，或者以<a href="http://www.redbook.io/" target="_blank" rel="noopener">数据库“红书”</a>更为人知，是由Peter Bailis，Joe Hellerstein和Michael Stonebraker编纂的论文合集。对于那些想要在CS 186课程的水平更进一步的学习者，“红书”应当是下一步。</p><p>如果你坚持一定要一本导论教材，那我们推荐Ramakrishnan和Gehrke所著的 _<a href="https://book.douban.com/subject/1155934/" target="_blank" rel="noopener">《数据库管理系统：原理与设计》</a>_。如需更深一步，Jim Gray的经典著作 _<a href="https://book.douban.com/subject/2586390/" target="_blank" rel="noopener">《Transaction Processing: Concepts and Techniques》</a>_ 值得一读，不过我们不建议把这本书当作首要资源。</p><p>如果没有编写足够数量的代码，很难巩固数据库理论。CS 186课程的学生给Spark添加特性，倒是不错的项目，不过我们仅仅建议从零实现一个简单的关系型数据库管理系统。自然，它将不会有太多的特性，但是即便只实现典型的关系型数据库管理系统每个方面最基础的功能，也是相当有启发的。</p><p>最后，数据模型往往是数据库中一个被忽视的、教学不充分的方面。关于这个主题，我们推荐的书籍是 _<a href="https://book.douban.com/subject/17915870/" target="_blank" rel="noopener">Data and Reality: A Timeless Perspective on Perceiving and Managing Information in Our Imprecise World</a>_。</p><p><a href="https://book.douban.com/subject/2256069/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20233656/66760126-08d27b00-eed4-11e9-82c6-46c571036aa1.jpg" alt="Readings in Database Systems"></a> <a href="https://book.douban.com/subject/1155934/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20233656/66760358-85655980-eed4-11e9-9130-66d2ecea5700.jpg" alt="数据库管理系统：原理与设计"></a> </p><h3 id="编程语言与编译器"><a href="#编程语言与编译器" class="headerlink" title="编程语言与编译器"></a>编程语言与编译器</h3><p>多数程序员学习编程语言的知识，而多数计算机科学家学习编程语言 _相关_ 的知识。这使得计算机科学家比起程序员拥有显著的优势，即便在编程领域！因为他们的知识可以推而广之：相较只学习过特定编程语言的人，他们可以更深入更快速地理解新的编程语言。</p><p>我们推荐的入门书是 Bob Nystrom 所著的优秀的 _<a href="https://craftinginterpreters.com/contents.html" target="_blank" rel="noopener">Crafting Interpreters</a>_，可在网上免费获取。这本书条理清晰，富有趣味性，非常适合那些想要更好地理解语言和语言工具的人。我们建议你花时间读完整本书，并尝试任何一个感兴趣的“挑战”。</p><p>另一本更为传统的推荐书籍是 _<a href="https://book.douban.com/subject/3296317/" target="_blank" rel="noopener">《编译原理》</a>_，通常称为“龙书”。不幸的是，这本书不是为自学者而设计的，而是供教师从中挑选一些主题用于1-2学期的教学。</p><p>如果你选择使用龙书进行自学，你需要从中甄选主题，而且最好是在导师的帮助下。我们建议依据某个视频课程来设定学习的结构，然后按需从龙书中获取深入的内容。我们推荐的在线课程是<a href="https://www.edx.org/course/compilers" target="_blank" rel="noopener">Alex Aiken在MOOC平台 edX 所开设的</a>。</p><p><a href="https://book.douban.com/subject/3296317/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20233656/66760486-ca898b80-eed4-11e9-80ba-df298ac8d5da.jpg" alt="编译原理"></a> </p><blockquote><p>不要做一个只写样板代码的程序员。相反，给用户和其他程序员创造工具。从纺织工业和钢铁工业中学习历史教训：你想制造机器和工具，还是操作这些机器？</p><p>— Ras Bodik 在他的编译器课程伊始</p></blockquote><h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>随着计算机在数量上的增加，计算机同样开始 _分散_。尽管商业公司过去愿意购买越来越大的大型机，现在的典型情况是，甚至很小的应用程序都同时在多台机器上运行。思考这样做的利弊权衡，即是分布式系统的研究所在，也是越来越重要的一项技能。</p><p>我们推荐的自学参考书是 Martin Kleppmann 的 _<a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">《数据密集型应用系统设计》</a>_。与传统的教科书相比，它是一本为实践者设计的具有很高的可读性的书，并且保持了深度和严谨性。</p><p>对于那些偏爱传统教材，或者希望可以从网上免费获取的人，我们推荐的教材是Maarten van Steen和Andrew Tanenbaum所著的 _《分布式系统原理与范型》（<a href="https://book.douban.com/subject/3108801/" target="_blank" rel="noopener">中文第二版</a>，<a href="https://book.douban.com/subject/26979326/" target="_blank" rel="noopener">英文第三版</a>）_。</p><p>对于喜欢视频课程的人，<a href="https://www.youtube.com/watch?v=cQP8WApzIQQ&amp;list=PLrw6a1wE39_tb2fErI4-WkMbsvGQk9_UB" target="_blank" rel="noopener">MIT的6.824</a> 是一门很好的在线视频课程，由 Robert Morris 教授的研究生课程，在<a href="https://pdos.csail.mit.edu/6.824/schedule.html" target="_blank" rel="noopener">这里</a>可以看到课程安排。</p><p>不管选择怎样的教材或者其他辅助资料，学习分布式系统必然要求阅读论文。<a href="http://dsrg.pdos.csail.mit.edu/papers/" target="_blank" rel="noopener">这里</a>有一个不错的论文清单，而且我们强烈建议你出席你当地的<a href="http://paperswelove.org/" target="_blank" rel="noopener">Papers We Love</a>（仅限美国）。</p><p><a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/20510068/82111034-94ff9600-9774-11ea-9d49-90b00f746659.png" alt="数据密集型应用系统设计"></a> </p><h3 id="人工智能-计算机图形学"><a href="#人工智能-计算机图形学" class="headerlink" title="人工智能/计算机图形学"></a>人工智能/计算机图形学</h3><p>我们试图把计算机科学主题清单限制到那些我们认为 _每一个软件工程师_ 都应该了解的内容，不限于专业或行业。拥有了这些基础，你将能更加轻松地挑选教材或论文，然而无需指引地学习核心概念。在这里，我们给出一些其他常见主题的自学起点：</p><ul><li>人工智能：通过观看视频并完成Pacman项目来学习<a href="http://ai.berkeley.edu/" target="_blank" rel="noopener">Berkeley的AI课程</a>。至于教材，使用Russell和Norvig编写的 _<a href="https://book.douban.com/subject/25796281/" target="_blank" rel="noopener">《人工智能：一种现代方法》</a>_。</li><li>机器学习：学习吴恩达在Coursera上的课程。耐心学习，先确保理解了基础概念再奔向类如深度学习的诱人新主题。</li><li>计算机图形学：学习<a href="http://inst.eecs.berkeley.edu/~cs184/fa12/onlinelectures.html" target="_blank" rel="noopener">Berkeley CS 184课程</a>的材料，使用<a href="https://book.douban.com/subject/30402778/" target="_blank" rel="noopener">《计算机图形学：原理及实践》</a>作为教材。</li></ul><h3 id="一定要严格遵守推荐的学习次序吗？"><a href="#一定要严格遵守推荐的学习次序吗？" class="headerlink" title="一定要严格遵守推荐的学习次序吗？"></a>一定要严格遵守推荐的学习次序吗？</h3><p>不过在我们看来，最重要的“先决条件”是：先学计算机架构再学操作系统或数据库，先学计算机网络和操作系统再学分布式系统。</p><h3 id="和Open-Source-Society、freeCodeCamp-curricula等比起来，这份指引"><a href="#和Open-Source-Society、freeCodeCamp-curricula等比起来，这份指引" class="headerlink" title="和Open Source Society、freeCodeCamp curricula等比起来，这份指引?"></a>和Open Source Society、freeCodeCamp curricula等比起来，这份指引?</h3><p><a href="https://github.com/open-source-society/computer-science" target="_blank" rel="noopener">OSS指引</a>涵盖太多主题，在许多主题中推荐劣质资源，没有就特定课程哪些方面有价值提供原因或指引。我们努力对这份指引中的课程加以限制，仅仅包括那些你作为软件工程师 _确实需要了解的_，不论你的专业方向，并且对每门课程为何必要做出了解释以帮助你理解。</p><p>FreeCodeCamp主要关注编程，而不是计算机科学。至于你为什么要学习计算机科学，参见<a href="#为什么要学习计算机科学">上文</a>。如果你是个新手，我们建议先学 freeCodeCamp 的课程，一两年后再回归本指南。</p><h3 id="XX编程语言怎么样"><a href="#XX编程语言怎么样" class="headerlink" title="XX编程语言怎么样?"></a>XX编程语言怎么样?</h3><p>学习一门特定的编程语言和学习计算机科学的一个领域完全不在一个维度——相比之下，学习语言 _容易_ 且 _缺乏价值_。如果你已经了解了一些语言，我们强烈建议遵照我们的指引，然后在学习的空当中习得语言，或者暂且不管以后再说。如果你已经把编程学得不错了（比如学完了 _《计算机程序的构造和解释》_），尤其是如果你学习过<strong>编译器</strong>，那么面对一门新的语言，你只需要花一个周末稍多的时间即可基本掌握，之后你可以在工作中学习相关的类库/工具/生态。</p><h3 id="XX流行技术怎么样"><a href="#XX流行技术怎么样" class="headerlink" title="XX流行技术怎么样?"></a>XX流行技术怎么样?</h3><p>没有任何一种技术的重要程度可以达到学习其使用足以成为计算机科学教学的核心部分。不过，你对学习那门技术充满热情，这很不错。诀窍是先从特定的技术回退到基本的领域或概念，判断这门流行技术在技术的宏观大局中位于何处，然后才深入学习这门技术。</p><h3 id="为什么你们还在推荐SICP"><a href="#为什么你们还在推荐SICP" class="headerlink" title="为什么你们还在推荐SICP?"></a>为什么你们还在推荐SICP?</h3><p>先尝试读一下，有些人觉得 SICP 让人神魂颠倒，这在其他书很少见。如果你不喜欢，你可以尝试其他的东西，也许以后再回到 SICP。</p><h3 id="为什么你们还在推荐龙书"><a href="#为什么你们还在推荐龙书" class="headerlink" title="为什么你们还在推荐龙书?"></a>为什么你们还在推荐龙书?</h3><p>龙书依旧是内容最为完整的编译器单本书籍。由于过分强调一些如今不够时新的主题的细节，比如解析，这本书招致了恶评。然而事实上，这本书从未打算供人一页一页的学习，而仅仅是为了给教师准备一门课程提供足够的材料。类似地，自学者可以从书中量身按需挑选主题，或者最好依照公开课授课教师在课程大纲中的建议。</p><hr><h1 id="人工智能领域"><a href="#人工智能领域" class="headerlink" title="人工智能领域"></a>人工智能领域</h1><p>人工智能属于计算机科学的一个分支。传统的人工智能是研究人类如何产生智能，然后让机器学习人的思考方式去行为，现代人工智能概念提出者约翰·麦卡锡认为，机器不一定需要像人一样思考才能获得智能，而重点是让机器能够解决人脑所能解决的问题。</p><p>AI目前包含大量各种各样的子领域，范围从通用领域，如学习和感知，到专门领域，如下棋、证明数学定理、在复杂的街道上开车和诊断疾病。计算机尚需具有以下能力：</p><ul><li>自然语言处理(natural language processing)使之能成功地用语言交流；</li><li>知识表示(knowledge representation)以存储知道的或听到的信息；</li><li>自动推理(automated reasoning)以运用存储的信息来回答问题并推出新结论；</li><li>机器学习(machine learning)以适应新情况并检测和预测模式。</li><li>计算机视觉(computer vision)以感知物体；</li><li>机器人学(robotics)以操作和移动对象。</li></ul><p>人工智能核心技术发展的两条主线是脑科学和类脑科学的研究。[^2018中国人工智能发展报告]</p><p><img src="/blog//jiangxj.top/blog/2020/07/15/计算机科学/Users\JXJ\Documents\blog\hexo\source\_posts\计算机科学\人工智能发展历程.jpg" alt="人工智能发展历程"></p><h2 id="人工智能的基础"><a href="#人工智能的基础" class="headerlink" title="人工智能的基础"></a>人工智能的基础</h2><p>哲学：形式规则、思想如何从物理的大脑中产生、知识来自何方、知识如何导致行动</p><p>数学：逻辑、计算和概率。其中贝叶斯规则构成了人工智能系统中大多数用于不确定性推理的现代方法的基础。</p><p>经济：决策理论、博弈论、运筹学。决策理论把概率理论和效用理论结合起来，在概率描述能适当捕捉决策者制定者的环境的情况下，做出决策提供一个形式化且完整的框架。</p><p>神经科学：人脑和数字计算机。</p><p>心理学：认知理论。认知理论应该描述详细的信息处理机制，靠这个机制可以实现某种认知功能。</p><p>计算机工程：建造高效的计算机。</p><p>控制论：目标函数。</p><p>语言学：语言与思维的关联。知识表示，自然语言处理。[^人工智能·一种现代的方法(3rd)]</p><p>大数据：也是人工智能的基础，而使大数据转变为知识或生产力，离不开机器学习，机器学习可以说是人工智能的核心，是使得机器具有类似人的智能的根本途径。</p><p>机器学习和深度学习算法是人工智能中的两大热点，关系如下：</p><p><img src="/blog//jiangxj.top/blog/2020/07/15/计算机科学/Users\JXJ\Documents\blog\hexo\source\_posts\计算机科学\人工智能与相关研究领域的关系.png" alt="人工智能与相关研究领域的关系"></p><p>机器学习强调三个关键词：算法、模型、算力。其本质如下：</p><p><img src="/blog//jiangxj.top/blog/2020/07/15/计算机科学/Users\JXJ\Documents\blog\hexo\source\_posts\计算机科学\机器学习本质.png" alt="机器学习本质"></p><p>大数据时代，产生数据的能力空前高涨，如互联网、移动网、物联网、成千上万的传感器、穿戴设备、定位系统等，存储数据、处理数据等能力也得到了几何级数的提升。Hadoop、Spark技术为存储和处理大数据提供了有效的方法。</p><p>数据就是信息，其背后隐含着大量不易被我们感官识别的信息、知识、规律等，如何揭示这些信息、规则、趋势，需要用到数据挖掘。</p><p>机器学习的任务，就是在大数据量的基础上，发掘有用信息，其处理的数据越多，机器学习就越能体现出优势。如语言识别、图像识别、天气预测等等。</p><h2 id="机器学习经典书"><a href="#机器学习经典书" class="headerlink" title="机器学习经典书"></a>机器学习经典书</h2><h3 id="pattern-recognition-and-machine-learning"><a href="#pattern-recognition-and-machine-learning" class="headerlink" title="pattern recognition and machine learning"></a>pattern recognition and machine learning</h3><p>被认为是贝叶斯方法的扛鼎之作，系统地介绍了模式识别和机器学习领域内的概念和基础。整体目录如下：</p><ul><li>第一章 绪论 </li><li>第二章 概率分布</li><li>第三章 线性回归模型</li><li>第四章 线性分类模型</li><li>第五章 神经网络</li><li>第六章 核方法</li><li>第七章 稀疏核机器</li><li>第八章 图模型</li><li>第九章 混合模型和EM</li><li>第十章 近似判断</li><li>第十一章 采样方法</li><li>第十二章 连续潜在变量</li><li>第十三章 顺序数据</li><li>第十四章 组合模型</li></ul><p><a href="/download/PRML_英文版.pdf">pattern recognition and machine learning</a></p><p><a href="/download/PRML_中文版.pdf">模式识别与机器学习</a></p><p><a href="http://www.52nlp.cn/author/prml" target="_blank" rel="noopener">PRML读书会-我爱自然语言处理</a></p><h3 id="周志华-机器学习-西瓜书"><a href="#周志华-机器学习-西瓜书" class="headerlink" title="周志华-机器学习(西瓜书)"></a>周志华-机器学习(西瓜书)</h3><p>整体目录如下：</p><ul><li>第一章 绪论</li><li>第二章 模型评估与选择</li><li>第三章 线性模型</li><li>第四章 决策树</li><li>第五章 神经网络</li><li>第六章 支持向量机</li><li>第七章 贝叶斯分类</li><li>第八章 集成学习</li><li>第九章 聚类</li><li>第十章 降维与度量学习</li><li>第十一章 特征选择与稀疏学习</li><li>第十二章 计算学习理论</li><li>第十三章 半监督学习</li><li>第十四章 概率图模型</li><li>第十五章 规则学习</li><li>第十六章 强化学习</li></ul><p><a href="/download/周志华-机器学习.pdf">周志华-机器学习</a></p><p><a href="/download/周志华西瓜书公式推导.pdf">周志华-机器学习-公式推导</a></p><h3 id="李航-统计学习方法-一、二版"><a href="#李航-统计学习方法-一、二版" class="headerlink" title="李航-统计学习方法(一、二版)"></a>李航-统计学习方法(一、二版)</h3><p><a href="/download/统计学习方法李航.pdf">李航-统计学习方法</a></p><h2 id="深度学习经典书"><a href="#深度学习经典书" class="headerlink" title="深度学习经典书"></a>深度学习经典书</h2><h3 id="深度学习-花书"><a href="#深度学习-花书" class="headerlink" title="深度学习-花书"></a>深度学习-花书</h3><h3 id="stanford-CS231n课程"><a href="#stanford-CS231n课程" class="headerlink" title="stanford CS231n课程"></a>stanford CS231n课程</h3><p>stanford CS231n课程：CS231n的全称是<a href="http://vision.stanford.edu/teaching/cs231n/index.html" target="_blank" rel="noopener">CS231n: Convolutional Neural Networks for Visual Recognition</a>，即<strong>面向视觉识别的卷积神经网络</strong>。该课程是<a href="http://vision.stanford.edu/index.html" target="_blank" rel="noopener">斯坦福大学计算机视觉实验室</a>推出的课程。需要注意的是，目前大家说CS231n，大都指的是2016年冬季学期（一月到三月）的最新版本。本课程将深入讲解深度学习框架的细节问题，聚焦面向视觉识别任务（尤其是图像分类任务）的端到端学习模型。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
    
    <summary type="html">
    
      计算机课程和人工智能领域所学课程及经典参考书籍整理
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="课程" scheme="https://jiangxj.top/blog/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LSTM网络理解</title>
    <link href="https://jiangxj.top/blog/2020/07/07/LSTM%E7%BD%91%E7%BB%9C%E7%90%86%E8%A7%A3/"/>
    <id>https://jiangxj.top/blog/2020/07/07/LSTM网络理解/</id>
    <published>2020-07-06T16:00:00.000Z</published>
    <updated>2021-06-28T14:11:21.332Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Recurrent-Neural-Network"><a href="#Recurrent-Neural-Network" class="headerlink" title="Recurrent Neural Network"></a>Recurrent Neural Network</h2><p>传统的神经网络很难处理一件事——使用先前事件推断后续的事件。RNN解决了这个问题，是包含循环的网络，允许信息的持久化。</p><img src="/blog/2020/07/07/LSTM网络理解/RNN-unrolled.png" title="RNN-unrolled"><p>$A$正在读取输入$x_t$，并输出$h_t$。循环可以使得信息可以从当前步传递到下一步。</p><p>RNN can be thought of as multiple copies of the same network, each passing a message to a successor(接替者). Consider what happens if we unroll the loop:</p><img src="/blog/2020/07/07/LSTM网络理解/RNN-unrolled.png" title="RNN-unrolled"><p>This chain-like nature reveals that RNN are intimately related to sequences and lists(和序列和列表相关). </p><p>There have been incredible success applying RNNs to a variety of problems: <strong>Speech recognition, Language modeling, Translation, Image captioning…</strong></p><p>Essential to these successes is the use of “LSTMs”, a very special kind of RNN which works, for many tasks, much much better than standard version.</p><h2 id="The-problem-of-Long-Term-Dependencies"><a href="#The-problem-of-Long-Term-Dependencies" class="headerlink" title="The problem of Long-Term Dependencies"></a>The problem of Long-Term Dependencies</h2><p>One of the appeals of RNNs is the idea that they might be able to connect previous information to the present task.</p><p>In theory, RNNs are absolutely capable of handling  long-term dependencies. It’s entirely possible for the gap between the relevant information and the point where it is needed to become very large. While, as the gap grows, RNNs become unable to learn to connect the information.</p><p>例如：有一个语言模型用来基于先前的的词来预测下一个词，如果试着预测”the clouds are in the sky”最后的一个词，并不需要任何其他的上下文，显然最后的一个词就是sky。在这样的场景中，相关的信息和预测的词位置之间的间隔非常小，RNN可以学会使用先前的信息。</p><img src="/blog/2020/07/07/LSTM网络理解/RNN-shorttermdepdencies.png" title="RNN-shorttermdepdencies"><p>然而，对于一些更加复杂的场景，如预测”I grew up in France… I speak fluent French”最后的词，当前的信息建议下一个词可能是一种语言的名字，这需要先前提到的离当前位置很远的France的上下文。此时，相关信息和当前预测位置之间的间隔变得很大，在这个间隔不断变大时，RNN会丧失学习到连接如此远的信息的能力。虽然可以仔细挑选参数来解决这类toy problems。但在实践中，RNN肯定不能够成功学习到这些知识，Bengio,et al.(1994)等人对该问题进行了深入研究，发现一些使得RNN训练变得非常困难的根本原因。</p><img src="/blog/2020/07/07/LSTM网络理解/RNN-longtermdependencies.png" title="RNN-shorttermdepdencies"><p>LSTM don’t have this problem!</p><h2 id="LSTM-Networks"><a href="#LSTM-Networks" class="headerlink" title="LSTM Networks"></a>LSTM Networks</h2><p>Long Short Term Memory networks(LSTMs)是一种RNN特殊的类型，可以学习长期依赖信息。LSTM由<a href="http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf" target="_blank" rel="noopener">Hochreiter &amp; Schmidhuber(1997)</a>提出，并被<a href="https://scholar.google.com/citations?user=DaFHynwAAAAJ&amp;hl=en" target="_blank" rel="noopener">Alex Graves</a>进行了改良和推广。</p><p>LSTMs are <strong>explicitly designed</strong> to avoid the long-term dependency problem. Remembering info for long periods of time is practically their <strong>default behavior</strong>, not something they struggle to learn.</p><p>All RNNs have the form of a chain of repeating modules of neural networks(重复神经网络模块的链式结构). </p><p><strong>标准的RNN</strong></p><p>标准的RNN中，重复的模块只有一个简单的结构，如一个tanh层：</p><div style="width:70%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM3-SimpleRNN.png" title="LSTM3-SimpleRNN"></div><p><strong>LSTM</strong></p><p>LSTM重复模块不同于单一神经网络层，这里是有四个，以一种非常特殊的方式进行交互：</p><div style="width:70%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM3-chain.png" title="LSTM3-chain"></div><p><strong>LSTM解析图元素</strong></p><div style="width:70%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM2-notation.png" title="LSTM2-notation"></div><p>Neural Network Layer: 学习到的网络层</p><p>Pointwise Operation: pointwise操作，如向量的和</p><p>Vector Transfer: 传输一整个向量，从一个节点输出到其他节点的输入</p><p>Concatenate: 向量的连接</p><p>Copy: 内容被复制，然后分发到不同的位置</p><h2 id="The-Core-Idea-Behinds-LSTMs"><a href="#The-Core-Idea-Behinds-LSTMs" class="headerlink" title="The Core Idea Behinds LSTMs"></a>The Core Idea Behinds LSTMs</h2><p>LSTM的关键是细胞状态，水平线在图上方贯穿运行。</p><div style="width:70%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM3-C-line.png" title="LSTM3-C-line"></div><p>细胞状态类似于传送带，直接在整个链上运行，只有一些少量的线性交互，信息在上面流传保持不变会变得很容易。</p><p>LSTM通过精心设计的“<strong>门(gates)</strong>”结构来去除或者增加信息到细胞状态的能力。</p><p>门是一种让信息选择式的通过的方法，包含一个sigmoid神经网络层和一个pointwise乘法操作。</p><div style="width:70%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM3-gate.png" title="LSTM3-gate"></div><p>Sigmoid层输出0-1之间的数值，描述每个部分有多少量可以通过。0表示“不允许任何量通过”，1表示“允许任意量通过”。</p><p>LSTM有三个门，来保护和控制细胞状态。</p><h2 id="Step-by-Step-LSTM-Walk-Through"><a href="#Step-by-Step-LSTM-Walk-Through" class="headerlink" title="Step-by-Step LSTM Walk Through"></a>Step-by-Step LSTM Walk Through</h2><p>第一步<strong>决定从细胞状态中丢弃什么信息</strong>。通过<strong>忘记门层(forget gate layer)</strong>完成。该门读取$h_{t-1}$和$x_t$，输出一个0-1之间的数值给每个在细胞状态$C_{t-1}$中的数字。1表示完全保留，0表示完全舍弃。</p><div style="width:70%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM3-focus-f.png" title="LSTM3-focus-f"></div><p>第二步<strong>决定什么样的新信息被存放到细胞状态中</strong>。包含两个部分，一是sigmoid层（输入门层）决定什么值将要更新，还有一个是tanh层将创建一个新的候选值向量$\tilde{C}_t$，会被加入到状态中。</p><div style="width:70%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM3-focus-i.png" title="LSTM3-focus-i"></div><p>第三步<strong>确定更新信息</strong>。$C_{t-1}$更新为$C_t$。把旧状态与$f_t$相乘，丢弃掉确定需要丢弃的信息。接着加上$i_t \times \tilde{C}_t$，即是新的候选值，根据我们决定更新每个状态的程度进行变化。</p><div style="width:70%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM3-focus-C.png" title="LSTM3-focus-C"></div><p>第四步<strong>更新细胞状态</strong>。最终，确定输出什么值，这个输出将会基于我们的细胞状态，但也是一个过滤后的版本。</p><p>首先，运行一个sigmoid层来确定细胞状态的哪一部分将输出出去。接着，把细胞状态通过tanh进行处理，得到一个在-1到1之间的值，并将其与sigmoid门的输出相乘。最终，仅输出我们确定输出的那部分。</p><div style="width:70%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM3-focus-o.png" title="LSTM3-focus-o"></div><h2 id="Variants-on-LSTMs"><a href="#Variants-on-LSTMs" class="headerlink" title="Variants on LSTMs"></a>Variants on LSTMs</h2><p>以上介绍的是正常的LSTM结构，实际使用上，都会采用微小的变体。</p><p>1、流形的LSTM变体。</p><p>是由<a href="ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf" target="_blank" rel="noopener">Gers &amp; Schmidhuber(2000)</a>提出的，增加了”peephole connection”。让 门层 也会接受细胞状态的输入。</p><div style="width:70%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM3-var-peepholes.png" title="LSTM3-var-peepholes"></div><p>图例中是所有部分都加入了peephole到每个门上，也有加入部分的peephole。</p><p>2、使用coupled忘记和输入门。</p><p>不同于之前是分开确定什么忘记和需要添加什么新的信息，这里是一同做出决定。We only forget when we’re going to input something in its place. We only input new values to the state when we forget something older.</p><div style="width:50%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM3-var-tied.png" title="LSTM3-var-tied"></div><p>仅仅在输入的当前位置进行忘记，仅仅输入新的值到已经忘记的旧的信息状态里。</p><p>3、Gated Recurrent Unit (GRU)</p><p>是由<a href="http://arxiv.org/pdf/1406.1078v3.pdf" target="_blank" rel="noopener">Cho,et al.(2014)</a>提出的。将忘记门和输入门合成一个单一的 <strong>更新门</strong>。同样还混合了细胞状态和隐藏状态以及其他一些改动。最终的模型比标准的LSTM模型更加简单。</p><div style="width:50%;margin:auto"><img src="/blog/2020/07/07/LSTM网络理解/LSTM3-var-GRU.png" title="LSTM3-var-GRU"></div><p>还有很多其他类型变体形式，如<a href="http://arxiv.org/pdf/1508.03790v2.pdf" target="_blank" rel="noopener">Yao,et al.(2015)</a>提出的Depth Gated RNN。<a href="http://arxiv.org/pdf/1402.3511v1.pdf" target="_blank" rel="noopener">Koutnik, et al.(2014)</a>提出的Clockwork RNN。<a href="http://arxiv.org/pdf/1503.04069.pdf" target="_blank" rel="noopener">Greff, et al.(2015)</a>给出了流行的LSTM变体的比较，结论是基本一样。<a href="http://jmlr.org/proceedings/papers/v37/jozefowicz15.pdf" target="_blank" rel="noopener">Jozefowicz,et al.(2015)</a>在超过10000种RNN架构上进行了测试，发现一些架构在某些任务上也取得了比LSTM更好的结果。</p><p><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">参考资料——colah’s blog</a></p>]]></content>
    
    <summary type="html">
    
      LSTM网络原理理解
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LSTM网络" scheme="https://jiangxj.top/blog/tags/LSTM%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据科学中需要用到的数学</title>
    <link href="https://jiangxj.top/blog/2020/06/10/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%AD%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    <id>https://jiangxj.top/blog/2020/06/10/数据科学中需要用到的数学/</id>
    <published>2020-06-10T02:22:20.000Z</published>
    <updated>2021-06-02T03:53:14.375Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>摘自Benjamin Obi Tayo Ph.D.博文</p></blockquote><img src="/blog/2020/06/10/数据科学中需要用到的数学/1_P7GJzEC-0f_IqbQH677uVw.png" title="数据科学中用到的数学"><h1 id="I-Introduction"><a href="#I-Introduction" class="headerlink" title="I. Introduction"></a>I. Introduction</h1><p>If you are a data science aspirant, you no doubt have the following questions in mind:</p><p><strong><em>Can I become a data scientist with little or no math background?\</em></strong></p><p><strong><em>What essential math skills are important in data science?\</em></strong></p><p>There are so many good packages that can be used for building predictive models or for producing data visualizations. Some of the most common packages for descriptive and predictive analytics include:</p><ul><li>Ggplot2</li><li>Matplotlib</li><li>Seaborn</li><li>Scikit-learn</li><li>Caret</li><li>TensorFlow</li><li>PyTorch</li><li>Keras</li></ul><p>Thanks to these packages, anyone can build a model or produce a data visualization. However, very solid background knowledge in mathematics is essential for fine-tuning your models to produce reliable models with optimal performance. It is one thing to build a model, it is another thing to interpret the model and draw out meaningful conclusions that can be used for data-driven decision making. It’s important that before using these packages, you have an understanding of the mathematical basis of each, that way you are not using these packages simply as black-box tools.</p><h1 id="II-Case-Study-Building-A-Multiple-Regression-Model"><a href="#II-Case-Study-Building-A-Multiple-Regression-Model" class="headerlink" title="II. Case Study: Building A Multiple Regression Model"></a><strong>II. Case Study: Building A Multiple Regression Model</strong></h1><p>Let’s suppose we are going to be building a multi-regression model. Before doing that, we need to ask ourselves the following questions:</p><p><em>How big is my dataset?</em></p><p><em>What are my feature variables and target variable?</em></p><p><em>What predictor features correlate the most with the target variable?</em></p><p><em>What features are important?</em></p><p><em>Should I scale my features?</em></p><p><em>How should my dataset be partitioned into training and testing sets?</em></p><p><em>What is principal component analysis (PCA)?</em></p><p><em>Should I use PCA for removing redundant features?</em></p><p><em>How do I evaluate my model? Should I used R2 score, MSE, or MAE?</em></p><p><em>How can I improve the predictive power of the model?</em></p><p><em>Should I use regularized regression models?</em></p><p><em>What are the regression coefficients?</em></p><p><em>What is the intercept?</em></p><p><em>Should I use non-parametric regression models such as KNeighbors regression or support vector regression?</em></p><p><em>What are the hyperparameters in my model, and how can they be fine-tuned to obtain the model with optimal performance?</em></p><p>Without a sound math background, you wouldn’t be able to address the questions raised above. The bottom line is that in data science and machine learning, mathematical skills are as important as programming skills. As a data science aspirant, it is therefore essential that you invest time to study the theoretical and mathematical foundations of data science and machine learning. Your ability to build reliable and efficient models that can be applied to real-world problems depends on how good your mathematical skills are. To see how math skills are applied in building a machine learning regression model, please see this article: <a href="https://medium.com/swlh/machine-learning-process-tutorial-222327f53efb" target="_blank" rel="noopener">Machine Learning Process Tutorial.</a></p><p>Let’s now discuss some of the essential math skills needed in data science and machine learning.</p><h1 id="III-Essential-Math-Skills-for-Data-Science-and-Machine-Learning"><a href="#III-Essential-Math-Skills-for-Data-Science-and-Machine-Learning" class="headerlink" title="III. Essential Math Skills for Data Science and Machine Learning"></a>III. Essential Math Skills for Data Science and Machine Learning</h1><h2 id="1-Statistics-and-Probability"><a href="#1-Statistics-and-Probability" class="headerlink" title="1. Statistics and Probability"></a>1. Statistics and Probability</h2><p>Statistics and Probability is used for visualization of features, data preprocessing, feature transformation, data imputation, dimensionality reduction, feature engineering, model evaluation, etc.</p><p>Here are the topics you need to be familiar with: <strong>Mean, Median, Mode, Standard deviation/variance, Correlation coefficient and the covariance matrix, Probability distributions (Binomial, Poisson, Normal), p-value, Baye’s Theorem (Precision, Recall, Positive Predictive Value, Negative Predictive Value, Confusion Matrix, ROC Curve), Central Limit Theorem, R_2 score, Mean Square Error (MSE), A/B Testing, Monte Carlo Simulation*</strong></p><h2 id="2-Multivariable-Calculus"><a href="#2-Multivariable-Calculus" class="headerlink" title="2. Multivariable Calculus"></a>2. Multivariable Calculus</h2><p>Most machine learning models are built with a dataset having several features or predictors. Hence, familiarity with multivariable calculus is extremely important for building a machine learning model.</p><p>Here are the topics you need to be familiar with: <strong><em>Functions of several variables; Derivatives and gradients; Step function, Sigmoid function, Logit function, ReLU (Rectified Linear Unit) function; Cost function; Plotting of functions; Minimum and Maximum values of a function\</em></strong></p><h2 id="3-Linear-Algebra"><a href="#3-Linear-Algebra" class="headerlink" title="3. Linear Algebra"></a>3. Linear Algebra</h2><p>Linear algebra is the most important math skill in machine learning. A data set is represented as a matrix. Linear algebra is used in data preprocessing, data transformation, dimensionality reduction, and model evaluation.</p><p>Here are the topics you need to be familiar with: <strong><em>Vectors; Norm of a vector; Matrices; Transpose of a matrix; The inverse of a matrix; The determinant of a matrix; Trace of a Matrix; Dot product; Eigenvalues; Eigenvectors\</em></strong></p><h2 id="4-Optimization-Methods"><a href="#4-Optimization-Methods" class="headerlink" title="4. Optimization Methods"></a>4. Optimization Methods</h2><p>Most machine learning algorithms perform predictive modeling by minimizing an objective function, thereby learning the weights that must be applied to the testing data in order to obtain the predicted labels.</p><p>Here are the topics you need to be familiar with: <strong><em>Cost function/Objective function; Likelihood function; Error function; Gradient Descent Algorithm and its variants (e.g. Stochastic Gradient Descent Algorithm)\</em></strong></p><h1 id="IV-Summary-and-Conclusion"><a href="#IV-Summary-and-Conclusion" class="headerlink" title="IV. Summary and Conclusion"></a>IV. Summary and Conclusion</h1><p>In summary, we’ve discussed the essential math and theoretical skills that are needed in data science and machine learning. There are several free online courses that will teach you the necessary math skills that you need in data science and machine learning. As a data science aspirant, it’s important to keep in mind that the theoretical foundations of data science are very crucial for building efficient and reliable models. You should, therefore, invest enough time to study the mathematical theory behind each machine learning algorithm.</p><h1 id="V-References"><a href="#V-References" class="headerlink" title="V. References"></a>V. References</h1><p><a href="https://medium.com/towards-artificial-intelligence/linear-regression-basics-for-absolute-beginners-68ed9ff980ae" target="_blank" rel="noopener">Linear Regression Basics for Absolute Beginners.</a></p><p><a href="https://medium.com/towards-artificial-intelligence/mathematics-of-principal-component-analysis-with-r-code-implementation-595a340908fa" target="_blank" rel="noopener">Mathematics of Principal Component Analysis with R Code Implementation.</a></p><p><a href="https://medium.com/swlh/machine-learning-process-tutorial-222327f53efb" target="_blank" rel="noopener">Machine Learning Process Tutorial.</a></p>]]></content>
    
    <summary type="html">
    
      data science中用到的数学
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="data science" scheme="https://jiangxj.top/blog/tags/data-science/"/>
    
      <category term="math" scheme="https://jiangxj.top/blog/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu代理软件Qv2ray使用</title>
    <link href="https://jiangxj.top/blog/2020/05/27/ubuntu%E4%BB%A3%E7%90%86%E8%BD%AF%E4%BB%B6Qv2ray%E4%BD%BF%E7%94%A8/"/>
    <id>https://jiangxj.top/blog/2020/05/27/ubuntu代理软件Qv2ray使用/</id>
    <published>2020-05-27T09:20:03.000Z</published>
    <updated>2020-06-18T02:07:45.293Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Qv2ray是一款全平台的代理软件，简单配置就可以使用。</p><p><a href="https://github.com/Qv2ray/Qv2ray" target="_blank" rel="noopener">官方github地址</a></p><p><a href="https://qv2ray.github.io/" target="_blank" rel="noopener">官方手册</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官方库下载release的版本（下的2.5.0的），下载的是Ubuntu的程序包：</p><p><code>Qv2ray.v2.5.0.linux-x64.AppImage</code></p><p>下载的是<code>.appimage</code>文件，右键属性，在权限一栏，勾选上<code>允许作为程序执行文件</code>，双击打开，进入软件。</p><h3 id="v2ray内核设置"><a href="#v2ray内核设置" class="headerlink" title="v2ray内核设置"></a>v2ray内核设置</h3><p>进入软件后，点击首选项，设置v2ray内核。</p><p>这里首先需要下载<a href="https://github.com/v2ray/v2ray-core/releases/" target="_blank" rel="noopener">v2ray-core</a></p><p>然后将其放到Qv2ray的资源目录中。配置如下：</p><img src="/blog/2020/05/27/ubuntu代理软件Qv2ray使用/qv2ray1.png" title="配置方法"><h3 id="加入订阅链接"><a href="#加入订阅链接" class="headerlink" title="加入订阅链接"></a>加入订阅链接</h3><p>直接订阅之后，连接服务器即可</p><p>Qv2ray的代理端口配置：</p><img src="/blog/2020/05/27/ubuntu代理软件Qv2ray使用/qv2ray2.png" title="代理端口配置"><h3 id="系统代理端口设置"><a href="#系统代理端口设置" class="headerlink" title="系统代理端口设置"></a>系统代理端口设置</h3><img src="/blog/2020/05/27/ubuntu代理软件Qv2ray使用/Qv2ray3.png" title="系统代理端口设置"><h3 id="浏览器的代理配置"><a href="#浏览器的代理配置" class="headerlink" title="浏览器的代理配置"></a>浏览器的代理配置</h3><p>使用的是chrome插件：switchOmega 。配置如下：</p><img src="/blog/2020/05/27/ubuntu代理软件Qv2ray使用/qv2ray4.png" title="浏览器代理配置"><h3 id="windows端配置"><a href="#windows端配置" class="headerlink" title="windows端配置"></a>windows端配置</h3><p>下载clash for windows安装后，配置一键导入即可。</p><p><a href="https://javid.cn/qv2ray/" target="_blank" rel="noopener">本文参考来源</a></p><p>附：</p><p>在Ubuntu18.04上用<a href="https://github.com/jiangxufeng/v2rayL" target="_blank" rel="noopener">v2rayL</a>代理软件<a href="https://javid.cn/ubuntuproxy/" target="_blank" rel="noopener">教程</a>。需要的环境较为苛刻（Ubuntu18.04+python3.6），一直没能在Ubuntu16.04上配置成功.</p>]]></content>
    
    <summary type="html">
    
      ubuntu16.04平台使用Qv2ray代理软件
    
    </summary>
    
      <category term="教程" scheme="https://jiangxj.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Qv2ray" scheme="https://jiangxj.top/blog/tags/Qv2ray/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda教程</title>
    <link href="https://jiangxj.top/blog/2020/05/20/Anaconda%E6%95%99%E7%A8%8B/"/>
    <id>https://jiangxj.top/blog/2020/05/20/Anaconda教程/</id>
    <published>2020-05-19T16:00:00.000Z</published>
    <updated>2020-05-15T02:23:46.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="修改conda-的镜像源"><a href="#修改conda-的镜像源" class="headerlink" title="修改conda 的镜像源"></a>修改conda 的镜像源</h2><p>（现在不可用）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>此时，在目录 C:\Users&lt;你的用户名&gt; 下就会生成配置文件.condarc，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br></pre></td></tr></table></figure><h2 id="jupyter-notebook使用"><a href="#jupyter-notebook使用" class="headerlink" title="jupyter notebook使用"></a>jupyter notebook使用</h2><p>创建带jupyter notebook内核的虚拟环境：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name py37_Pytorch python=<span class="number">3.7</span> ipykernel</span><br></pre></td></tr></table></figure><p>关联和conda的环境和包：</p><p><code>conda install nb_conda</code></p><p>Markdown生成目录：</p><p><code>conda install -c conda-forge jupyter_contrib_nbextensions</code></p><p><a href="https://www.jianshu.com/p/91365f343585" target="_blank" rel="noopener">jupyter notebook使用教程</a></p><p>在虚拟环境下创建kernel文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install</span> -n 环境名称 ipykernel</span><br></pre></td></tr></table></figure><p>将环境写入jupyter notebook的kernel中</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m ipykernel install --<span class="keyword">user</span> <span class="title">--name</span> 环境名称 --display-name <span class="string">"Python (环境名称)"</span></span><br></pre></td></tr></table></figure><h2 id="pip-安装-PyTorch步骤"><a href="#pip-安装-PyTorch步骤" class="headerlink" title="pip 安装 PyTorch步骤"></a>pip 安装 PyTorch步骤</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install https://download.pytorch.org/whl/cpu/torch<span class="number">-1.0</span><span class="number">.0</span>-cp37-cp37m-win_amd64.whl</span><br></pre></td></tr></table></figure><p>安装版本为<code>torch-1.0.0</code>，CPU版本，没有CUDA，python3.x版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --no-deps torchvision</span><br></pre></td></tr></table></figure><p>不使用：<code>pip3 install torchvision</code>，会报错。</p><p><a href="https://redstonewill.com/1948/" target="_blank" rel="noopener">PyTorch安装</a></p><h2 id="pip和conda区别"><a href="#pip和conda区别" class="headerlink" title="pip和conda区别"></a>pip和conda区别</h2><p>conda是一种通用包管理系统，是一个与语言无关的跨平台的环境管理器，可以构建和管理任何语言的任何类型的软件。因此适用于python包。</p><p>pip代表pip install packages，是python官方认可的包管理器，最常用于安装python包索引（PyPI）上的发布的包。</p><p>conda install包，默认是安装在base（anaconda）环境下，conda在指定的环境下安装包：</p><p><code>conda install -n env_name pandas</code>。</p><p>anaconda是一个python的发行版，conda是一个包管理器。</p><h2 id="pip和pip3区别"><a href="#pip和pip3区别" class="headerlink" title="pip和pip3区别"></a>pip和pip3区别</h2><p>在安装库numpy，pip3 install numpy和pip install numpy命令效果一致的，但当有多个版本的python虚拟环境时，用pip3可以自动区别用python3来安装库文件，避免发生和python2的冲突。</p><p>若只安装了python3，pip和pip3是一样的效果，安装python3后，会自动安装pip3，添加scripts到环境变量(避免出现不是内部或外部命令问题)。</p><p>若多版本python存在，使用pip install ，新安装的库文件会放在目录：<code>python2.x/site_packages</code>中；使用 pip3 install ，新安装的库文件会放在目录：<code>python3.x/site-packages</code>中。</p><h2 id="一些常用命令"><a href="#一些常用命令" class="headerlink" title="一些常用命令"></a>一些常用命令</h2><p><code>conda activate env_name</code>激活环境，当前被激活环境前有*号</p><p><code>conda deactivate env_name</code>关闭环境</p><p>（Linux下）：</p><p><code>source activate/deactivate env_name</code></p><p><code>conda remove -n env_name --all</code>删除环境</p><p><code>conda create --name env_name python=3.x</code>创建一个基于python3.x的名为env_name的虚拟环境，同样正对于python2.x版本。</p><p><code>conda env list</code>查看所有安装的环境</p><p><code>conda install requests</code>安装包</p><p><code>conda install -n env_name numpy</code>安装在指定的环境下的包，若不指定，则是安装在当前活跃环境，也可通过-c指定某个channel来安装。</p><p><code>conda list</code>查看所安装的包</p><p><code>conda update requests</code>包更新</p><p><code>conda update -n env_name packages</code>指定环境下的包更新</p><p><code>conda remove requests</code>删除包</p><p><code>conda list -n env_name</code>查看指定环境下的已安装包</p><p><code>conda search numpy</code>查找package信息</p><hr><p>conda将conda、python等都看成packages，都可以通过conda来管理conda和python版本，如：</p><p><code>conda update conda</code>更新conda</p><p><code>conda update anaconda</code>更新当前环境下的anaconda。</p><p><code>conda update python</code>假设当前环境下的python为3.7版本，会升级为3.7.x系列的最新版本、</p><p>Anaconda的bin目录加入PATH，可能有不同的~/anaconadx/bin，：</p><p><code>echo &#39;export PATH = &quot;~/anaconda3/bin:$PATH&quot;&#39; &gt;&gt; ~/.bashrc</code>      Linux下的添加命令。</p><p>运行<code>conda --version</code>检查是否正确。</p><p><a href="https://www.jianshu.com/p/2f3be7781451#" target="_blank" rel="noopener">Anaconda基本使用总结</a></p>]]></content>
    
    <summary type="html">
    
      Anaconda使用简单教程
    
    </summary>
    
      <category term="教程" scheme="https://jiangxj.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>概率神经网络和粒子群算法</title>
    <link href="https://jiangxj.top/blog/2020/05/20/%E6%A6%82%E7%8E%87%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
    <id>https://jiangxj.top/blog/2020/05/20/概率神经网络-粒子群算法/</id>
    <published>2020-05-19T16:00:00.000Z</published>
    <updated>2020-05-15T02:32:42.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概率神经网络"><a href="#概率神经网络" class="headerlink" title="概率神经网络"></a>概率神经网络</h1><p>Specht.D.F根据已有的神经网络理论同时融入概率学的相关知识，提出了概率神经网络的理论。概率神经网络是一种前馈神经网络，充分利用贝叶斯准则理论，能够进行较为准确的数据分类。在贝叶斯决策中，引用了概率密度函数的知识，同时充分结合了贝叶斯最小风险准则，实现了对数据的分类研究。概率神经网络已广泛应用于数据分类、模式识别、图像或语音识别等领域。</p><p>概率神经网络参数较少且内部的隐藏层不需要人为的设定，便于构建网络模型。同时使用贝叶斯准则大大提高了模式分类的准确性。在训练数据充足的情况下，能够很好地表达输入数据与输出数据的内在联系，即使在网络工作的过程中需要加入新的训练样本，网络的整体结构亦不需改进。</p><p><strong>概率神经网络与BP网络比较</strong>：</p><p>概率神经网络采用了 贝叶斯最小风险准则，在模式分类上具有较高的正确率，在故障诊断上有明显优势。</p><p>概率神经网络结构简单，需要调节的参数较少，更容易收敛。</p><p>根据贝叶斯理论，在一般情况下，概率神经网络的收敛值较为固定，达到了对故障知识的充分利用，结果的可信程度较高，而BP网络的输入到输出的过程中，存在不可预知的规则，受主观影响较大，结果存在不稳定的情况。</p><p>概率神经网络在工作过程中，增加或删除某些样本，网络的整体结构不会发生过大的变化，仅仅就是对某一层节点数的增加或删除。对于BP网络，增加或减少训练数据后，网络层与层之间的权值很可能发生改变，如不及时进行更新，输出结果很可能会偏离期望值。BP网络的训练数据的改变意味着整个网络的改变。</p><h1 id="粒子群算法"><a href="#粒子群算法" class="headerlink" title="粒子群算法"></a>粒子群算法</h1><p>粒子群算法(Particle Swarm Optimization)属于仿生学的优化算法。核心思想是从人为设定的随机解出发，通过不断的迭代寻找最优的适应度值。PSO没有像遗传算法那样的变异、交叉等复杂过程。</p><p><strong>算法原理</strong>：</p><p>在一个$D$维空间内，种群由$n$个粒子组成$X=(X_1,X_2,\dots,X_n)$，第$i$个粒子表示为1个$D$维的向量$Xi = (X_{i1},X_{i2},\dots,X_{iD})^T$，表示第$i$个粒子在$D$维空间中的位置，即问题的一个潜在解，由目标函数可以求出每个粒子的适应度值。第$i$个粒子的速度为$Vi = (V_{i1},V_{i2},\dots,V_{iD})^T$,其个体极值为$Pi = (P_{i1},P_{i2},\dots,P_{iD})^T$，群体极值为$P_g = (P_{g1},P_{g2},\dots,P_{gD})^T$。</p><p>在每次迭代过程中，粒子通过个体极值与群体极值更新自身的速度和位置，即：<br>$$<br>V_{id}^{k+1} = wV_{id}^k +c_1r_1(P_{id}^k - X_{id}^k) +c_2r_2(P_{gd}^k -X_{id}^k)<br>$$</p><p>$$<br>X_{id}^{k+1} = X_{id}^k + V_{id}^{k+1}<br>$$</p><p>其中：$i =1,2,\dots,n$，$n$表示群体的粒子数目</p><p>​           $d=1,2,\dots,D$,$D$是解空间维数</p><p>​           $k$表示当前迭代次数</p><p>​           $w$表示惯性权重</p><p>​           $X_{id}^k$为当前粒子在迭代到第$k$次的位置分量</p><p>​           $V_{id}^k$为当前粒子在迭代到第$k$次的速度分量</p><p>​          $P_{id}^k$为当前粒子在迭代到第$k$次的个体历史最优分量</p><p>​          $P_{gd}^k$为当前粒子在迭代到第$k$次的群体历史最优分量</p><p>​          $r_1,r_2$为[0,1]之间的随机数</p><p>​          $c_1,c_2$为非负的常数，称为学习因子。分别调节自身的认知能力和对群体的认知能力，对粒子寻找到最优值有重要作用。</p><p>在粒子在寻优过程中可能出现盲目搜索的现象，需要将粒子搜索的速度和位置限定在一定的区间内保证粒子在可行解空间内有目的的搜索。</p><p><strong>算法流程</strong>：</p><p>主要包括：初始化粒子、更新粒子的位置和速度、最优值的确定以及结束情况的判断。</p><ol><li>种群初始化。主要是在可行的解空间内设置：种群规模、学习因子、粒子的位置和速度、最大迭代次数、粒子执行搜索的空间范围和速度范围等参数。</li><li>适应度函数的建立。结合优化类型确定适应度函数，然后计算每一个粒子当前的适应度值，通过适应度值，确定粒子的群体极值与个体极值</li><li>对粒子的位置和速度进行更新</li><li>个体极值的确定，对于群体的每一个粒子，将当前适应度值与粒子自身历史适应度值进行比较。若优于历史适应度值，将当前适应度值作为个体极值，反之历史极值仍为个体极值</li><li>群体极值的确定。对于群体中的每一个粒子，将当前的适应度值与整个种群的最优适应度值进行比较。若优于群体最优适应度值，则将当前适应度值作为群体极值，反之，原群体极值仍为群体最优适应度值</li><li>对迭代是否结束进行判定，若达到预先设定的误差或者达到了最大的迭代次数，循环结束，输出得到最优值，反之，返回2继续执行。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">op0=&gt;operation: 粒子群的初始化</span><br><span class="line">op1=&gt;operation: 计算粒子的适应度值</span><br><span class="line">op2=&gt;operation: 根据适应度值更新个体的极值和群体极值</span><br><span class="line">op3=&gt;operation: 更新粒子的速度和位置</span><br><span class="line">cond=&gt;condition: 满足终止条件</span><br><span class="line"></span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">st-&gt;op0-&gt;op1-&gt;op2-&gt;op3-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no) -&gt;op1</span><br></pre></td></tr></table></figure><p><strong>粒子群算法在解空间内存有如下特点</strong>：</p><ol><li>算法无论在初始化还是寻优等方面都有一定的随机性，这样可以使得找到的结果尽可能地接近最优值，利于解决复杂问题。</li><li>对初值地设定随机，其变化不影响最终地结果</li><li>目标函数是粒子群算法地寻优依据，函数包括多种类型，包括不可微地函数</li><li>粒子群算法作为一种群体智能优化算法，过程易理解，适应性强</li><li>与GA的“优胜劣汰”不同，粒子群算法不遵循此项规则，从算法开始到结束，种群中的每一个粒子都参与算法寻优的全过程，使粒子群算法能够很好的表达种群的信息，寻优结果要优于遗传算法。</li></ol>]]></content>
    
    <summary type="html">
    
      概率神经网络和粒子群算法原理简介
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>编译器原理简介</title>
    <link href="https://jiangxj.top/blog/2020/05/20/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <id>https://jiangxj.top/blog/2020/05/20/编译器/</id>
    <published>2020-05-19T16:00:00.000Z</published>
    <updated>2020-05-15T02:31:48.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、概念</p><p>广义上说，能把高级语言转化为低级语言的都算编译器，编译的存在就是为高级语言服务。</p><p>计算机语言分为三层，最底层，机器语言，即0和1；往上是汇编语言，指明操作什么部件干什么活，是对机器干活的描述，再往上是高级语言，人不用理机器干什么活，只需要明确地表达自己要达到什么目的。</p><p>对于CPU而言，只认识二进制的机器码，指挥CPU运行程序，需要一个“翻译”，将代码翻译成机器码给CPU，让它知道如何执行你的程序。常见的“翻译”工具有：汇编器、编译器、解释器。</p><p>汇编器：将汇编代码直接翻译成机器码，速度快，但可读性差，写大型程序很难实现。</p><p>编译器：将常用的高级语言，如Java/c++等，翻译成机器码，编译很慢，但是执行起来很快。</p><p>解释器：程序不需要编译，程序在运行时才翻译成机器码，每执行一次都要翻译一次。效率低，运行慢，典型的解释行语言如PHP/JS/Python。</p><p>2、Java代码的执行</p><p>依赖于Java虚拟机(JVM)，JVM能直接识别字节码。Java代码经过编译会产生class文件，即字节码文件，再交由JVM处理。当字节码被放到某种指令集的机器上，由运行环境中的虚拟机将字节码直接编译成该指令集的机器码然后执行，所以不管指令集是什么，只要更换运行环境中的虚拟机就能执行，从而实现跨平台性。</p><p><img src="https://pic1.zhimg.com/80/v2-3eed6368f57d6791327eed3536a58ab4_hd.jpg" alt="img"></p><p>以hotspot为例，有几种翻译形式：</p><p>（1）解释执行</p><p>逐条将字节码翻译成机器码并执行；无需等待编译</p><p>（2）即时编译（just-in-time,JIT）</p><p>将一个方法中包含的所有字节码编译成机器码后再执行；运行速度更快</p><p>在ART中，不要求跨平台性，直接在一个平台上运行，可以不用实时编译浪费时间。在ART中，直接将字节码在安装时编译为机器码，在安卓开发中，ART实际上是在机器上实现的，和编译器没有关系，编译器编译的还是字节码。</p><p>3、Android代码执行</p><p>开发Android目前最多的还是Java，Android工程中的Java源文件经过编译也是生成class文件，最后打包为DEX字节码文件，负责将DEX字节码翻译成字节码的是Dalvik或者ART。</p><p>在Android5.0之前，是Dalvik的天下，Dalvik是解释执行加上JIT，每次app运行时，动态的将一部分Dalvik字节码解释为机器码，随着app的运行，更多的字节码被编译和缓存。因为JIT只编译了一部分代码，具有更小的内存占用和更少的设备物理空间占用。但是边解释边执行，效率低下。</p><p>Android4.4开始，引入ART，到5.0，正式代替Dalvik，ART使用的是AOT(Ahead of time)的编译方式，即在应用安装过程中，就将所有的Dex字节码编译成机器码存储在设备空间中，完全抛弃JIT。带来的好处：</p><ul><li>app运行更快，直接运行机器码</li><li>减少应用的启动时间，本地代码可以直接执行</li><li>节省电量消耗，不需要再去一行一行解释字节码</li><li>增强了垃圾回收</li><li>增强了开发者工具</li></ul><p>但是，在安装期间翻译字节码，安装过程会很长，尤其是对一些大型应用来说，另外，安装过程中翻译出来的机器码占用了更大的机身存储空间。</p><p>Android7.0，又加入了JIT，一个具备代码分析功能的即时编译器，根据二八定律，经常运行的热点代码可能只占20%，甚至更少，没有必要通过AOT提前将所有的字节码翻译成机器码。安装过程中，放弃AOT，加快安装速度，初次使用时需要解释执行。使用app时，JIT开始分析代码，在合适的时候将字节码翻译成机器码，在Android应用运行时持续提高其性能，设备空闲时，AOT发挥作用，将热点代码翻译成机器码并保存下来，进一步提高运行效率。</p><p>现在的Android是 解释执行、JIT、AOT共存的。所做的无非是 安装速度、空间占用和运行速度的平衡。</p><p>4、现代编译器结构</p><p>现代编译器通常分为前端和后端，前端将高级语言转化为中间的统一代码，然后由后端将中间代码编译为机器代码，处理硬件架构相关的优化。</p><p><img src="https://pic4.zhimg.com/80/v2-12a256d50907445c4f9ef18f6def57b3_hd.jpg" alt="img"></p><p>当前最主要的编译器有两个：GCC和llvm。早在iOS4时xcode的前端有两种，gcc和clang，后端是llvm和GCC，后来统一为clang+llvm，而目前NDK前端也有GCC和clang，后端为llvm。但安卓已经全面放弃GCC全面转向clang。也就是说，当我们考虑一个现代编译器时，必须前后端同时考虑。</p><p>5、方舟编译器</p><p>IOS的快、流畅是建立在苹果强大的A系列处理器，精心设计的swift语言，继承swiftc编译命令的xcode工具，高效的IOS系统，严格的权限管理等基础上，称之为软硬件集合一体化的典范。</p><p>方舟编译器舍弃了现在Android中的ART虚拟机，不需要编译为字节码文件（DEX），在生成apk的安装包时直接编译生成的适合的机器码，在终端设备上安装后直接就可以执行，省去虚拟机，省去JIT和AOT。</p><p>PPT 中最后一句话是 “希望 APP 厂商尽快使用” ，并不是手机厂商，所以不排除方舟编译器可以直接将 Apk ，或者说 Apk 中的 DEX 打包成机器码格式。但由于机器码并不是平台兼容的，所以并不能确定方舟编译器是否必须要绑定 EMUI。</p><p>方舟编译器是为了改变现有的代码和编程习惯的基础上进行编译的优化，使得APP运行更为流畅，最终的目的是成为一个跨硬件平台、跨系统、跨语言的软件编译平台。编译器是一个桥梁，连接着上层的开发语言与底层的硬件，又与操作系统紧密结合，掌握了编译器，更换开发语言，更换硬件架构甚至更换操作系统都会有很大的帮助。</p><p><a href="https://zhuanlan.zhihu.com/p/62152260" target="_blank" rel="noopener">参考资料1</a></p><p><a href="https://blog.csdn.net/weixin_44946052/article/details/89441380" target="_blank" rel="noopener">参考资料2</a></p><p><a href="https://zhuanlan.zhihu.com/p/65307730" target="_blank" rel="noopener">参考资料3</a></p>]]></content>
    
    <summary type="html">
    
      编译器原理简介&amp;方舟编译器
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo多终端同步</title>
    <link href="https://jiangxj.top/blog/2020/05/18/hexo%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5/"/>
    <id>https://jiangxj.top/blog/2020/05/18/hexo多终端同步/</id>
    <published>2020-05-18T07:27:23.000Z</published>
    <updated>2021-01-13T10:21:36.408Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><p>两台终端，其中一台已经被配置hexo+github博客平台（win平台）。</p><p>安装好node和hexo，git环境</p><p>其中node使用<code>nvm</code>进行安装：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">list</span>  <span class="comment">#查找所有的node版本</span></span><br><span class="line">nvm use &lt;版本号&gt;  <span class="comment">#切换使用指定的版本</span></span><br></pre></td></tr></table></figure><h2 id="备份本地博客的文件"><a href="#备份本地博客的文件" class="headerlink" title="备份本地博客的文件"></a>备份本地博客的文件</h2><p>由于 Github 上保存的只是生成的网页静态文件，因此需要新建一个分支保存本地原始文件，方便在不同的电脑上写博客。需要解决备份问题。</p><p>机制是这样的，<code>hexo d</code>上传部署到GitHub的是hexo编译后的文件，用来生成网页的，不包含源文件。即上传的是在本地目录里自动生成的<code>.deploy_git</code>里面。其它文件，包括写在<code>source</code>里面的，和配置文件，主题文件，都没有上传到GitHub上。</p><p>所以可以利用git的分支管理，将源文件上传到GitHub的同一仓库的另一个分支即可。</p><p>创建两个分支：master 与 source，<br>在博客目录下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd blog       <span class="comment">#注意要删除已经存在.git隐藏文件夹</span></span><br><span class="line"><span class="variable">$ </span>git init        <span class="comment">#在当前目录新建一个git代码库</span></span><br><span class="line"><span class="variable">$ </span>git add .     <span class="comment">#添加blog目录所有文件</span></span><br><span class="line"><span class="variable">$ </span>git branch hexo <span class="comment">#新建一个hexo分支</span></span><br><span class="line"><span class="variable">$ </span>git checkout hexo <span class="comment">#切换到hexo分支</span></span><br><span class="line"><span class="variable">$ </span>git remote add origin git<span class="variable">@github</span>.com：yourname/yourname.github.io.git <span class="comment">#本地与github项目对接</span></span><br><span class="line"><span class="variable">$ </span>git push origin hexo       /<span class="regexp">/将新的分支发布到GitHub上</span></span><br></pre></td></tr></table></figure><p>这样GitHub项目的库里会多出一个hexo分支，是用于多终端同步的关键部分。</p><p>出现以下错误：<code>error：failed to push some refs to</code></p><p>解决方法：<code>git pull --rebase origin master</code>。把远程库中的更新合并到本地库中。 </p><p>在另一个终端中更新博客，只需要将GitHub上source分支clone下来，进行初次相关配置。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将Github中hexo分支clone到本地</span></span><br><span class="line"><span class="variable">$ </span>git clone -b hexo git<span class="variable">@github</span>.<span class="symbol">com:</span>yourname/yourname.github.io.git</span><br><span class="line"></span><br><span class="line">/jiangxjun.github.io  <span class="variable">$ </span>git checkout -b hexo     <span class="comment">#cheackout 远程代码到本地hexo分支</span></span><br><span class="line"><span class="comment"># 注意，这里一定要切换到刚刚clone的文件夹内执行</span></span><br><span class="line"><span class="variable">$ </span>git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个.md文件，并编辑完成自己的博客内容</span></span><br><span class="line"><span class="variable">$ </span>hexo new post <span class="string">"new blog name"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客</span></span><br><span class="line">/jiangxjun.github.io/hexo  <span class="variable">$ </span>git add source</span><br><span class="line"><span class="variable">$ </span>touch README</span><br><span class="line"><span class="variable">$ </span>git add README</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"update blog"</span></span><br><span class="line"><span class="variable">$ </span>git remote add origin git<span class="variable">@github</span>.com：yourname/yourname.github.io.git</span><br><span class="line"><span class="comment"># 更新分支</span></span><br><span class="line"><span class="variable">$ </span>git push -u origin +hexo<span class="comment"># push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#出现更新被拒绝，当前分支的最新提交落后于其对应的远程分支</span></span><br><span class="line"><span class="variable">$ </span>git fetch origin <span class="comment">#获取远程更新</span></span><br><span class="line"><span class="variable">$ </span>git merge origin/master <span class="comment"># 把更新内容合并到本地分支</span></span><br><span class="line"><span class="variable">$ </span>git push -u origin +hexo</span><br></pre></td></tr></table></figure><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>在github上下载源代码时候，遇到<code>git clone</code>命令出现错误：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Permissiondenied (publickey).</span><br><span class="line"></span><br><span class="line">fatal:Could <span class="keyword">not</span> <span class="built_in">read</span> <span class="built_in">from</span> remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have <span class="keyword">the</span> correct access rights</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">the</span> repository exists.</span><br></pre></td></tr></table></figure><p>原因是：本地（或服务器上）没有生成<code>ssh key</code>。解决办法如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">(base)</span> jiang@jiang-X299:~$ <span class="keyword">cd</span> ~<span class="string">/.ssh</span> <span class="keyword">ls</span></span><br><span class="line"><span class="keyword">ls</span> <span class="comment">#查看是否有文件id_rsa以及文件id_rsa.pub</span></span><br></pre></td></tr></table></figure><p>没有，则终端命令如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span>   <span class="comment">#修改为自己的邮箱，途中需要输入密码，不管，一路回车即可，即生成你的ssh key</span></span><br><span class="line"> ssh -v git@github.com  <span class="comment">#最后会出现No more authentication methods to try. </span></span><br><span class="line">                          Permission denied (publickey)</span><br><span class="line"> </span><br><span class="line">ssh-agent -<span class="keyword">s</span>      <span class="comment">#输入该命令，会出现SSH_AUTH_SOCK=/tmp/ssh-a94vS6DUEnSA/agent.14751; </span></span><br><span class="line">               export SSH_AUTH_SOCK;</span><br><span class="line">               SSH_AGENT_PID=<span class="number">14752</span>; export SSH_AGENT_PID;</span><br><span class="line">               echo Agent pid <span class="number">14752</span>;</span><br><span class="line"></span><br><span class="line">ssh-add ~<span class="regexp">/.ssh/id</span>_rsa    <span class="comment">#输入该命令，会出现identity added:(一些ssh key文件路径的信息)</span></span><br><span class="line">                      （注意）如果出现错误提示：Could <span class="keyword">not</span> <span class="keyword">open</span> a connection to your authentication agent.请执行命令：<span class="keyword">eval</span> <span class="string">`ssh-agent -s`</span>后继续执行命令 ssh-add ~<span class="regexp">/.ssh/id</span>_rsa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后打开你刚刚生成的id_rsa.pub，将里面的内容复制，进入你的github账号，在settings下，SSH <span class="keyword">and</span> GPG <span class="keyword">keys</span>下new SSH key，title随便取一个名字，然后将id_rsa.pub里的内容复制到Key中，完成后Add SSH Key。</span><br><span class="line"></span><br><span class="line">最后一步，验证Key</span><br><span class="line"></span><br><span class="line">　　在ternimal下输入命令：</span><br><span class="line"></span><br><span class="line">　　ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">　　提示：Hi xxx! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell  access.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      解决github+hexo的博客多终端同步问题
    
    </summary>
    
      <category term="教程" scheme="https://jiangxj.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="https://jiangxj.top/blog/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu使用教程</title>
    <link href="https://jiangxj.top/blog/2020/05/18/ubuntu%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://jiangxj.top/blog/2020/05/18/ubuntu使用教程/</id>
    <published>2020-05-18T06:06:10.000Z</published>
    <updated>2021-01-13T10:21:36.409Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Ubuntu磁盘操作"><a href="#Ubuntu磁盘操作" class="headerlink" title="Ubuntu磁盘操作"></a>Ubuntu磁盘操作</h2><p>需要root权限</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">su</span></span><br><span class="line"><span class="keyword">su</span> ***</span><br></pre></td></tr></table></figure><p>用命令<code>fdisk -l</code>查看系统识别磁盘情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Device     Boot     <span class="keyword">Start</span>       <span class="keyword">End</span>   Sectors   <span class="keyword">Size</span> <span class="keyword">Id</span> <span class="keyword">Type</span></span><br><span class="line">/dev/sda1  *         <span class="number">2048</span> <span class="number">960335871</span> <span class="number">960333824</span> <span class="number">457.9</span>G <span class="number">83</span> Linux</span><br><span class="line">/dev/sda2       <span class="number">960337918</span> <span class="number">976771071</span>  <span class="number">16433154</span>   <span class="number">7.9</span>G  <span class="number">5</span> <span class="keyword">Extended</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: <span class="number">2.7</span> TiB, <span class="number">3000592982016</span> <span class="keyword">bytes</span>, <span class="number">5860533168</span> sectors</span><br><span class="line">Units: sectors <span class="keyword">of</span> <span class="number">1</span> * <span class="number">512</span> = <span class="number">512</span> <span class="keyword">bytes</span></span><br><span class="line">Sector <span class="keyword">size</span> (<span class="keyword">logical</span>/<span class="keyword">physical</span>): <span class="number">512</span> <span class="keyword">bytes</span> / <span class="number">4096</span> <span class="keyword">bytes</span></span><br><span class="line">I/O <span class="keyword">size</span> (<span class="keyword">minimum</span>/<span class="keyword">optimal</span>): <span class="number">4096</span> <span class="keyword">bytes</span> / <span class="number">4096</span> <span class="keyword">bytes</span></span><br><span class="line">Disklabel <span class="keyword">type</span>: gpt</span><br><span class="line">Disk identifier: <span class="number">1</span>AB82561-C5FD<span class="number">-47</span>A9<span class="number">-9</span>A29<span class="number">-31835617</span>EBD3</span><br><span class="line"></span><br><span class="line">Device     <span class="keyword">Start</span>        <span class="keyword">End</span>    Sectors  <span class="keyword">Size</span> <span class="keyword">Type</span></span><br><span class="line">/dev/sdb1   <span class="number">2048</span> <span class="number">5860532223</span> <span class="number">5860530176</span>  <span class="number">2.7</span>T Microsoft basic <span class="keyword">data</span></span><br></pre></td></tr></table></figure><p>可以看到磁盘的挂载点，然后<code>cd</code>切换到对应的磁盘，访问。</p><p>跟磁盘相关的几个常用命令：</p><p><code>df -h</code>：查看磁盘占用情况</p><p><code>df -T</code>：查看磁盘的文件系统类型(type)</p><p><code>fdisk -l</code>：查看所有被系统识别的磁盘</p><h2 id="ubuntu-hexo-github搭建博客"><a href="#ubuntu-hexo-github搭建博客" class="headerlink" title="ubuntu +hexo +github搭建博客"></a>ubuntu +hexo +github搭建博客</h2><p><strong>1、安装git</strong></p><p><strong>2、安装node.js</strong></p><p>为了避免安装的 Node.js 版本过旧导致后续的 Hexo 安装过程出错，应该使用 NVM（Node Version Manager）安装 Node.js。官方给出了两个安装脚本，直接复制到命令行即可：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/creationix/</span>nvm<span class="regexp">/v0.33.2/i</span>nstall.sh | bash</span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/creationix/</span>nvm<span class="regexp">/v0.33.2/i</span>nstall.sh | bash</span><br></pre></td></tr></table></figure><p>安装完成后，<strong>重启终端</strong>使用。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nvm <span class="keyword">install</span> stable <span class="comment">#安装 nvm</span></span><br><span class="line">完成安装。安装完成后可使用</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>环境配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># 在底部添加 PATH 变量</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:/usr/local/node/bin</span><br><span class="line"><span class="comment"># 保存生效</span></span><br><span class="line">source etc/profile</span><br></pre></td></tr></table></figure><p>具体教程参考<a href="https://www.fengkx.top/post/building-a-blog-based-on-hexo-and-github-in-ubuntu/index.html" target="_blank" rel="noopener">此文</a>。</p><p>注意node版本和hexo版本匹配问题，如果node版本过高，执行<code>hexo g -d</code>部署会出现问题。</p><p><strong>3、安装多版本node/npm</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nvm</span> <span class="selector-tag">install</span> 10<span class="selector-class">.15</span><span class="selector-class">.3</span>  #安装10<span class="selector-class">.15</span><span class="selector-class">.3</span>版本</span><br></pre></td></tr></table></figure><p>具体参考<a href="https://www.runoob.com/w3cnote/nvm-manager-node-versions.html" target="_blank" rel="noopener">此文</a></p><p><strong>4、修改hexo版本</strong></p><p>update hexo in <code>package.json</code></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line"><span class="string">"dependencies"</span>:&#123;</span><br><span class="line">    <span class="string">"hexo"</span>: <span class="string">"^4.2.0"</span>  <span class="meta">#删除原版本</span></span><br><span class="line">    <span class="string">"hexo"</span>: <span class="string">"^4.2.1"</span>  <span class="meta">#输入新版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> update</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Ubuntu的基本使用教程
    
    </summary>
    
      <category term="教程" scheme="https://jiangxj.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ubuntu" scheme="https://jiangxj.top/blog/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>迁移学习和深度迁移学习原理</title>
    <link href="https://jiangxj.top/blog/2020/05/18/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jiangxj.top/blog/2020/05/18/迁移学习/</id>
    <published>2020-05-17T16:00:00.000Z</published>
    <updated>2020-06-18T02:39:58.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h1><blockquote><p>S. J. Pan and Q. Yang, “<strong>A Survey on Transfer Learning</strong>“ in <em>IEEE Transactions on Knowledge and Data Engineering</em>, vol. 22, no. 10, pp. 1345-1359</p></blockquote><h2 id="迁移学习概念"><a href="#迁移学习概念" class="headerlink" title="迁移学习概念"></a>迁移学习概念</h2><p>传统机器学习的领域假设训练数据和测试数据属于相同的特征空间并在同一分布，然而现实中这种假设往往得不到满足。例如，我们对目标领域的分类问题，却只有源领域的训练数据，但源领域数据与目标领域数据要么不在同一个特征空间，要么不满足相同的数据分布，例如需要进行的文本分类语言是西班牙语。但只提供了了葡萄牙语的文本。</p><p>在某些情况下成功地进行知识迁移能够很大程度上提高学习的性能，但也同时降低了标记目标领域数据带来的大量时间和人力成本。</p><p>近年来，迁移学习已经成为一种解决<strong>知识迁移问题</strong>的新型学习框架，<a href="https://ieeexplore.ieee.org/document/5288526" target="_blank" rel="noopener">这篇论文【S. J. Pan and Q. Yang, “A Survey on Transfer Learning,” in <em>IEEE Transactions on Knowledge and Data Engineering</em>, vol. 22, no. 10, pp. 1345-1359】</a>讨论了使用迁移学习进行分类、回归和聚类的一般过程，也讨论了迁移学习和其他相关的机器学习技术之间的关系，如领域适应性、多任务学习、样本选择和变量变换。</p><p>传统的机器学习/数据挖掘只有在训练集和测试集数据都来自同一个feature space和the same distribution的时候才有较好的表现，也就意味着如果每一次更换了数据集重新训练模型，会变得很麻烦。比如：</p><p>（1）从数据类型/内容上看，获取新的数据集很贵很麻烦</p><p>（2）从时间维度上看，有些数据很容易过期，不同时期的数据分布会不同。对于每个时间段都要进行一次训练很麻烦（如进行室内wifi定位）</p><p>2005年DARPA的信息处理办公室(IPTO)给迁移学习有了一个新的定义：一个系统具有把从先前的任务学习到的识别和应用知识的能力运用到新的任务上的能力。</p><p>区别于多任务学习(multi-task learning)中将source和target tasks同等对待，迁移学习更多的关注target tasks，在迁移学习中，两者不再对等。</p><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><p>几个关键词：<strong>domain（域）</strong>和<strong>task（任务）</strong>，<strong>source（源）</strong>和<strong>target（目标）</strong></p><p>domain包括两部分：feature space和probability（概率）。domain不同可能分为两种情况，特征空间不同或者概率不同。</p><p>task包括两部分：label space和objective predictive function（目标预测函数）。同样如上所述。</p><p>source：用于训练模型的域/任务。</p><p>target：使用基于source训练出来的模型对自己的数据进行预测/分类/聚类等机器学习任务的域/任务。</p><p>领域（domain）$\mathcal{D}$包括特征空间$\mathcal{X}$和边缘分布（marginal probability distribution）$P(X)$，$X = \{x_1,x_2,\dots,x_n\} \in \mathcal{X}$。即：$\mathcal{D}= \{\mathcal{X},P(X)\}$</p><p>任务（task）$\mathcal{T}$包括标签空间$\mathcal{Y}$和目标预测函数$f(·)$，也就是条件概率分布，记作$P(y|x)$。即：$\mathcal{T} = \{\mathcal{Y},f(·)\}$</p><p><strong>迁移学习定义</strong>：给出一个源领域$\mathcal{T}_S$和学习任务$\mathcal{T}_S$，一个目标领域$\mathcal{D}_T$和学习任务$\mathcal{T}_T$，迁移学习指的是通过从$\mathcal{D}_S$和$\mathcal{T}_S$学到的知识了来帮助在$\mathcal{D}_T$中目标函数$f_T(·)$的学习。$\mathcal{D}_T \neq \mathcal{D}_S$或者$\mathcal{T}_T \neq \mathcal{T}_S$</p><p>源领域和目标领域不同指的是$\mathcal{X}_S \neq \mathcal{X}_T$【即特征空间不同】或者$P_S(X) \neq P_T(X)$【即源和目标任务的边缘分布不同】</p><p>源任务和目标任务不同指的是$\mathcal{Y}_S \neq \mathcal{Y}_T $【即任务标签集不同】或者$P(Y_S |X_S) \neq P(Y_T | X_T)$【即源和目标任务的条件概率不同】</p><h2 id="迁移学习的划分"><a href="#迁移学习的划分" class="headerlink" title="迁移学习的划分"></a>迁移学习的划分</h2><p><strong>①从问题角度来看</strong><br>（1）迁移什么？</p><p>哪一部分知识可以被迁移？</p><p>（2）怎么迁移？</p><p>那当然就是训练出适合的模型啦。</p><p>（3）什么时候需要用到迁移学习？</p><p>当source domain和target domain没什么关系或者太不相同的时候，迁移效果可能就不那么好了，甚至可能会比不迁移的时候表现要更差，这个就叫做<strong>negative transfer</strong>了。</p><p>可以看到，迁移学习的能力也是有限的，所以我们需要关注迁移学习的边界在哪里，比如用conditional Kolmogorov complexity去衡量tasks之间的相关性。</p><p>作者指出，现在很多工作都关注前两个问题，但实际上第三个问题是很重要的，因为你在那捣腾半天最后发现其实迁移了还不如不迁移，那不是白费心思嘛。所以作者认为这个问题应当被重视，比如说可以在迁移之前先看看source和domain之间的transferability（可迁移性）。</p><p> <strong>②从迁移场景来看</strong><br>（1）Homogeneous TL（同构学习）：source domain和target domain的feature space相同。</p><p>（2）Heterogeneous TL（异构学习）：source domain和target domain的feature space不同。</p><p><strong>③从迁移算法来看</strong><br>（1）Inductive TL（归纳式迁移学习）</p><p>source和target的domain可能一样或不一样，task不一样；target domain的labeled数据可得，source domain不一定可得。</p><p>所以呢，根据source domain的labeled数据可以再细分为两类：</p><p>multi_task learning（多任务学习）：source domain的labeled数据可得。<br>self-taught learning（自学习）：source domain的labeled数据不可得。</p><img src="/blog/2020/05/18/迁移学习/20170308151057479.png" title="归纳式迁移学习"><blockquote><p>代表性论文引用：Dai W, Yang Q,Xue G R, et al. Boosting for transfer learning[C]//Machine Learning, Proceedings of the Twenty-Fourth International   Conference. DBLP, 2007:193-200.</p></blockquote><p>（2）Transductive TL（直推式迁移学习）</p><p>source和target的task一样，domain不一样；source domain的labeled数据可得，target domain的不可得。注意我们提过，domain不一样意味着两种可能：feature space不一样，或者feature space一样而probability不一样。而后一种情况和domain adaptation（域适配）息息相关。这里也可以根据domain和task的个数分为两个情况：</p><p>Domain Adaptation（域适配）：不同的domains+single task<br>Sample Selection Bias（样本选择偏差）/Covariance Shift（协方差转变）：single domain+single task</p><img src="/blog/2020/05/18/迁移学习/20170308151131042.png" title="直推式迁移学习"><blockquote><p>代表性论文引用：Arnold A, Nallapati R, Cohen W W. A comparativestudy of methods for transductive transfer    learning[C]//Data Mining Workshops,2007. ICDM Workshops 2007. Seventh IEEE International Conference on. IEEE,2007: 77-82.</p></blockquote><p>（3）Unsupervised TL（无监督迁移学习）</p><p>source和target的domain和task都不一样；source domain和target domain的labeled数据都不可得。</p><img src="/blog/2020/05/18/迁移学习/20170308151150215.png" title="无监督迁移学习"><blockquote><p>代表性论文引用：Dai W, Yang Q, Xue G R, et al. Self-taughtclustering[C]//Proceedings of the 25th international conference on Machinelearning. ACM, 2008: 200-207.</p></blockquote><p>将迁移学习根据领域和任务的不同进行了划分：</p><img src="/blog/2020/05/18/迁移学习/分类.png" title="迁移学习根据领域和任务不同分类"><p>综上，这几个方法差别主要是：<strong>（1）source和domain之间，domain是否相同，task是否相同；（2）source domain和target domain的labeled数据是否可以得到。</strong></p><img src="/blog/2020/05/18/迁移学习/tabel1.png" title="Relation Between Traditional ML & Various Transfer Learning Setting"><img src="/blog/2020/05/18/迁移学习/table2.png" title="Different Settings of Transfer Learning"><p><strong>④从“迁移什么”来看</strong></p><p>（1）Instance-based TL（样本迁移）</p><p>尽管source domain数据不可以整个直接被用到target domain里，但是在source domain中还是找到一些可以重新被用到target domain中的数据。对它们调整权重，使它能与target domain中的数据匹配之后可以进行迁移。盗一张图，比如在这个例子中就是找到例子3，然后加重它的权值，这样在预测的时候它所占权重较大，预测也可以更准确。</p><p>instance reweighting（样本重新调整权重）和importance sampling（重要性采样）是instance-based TL里主要用到的两项技术。</p><img src="/blog/2020/05/18/迁移学习/2018041120463545.png" title="样本迁移"><p>（2）Feature-representation-transfer（特征迁移）</p><p>找到一些好的有代表性的特征，通过特征变换把source domain和target domain的特征变换到同样的空间，使得这个空间中source domain和target domain的数据具有相同的分布，然后进行传统的机器学习就可以了。</p><p>特征变换这一块可以举个栗子，比如评论男生的时候，你会说”好帅！好有男人味！好有担当！“；评论女生的时候，你会说”好漂亮！好有女人味！好温柔！“可以看出共同的特征就是“好看”。把“好帅”映射到“好看”，把“好漂亮”映射到“好看”，“好看”便是它们的共同特征。</p><p>（3）Parameter-transfer（参数/模型迁移）</p><p>假设source tasks和target tasks之间共享一些参数，或者共享模型hyperparameters（超参数）的先验分布。这样把原来的模型迁移到新的domain时，也可以达到不错的精度。</p><p>下面这个项目感觉用到就是这个parameter-transfer：<a href="https://cosx.org/2017/10/transfer-learning/" target="_blank" rel="noopener">基于深度学习和迁移学习的识花实践</a>。</p><p>（4）Relational-knowledge-transfer（关系迁移）</p><p>把相似的关系进行迁移，比如生物病毒传播到计算机病毒传播的迁移，比如师生关系到上司下属关系的迁移。</p><img src="/blog/2020/05/18/迁移学习/table3.png" title="Different Approaches Used in Different Settings"><h2 id="具体方法概述"><a href="#具体方法概述" class="headerlink" title="具体方法概述"></a>具体方法概述</h2><p>即上表的扩展分析：</p><p><strong>①Inductive TL</strong></p><p>（1）Instances TL</p><p>主要方法：TrAdaBoost（AdaBoost的拓展）</p><p>假设：source domain和target domain数据的feature和labels是一样的，但是分布不一样；部分source domain的数据会对target domain的学习有帮助，但有部分可能会不利于target domain的学习。</p><p>过程：大致就是不断地给好的source data赋予更高的权重，给不好的赋予更多的权重。</p><p>（2）Features TL</p><p>需要根据source domain的labeled data是否可得分为两类（回顾：Inductive TL是target domain的labeled data可得，但是source domain的未必可得）：</p><p>Supervised Feature Construction（监督的特征构建）</p><p>Unsupervised Feature Construction（非监督的特征构建）</p><p>大致过程：通过减少model error，找出低维的有代表性的特征</p><p>（3）Parameters TL</p><p>主要方法：MT-IVM（基于Gaussian Processes）</p><p>大致过程（注意这里讲述的不是上面提到的那个主要方法的过程，而是另一个方法的过程）：假设source和target的参数都可以分为两部分，一部分是source/target特有的参数，一部分是它们共同有的参数。把这两个参数丢到改进了的SVM问题中，把参数训练出来就好了。</p><p>（4）Relational TL</p><p>注意和上面三种方法不同的是，这个方法是在relational domains里进行的，这个domain里的数据不是iid（独立同分布）的，所以它不需要假设每个domain里的数据都必须iid。</p><p>主要方法：statistical relational learning（SRL，统计关系学习）</p><p><strong>②Transductive TL</strong></p><p>Transductive TL是source domain的label可得，target domain的label不可得。但是要注意！为了得到target data的边际分布，在training的时候是需要一些unlabeled的target data的。</p><p>（1）Instances TL</p><p>主要方法：Importance sampling。</p><p>大致过程：我们的目标是最小化target domain里的expected risk（期望风险），但是target domain里没有labeled数据可用，所以我们必须替换成source domain里的数据，通过一些方法可以把它替换成source domain里的数据再乘以一个权重，只要把这个权重算出来就好。</p><p>（2）Feature Representations TL</p><p>主要方法：Structural Correspondence Learning（SCL）</p><p>大致过程：定义一些pivot features（就是共同特征），然后把每一个pivot feature都当成是一个新的label vector，通过公式把权重学习出来，然后对权重进行SVD分解，最后在argumented feature vector上使用传统的判别式算法即可。这里argumented feature vector包括这些新的features和所有原来的feature。（我还没有详细看这一块儿，所以先直译了）</p><p>难点：如何寻找好的pivot feature、domain之间的依赖性。</p><p><strong>③ Unsupervised TL</strong></p><p>（1）Feature Representations TL</p><p>主要方法：涉及两个</p><p>Self-taught clustering（STC），主要用于transfer clustering（迁移聚类）。目标就是希望通过source domain里大量的unlabeled data对少量的target domain里的unlabeled data进行聚类。<br>TDA方法，这个主要用于解决transfer dimensionality reduction（迁移降维）问题</p><h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2><p>（1）negative transfer的问题，比如怎么定义transferability，怎么衡量domain之间或task之间的相关性。</p><p>（2）目前的TL算法主要都是想要提高feature space相同probability不同时的表现的，domain不同或者task不同都有两种情况，一种是space不同，一种是space相同probability不同 ，但是这里说的就是<strong>目前TL算法主要致力于提高的都是概率不同的</strong>。但是很多时候我们其实也想要对feature space不同的domain和task进行迁移。即提到的heterogeneous TL（异构学习）问题。</p><p>（3）现在的TL主要都是应用到小且波动不大的数据集中（例如传感器数据、文本分类、图片分类等），以后要考虑如何用到更广泛的数据场景中。</p><h2 id="迁移学习的基本过程"><a href="#迁移学习的基本过程" class="headerlink" title="迁移学习的基本过程"></a>迁移学习的基本过程</h2><p>当可用的数据集特别少时，从头开始训练一个神经网络往往不能得到很好的结果，于是就从一个预训练模型开始训练，让网络本身已经具备一定的训练基础，然后用小数据集进行微调，便可以得到一个不错的结果。</p><p>通常加载预训练后，冻结模型的部分参数，一般只训练模型的最后几层，这样可以保留整个模型前面对物体特征提取的能力。预训练模型一定要与新的数据集有共同点，这样才能有效地预训练模型里的特征提取能力迁移到新的模型上。</p><p>一般过程：</p><p>1、加载预训练模型</p><p>2、冻结模型前面部分的参数</p><p>3、添加可训练的自定义的分类层，或使用原模型的分类层（如果可重用的话）</p><p>4、在新数据集上训练</p><h2 id="准备数据集"><a href="#准备数据集" class="headerlink" title="准备数据集"></a>准备数据集</h2><p>按照50%，25%，25%的比例划分training，valid，和testing。</p><p>目录整理如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/datadir</span><br><span class="line">     /train</span><br><span class="line">         /class1</span><br><span class="line">         /class2</span><br><span class="line">     </span><br><span class="line">    /valid    验证集</span><br><span class="line">         /class1</span><br><span class="line">         /class2</span><br><span class="line">    /test</span><br><span class="line">         /class1</span><br><span class="line">         /class2</span><br></pre></td></tr></table></figure><p>预训练模型是基于ImageNet的，训练图像大小224×224，需要对数据集的图像进行大小缩放。</p><h2 id="图像增广-data-augmentation"><a href="#图像增广-data-augmentation" class="headerlink" title="图像增广(data augmentation)"></a>图像增广(data augmentation)</h2><p>图像增广一般用来人工产生不同的图像，比如对图像进行旋转、翻转、随机裁剪、缩放等等。选择训练阶段对输入进行增广。</p><h2 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h2><p>定义training和validation的预处理方式。</p><p>定义dataset和dataloader。用datasets.imagesfolder来定义dataset时，pytorch可以自动将图片与对应的文件夹分类对应起来，应用上面定义好的transformers，然后dataset传入到dataloader里，dataloader在每一个循环会自动生成batchsize大小的图像和label。</p><h2 id="ImageNet的预训练模型"><a href="#ImageNet的预训练模型" class="headerlink" title="ImageNet的预训练模型"></a>ImageNet的预训练模型</h2><p>PyTorch自带了很多ImageNet上的预训练模型</p><p><a href="https://www.pytorchtutorial.com/pytorch-transfer-learning/" target="_blank" rel="noopener">PyTorch迁移学习实现图像分类</a></p><p><a href="https://www.pytorchtutorial.com/" target="_blank" rel="noopener">PyTorch 中文网</a></p><h1 id="深度迁移学习"><a href="#深度迁移学习" class="headerlink" title="深度迁移学习"></a>深度迁移学习</h1><blockquote><p>论文：A Survey on Deep Transfer Learning</p><p>清华大学智能技术与系统国家重点实验室近期发表的深度迁移学习综述，首次定义了深度迁移学习的四个分类，包括基于实例、映射、网络和对抗的迁移学习方法，并在每个方向上都给出了丰富的参考文献。</p><p><a href="https://zhuanlan.zhihu.com/p/44654536" target="_blank" rel="noopener">参考</a></p></blockquote><img src="/blog/2020/05/18/迁移学习/深度迁移学习论文.png" title="深度迁移学习综述论文"><h2 id="回顾迁移学习"><a href="#回顾迁移学习" class="headerlink" title="回顾迁移学习"></a>回顾迁移学习</h2><p><strong>迁移学习</strong>：解决训练数据不足这一基本问题，试图放松训练数据和测试数据必须是独立同分布(i.i.d)的假设，将知识从源域迁移到目标域。</p><img src="/blog/2020/05/18/迁移学习/迁移学习形式化定义.PNG" title="迁移学习形式化定义"><p>给出一个源领域$\mathcal{T}_S$和学习任务$\mathcal{T}_S$，一个目标领域$\mathcal{D}_T$和学习任务$\mathcal{T}_T$，迁移学习指的是通过从$\mathcal{D}_S$和$\mathcal{T}_S$学到的知识了来帮助在$\mathcal{D}_T$中目标函数$f_T(·)$的学习。$\mathcal{D}_T \neq \mathcal{D}_S$或者$\mathcal{T}_T \neq \mathcal{T}_S$</p><h2 id="深度迁移学习-1"><a href="#深度迁移学习-1" class="headerlink" title="深度迁移学习"></a>深度迁移学习</h2><p>如何利用深度神经网络进行有效的知识传递很重要，即深度迁移学习。定义如下：</p><p><strong>深度迁移学习定义</strong>：给定一个迁移学习任务，定义为$\left(\mathcal{D}_S,\mathcal{T}_S,\mathcal{D}_T,\mathcal{T}_T,f_{\mathcal{T}}(·)\right)$。其中$f_{\mathcal{T}}(·)$是一个反映深度神经网络的非线性函数。</p><p><strong>深度迁移学习分类</strong>：基于实例的深度迁移学习、基于映射的深度迁移学习、基于网络的深度迁移学习和基于对抗的深度迁移学习。</p><h3 id="基于实例的深度迁移学习"><a href="#基于实例的深度迁移学习" class="headerlink" title="基于实例的深度迁移学习"></a>基于实例的深度迁移学习</h3><p>使用特定的权重调整策略，从源域中选择部分实例作为目标域训练集的补充，并为这些选择的实例分配合适的权值。</p><p>是基于这样的假设：“虽然两个域之间存在差异，但是源域中的部分实例可以被具有适当权重的目标域使用”。</p><h3 id="基于映射的深度迁移学习"><a href="#基于映射的深度迁移学习" class="headerlink" title="基于映射的深度迁移学习"></a>基于映射的深度迁移学习</h3><p>将实例从源域和目标域映射到新的数据空间，在这个新的数据空间中，来自两个域的实例是相似的，适合于联合深度神经网络。</p><p>是基于这样的假设：“尽管两个源域之间存在差异，但它们在一个复杂的新数据空间中可能更加相似”。</p><h3 id="基于网络的深度迁移学习"><a href="#基于网络的深度迁移学习" class="headerlink" title="基于网络的深度迁移学习"></a>基于网络的深度迁移学习</h3><p>将源领域中预先训练好的部分网络，包括其网络结构和连接参数，重新利用，将其转化为用于目标领域的深度神经网络的一部分。</p><p>是基于这样的假设：“神经网络类似于人脑的处理机制，是一个迭代的、连续的抽象过程”。该网络的前端层可以看作是一个特征提取器，所提取的特征是通用的。</p><h3 id="基于对抗的深度迁移学习"><a href="#基于对抗的深度迁移学习" class="headerlink" title="基于对抗的深度迁移学习"></a>基于对抗的深度迁移学习</h3><p>在生成对抗网络(GAN)的启发下，引入对抗技术，寻找既适合于源域又适用于目标域的可迁移表达。</p><p>是基于这样的假设：“为了有效的迁移，良好的表征应该是对主要学习任务的区别性，以及对源域和目标域的不加区分”。</p><p><a href="https://zhuanlan.zhihu.com/p/89951541" target="_blank" rel="noopener">更详细的中文描述</a></p>]]></content>
    
    <summary type="html">
    
      主要分析迁移学习和深度迁移学习两篇综述文章
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="迁移学习" scheme="https://jiangxj.top/blog/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度迁移学习" scheme="https://jiangxj.top/blog/tags/%E6%B7%B1%E5%BA%A6%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>马尔科夫链-蒙特卡罗方法</title>
    <link href="https://jiangxj.top/blog/2020/05/16/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE-%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95/"/>
    <id>https://jiangxj.top/blog/2020/05/16/马尔科夫链-蒙特卡罗方法/</id>
    <published>2020-05-15T16:00:00.000Z</published>
    <updated>2020-06-18T01:17:12.457Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MCMC(markov chain monte carlo)马尔科夫链蒙特卡洛随机采样方法，是很多复杂算法求解的基础，用作一些复杂运算的近似求解。</p><h2 id="蒙特卡洛方法部分"><a href="#蒙特卡洛方法部分" class="headerlink" title="蒙特卡洛方法部分"></a>蒙特卡洛方法部分</h2><p><strong>概述</strong></p><p>通过大量的随机样本，去了解一个系统，进而得到所要计算的值。是以概率为基础的方法，与之对应的是确定性算法。</p><p><strong>基本思想</strong></p><p>​          所求解的问题是某随机事件A出现的概率（或者是某随机变量B的期望值）。通过某种“实验方法”，得出A事件出现的概率，以此估计出A事件出现的概率（或者得到随机变量B的某些数字特征，得出B的期望值）。</p><p><strong>工作过程</strong></p><p>​          Monte Carlo方法模拟某一个过程时，需要产生各种概率分布的随机变量，用统计方法把模拟的数字特征估计出来，从而得到实际问题的数值解。</p><p><strong>分类</strong></p><p>一类是所求解的问题具有内在的随机性，借助计算机的运算能力可以直接模拟这种随机过程。如分析中子在反应堆中的传输过程，依据其概率随机抽样得到裂变位置、速度和方向，模拟大量中子的行为后，经过统计得到中子传输的范围，作为堆设计的依据。</p><p>一类是所求解问题可以转化为某种随机分布的特征数，如随机事件发生的概率，或者随机变量的期望值，通过随机抽样，以随机事件出现的频率估计其概率，或者以抽样的数字特征估算随机变量的数字特征，作为问题的解。多用于求解复杂的多维积分问题。</p><p><strong>举例</strong></p><p>求解积分：$ \theta = \int_a^b f(x)dx $</p><p>一个简单近似求解方法是在$[a,b]$之间随机采样一个点，如$x_0$，然后用$f(x_0)$代表在这个区间上所有的$f(x)$的值，近似求解为：<br>$$<br>(b-a)f(x_0)<br>$$<br>在区间$[a,b]$上采样n个值：$x_0,x_1,\dots,x_{n-1}$，用其均值来代表区间上所有的$f(x)$的值，近似求解为：<br>$$<br>\frac{b-a}{n}\sum\limits_{i=0}^{n-1}f(x_i)<br>$$<br>上述是在假设$x$是在$[a,b]$上均匀分布的情况下，若不是均匀分布，则可以采用：如果得到$x$在$[a,b]$上的概率分布函数$p(x)$，有<br>$$<br>\theta = \int_{a}^b f(x)dx = \int_a^b \frac{f(x)}{p(x)} p(x)dx \approx \frac{1}{n}\sum\limits_{i=0}^{n-1}\frac{f(x_i)}{p(x_i)}<br>$$<br>上式最右边为蒙特卡洛方法的一般形式，此处是连续函数形式的。</p><p>可见，当假设$x$在区间内均匀分布时候，即：$p(x_i) = 1/(b-a)$，带入上式可以得到：<br>$$<br>\frac{1}{n}\sum\limits_{i=0}^{n-1}\frac{f(x_i)}{1/(b-a)} =\frac{b-a}{n}\sum\limits_{i=0}^{n-1}f(x_i)<br>$$<br><strong>概率分布采样</strong></p><p>如何基于概率分布去采样基于该概率分布的$n$个$x$样本集问题：</p><p>对于常见的均匀分布uniform（0，1）是非常容易采样的，一般是通过线性同余发生器可以生成(0,1)之间的伪随机数样本。</p><p>其他常见的概率分布，可以通过uniform(0,1)的样本转换得到，如二维的正太分布样本$(Z_1,Z_2)$可以通过独立采样得到uniform(0,1)样本对$(X_1,X_2)$。</p><p>其他的常见的连续分布，如$t$分布，$F$分布等，都可以通过类似得方式转换为uniform(0,1)得到的采样样本转化得到，在python中的numpy，scikit-learn等类库中，有生成这些常用分布样本的函数可以使用。</p><p><strong>接受-拒绝采样</strong></p><p>对于不常见的概率分布，一个可行的解决办法是：接受——拒绝采样。</p><p>设定一个程序可采样的分布$q(x)$，如高斯分布，然后按照一定的方法拒绝某些样本，以达到接近$p(x)$分布的目的，其中$q(x)$成为proposal distribution。</p><img src="/blog/2020/05/16/马尔科夫链-蒙特卡罗方法/1.png" title="高斯分布"><p>具体采用过程为：</p><p>设定一个方便采样的常用概率分布函数$q(x)$,以及一个常量$k$，使得$p(x)$总在$kq(x)$的下方。</p><p>采样得到的$q(x)$的一个样本$z_0$，然后，从均匀分布$(0,kq(z_0))$中采样得到一个值$u$，若$u$落在上图中的灰色区域，则拒绝抽样，否则接受这个样本$z_0$，重复以上过程得到$n$个接受的样本$z_0,z_1,\dots,z_{n-1}$，最后的蒙特卡罗方法求解结果为：<br>$$<br>\frac{1}{n}\sum\limits_{i=0}^{n-1}\frac{f(x_i)}{p(x_i)}<br>$$<br>通过一系列的接受拒绝决策来达到用$q(x)$模拟$p(x)$概率分布。</p><h2 id="马尔科夫链部分"><a href="#马尔科夫链部分" class="headerlink" title="马尔科夫链部分"></a>马尔科夫链部分</h2><p><strong>概述</strong></p><p>假设某一个时刻状态转移的概率只依赖于它的前一个状态，这样做可以大大简化模型的复杂度，因此马尔科夫链在很多时间序列模型中得到广泛的应用，如循环神经网络RNN，隐式马尔科夫链HMM等。</p><p>数学定义描述为：</p><p>假设序列状态是$\dots X_{t-2},    X_{t-1},X_{t},X_{t+1},\dots$，那么在时刻$X_{t+1}$的状态的条件概率仅仅依赖于时刻$X_t$，即：<br>$$<br>P(X_{t+1} | \dots X_{t-2},    X_{t-1},X_{t})= P(X_{t+1}|X_t)<br>$$<br>因为某一时刻状态转移的概率只依赖于它的前一个状态，因而只能求出系统中任意两个状态之间的转换概率。</p><p><strong>举例</strong></p><img src="/blog/2020/05/16/马尔科夫链-蒙特卡罗方法/2.png" title="股市模型"><p>表示股市模型，共三种状态：牛市、熊市和横盘(stagnant market)。每一个状态都以一定的概率转化到下一个状态。如，牛市以0.025概率转化为横盘的状态。</p><p>上图可以表示为矩阵的形式，如果定义矩阵$P$某一个位置$P(i,j)$的值为$P(j|i)$，即从状态$i$转化为状态$j$的概率，定义牛市状态为0，熊市状态为1，横盘为2，得到马尔科夫链模型的状态转移矩阵为：<br>$$<br>P = \pmatrix{0.9 &amp; 0.075&amp;0.025 \ 0.15 &amp; 0.8 &amp; 0.05 \ 0.25 &amp; 0.25 &amp; 0.5}<br>$$<br><strong>状态转移矩阵的性质</strong></p><p>马尔科夫链模型的状态转移矩阵收敛到稳定概率分布与初始状态概率分布无关，即</p><p>得到稳定分布对应的马尔科夫链模型的状态转移矩阵，可以用任意的概率分布样本开始，带入马尔科夫链模型的状态转移矩阵，经过一系列的转换，最终可以得到符合对应稳定概率分布的样本。</p><p>对于一个确定的状态转移矩阵$P$，$P^n$在$n$大于一定的值的时候也可以发现是确定的。</p><p>马尔科夫链性质数学描述：</p><p>如果一个非周期的马尔科夫链有状态转移矩阵$P$，并且它的任意两个状态是连通的，$\lim \limits_{n \rightarrow \infty} P_{ij}^n$与$i$无关，有：</p><ul><li>$\lim \limits_{n \rightarrow \infty} P_{ij}^n =\pi(j)$</li><li>$\lim\limits_{n \rightarrow \infty} P^n = \pmatrix{\pi(1) &amp; \pi(2) &amp; \dots &amp; \pi(j) &amp; \dots \ \pi(1) &amp; \pi(2) &amp; \dots &amp; \pi(j) &amp; \dots \ \dots \ \pi(1) &amp; \pi(2) &amp; \dots &amp; \pi(j) &amp; \dots \ \dots}$</li><li>$\pi(j) = \sum\limits_{i=0}^{\infty}\pi(i) P_{ij}$</li><li>$\pi$是方程$\pi P = \pi$的唯一非负解，其中：$\pi = [\pi(1),\pi(2),\dots,\pi(j), \dots]\sum\limits_{i=0}^{\infty}\pi(i) =1$</li></ul><p>（1）非周期性的马尔科夫链：这个主要是指马尔科夫链的状态转化不是循环的，如果是循环的则永远不会收敛。对于任意某一个状态$i,d$为集合$\{n|n \ge 1, P_{ii}^n &gt; 0\}$的最大公约数，如果$d=1$，则状态为非周期的。</p><p>（2）任何两个状态是连通的：从任意一个状态可以通过有限步到达其他的任意一个状态，不会出现条件概率一直为0导致不可达的情况。</p><p>（3）马尔科夫链的状态数是有限的，也可以是无限的，可以用于连续概率分布和离散概率分布</p><p>（4）$\pi$通常是马尔科夫链的平稳分布</p><p><strong>基于马尔科夫链采样</strong></p><p>得到了某个平稳分布所对应的马尔科夫链状态转移矩阵，很容易采样出这个平稳分布的样本集。</p><p>假设任意初始的概率分布为$\pi_0(x)$，经过第一轮马尔科夫链状态转移后的概率分布是$\pi_1(x)$，第$i$轮的概率分布是$\pi_i(x)$。经过$n$轮后的马尔科夫链收敛到平稳分布$\pi(x)$，即：<br>$$<br>\pi_n(x) = \pi_{n+1}(x)= \dots = \pi(x)<br>$$<br>对于每个分布$\pi_i(x)$，有：<br>$$<br>\pi_i(x) = \pi_{i-1}(x)P = \pi_{i-2}(x)P^2 = \pi_0(x)P^{i}<br>$$<br>采样过程：</p><p>首先，基于初始简单概率分布（如高斯分布）$\pi_0(x)$采样得到状态值$\pi_0$，基于条件概率分布$P(x|x_0)$采样状态值$x_1$，一直进行下去，当状态转移进行到一定的次数时，如$n$次，认为此时的样本集$(x_n,x_{n+1},x_{n+2},\dots)$即是符合平稳分布的对应的样本集，可以用来做蒙特卡洛模拟求和。</p><ol><li>输入马尔科夫链状态转移矩阵P，设定状态转移次数阈值$n_1$，需要样本个数$n_2$</li><li>从任意简答概率分布采样得到初始状态值$x_0$</li><li>for $t=0$ to $n_1+n_2 -1$：从条件概率分布$P(x|x_t)$中采样得到样本$x_{t+1}$样本集$(x_{n_1},x_{n_1+1},\dots,x_{n_1+n_2-1})$即为需要的平稳分布对应的样本集。</li></ol><p><strong>问题</strong>：随意给定一个平稳分布$\pi$，如何得到它所对应的马尔科夫链状态转移矩阵$P$。</p><p><strong>解决办法</strong>：MCMC采样和其易用版M-H采样。</p><h2 id="MCMC采样和M-H采样"><a href="#MCMC采样和M-H采样" class="headerlink" title="MCMC采样和M-H采样"></a>MCMC采样和M-H采样</h2><p><strong>马尔科夫链的细致平稳条件</strong></p><p>定义：</p><p>如果非周期的马尔科夫链的状态转移矩阵P和概率分布$\pi(x)$对于所有的$i,j$满足：<br>$$<br>\pi(i)P(i,j) = \pi(j)P(i,j)<br>$$<br>称概率分布$\pi(x)$是状态转移矩阵$P$的平稳分布。其中，$P(i,j)$表示从状态$i$到状态$j$的转化概率。</p><p>证明：<br>$$<br>\sum\limits_{i=1}^{\infty}\pi(i)P(i,j) = \sum\limits_{i=1}^{\infty}\pi(j)P(i,j) =\pi(j)\sum\limits_{i=1}^{\infty}P(j,i)=\pi(j)<br>$$<br>写成矩阵形式为：<br>$$<br>\pi P = \pi<br>$$<br>满足马尔科夫链的收敛性质，即只要找打可以使得概率分布$\pi(x)$满足细致平稳分布的矩阵P即可。</p><p><strong>MCMC采样</strong></p><p>一般情况下，目标平稳分布$\pi(x)$和某一个马尔科夫链状态转移矩阵Q不满足细致平稳条件，即：<br>$$<br>\pi(i)Q(i,j) \ne \pi(j)Q(j,i)<br>$$<br>引入$\alpha(i,j)$，使得上式成立，即：<br>$$<br>\pi(i)Q(i,j)\alpha(i,j) = \pi(j)Q(j,i)\alpha(j,i)<br>$$<br>其中：<br>$$<br>\alpha(i,j) = \pi(j)Q(j,i)<br>$$</p><p>$$<br>\alpha(j,i) = \pi(i)Q(i,j)<br>$$</p><p>得到分布$\pi(x)$对应的马尔科夫链状态转移矩阵P，满足：<br>$$<br>P(i,j) = Q(i,j)\alpha(i,j)<br>$$<br>即：目标矩阵P可以通过任意一个马尔科夫链状态转移矩阵Q乘以$\alpha(i,j)$得到，$\alpha(i,j)$称为<strong>接受率</strong>。取值$[0,1]$之间，相当于一个概率值。</p><p>MCMC采样过程：</p><ol><li><p>输入任意选定的马尔科夫链状态转移矩阵Q，平稳分布$\pi(x)$，设定状态转移次数阈值$n_1$，需要样本个数$n_2$</p></li><li><p>从任意简单概率分布采样得到初始状态值$x_0$</p></li><li><p>for $t=0$ to $n_1+n_2-1$:</p><p>(a)从条件概率分布$Q(x|x_t)$中采样得到样本$x_*$</p><p>(b)从均匀分布采样u~uniform[0,1]</p><p>(c)如果$u &lt; \alpha(x_t,x_<em>) = \pi(x_</em>)Q(x_<em>,x_t)$，则接受转移$x_t \rightarrow x_</em>$，即$x_{t+1} = x_*$</p><p>(d)否则不接受转移，即$x_{t+1} = x_t$</p></li></ol><p>样本集$(x_{n_1}，x_{n_1+1},\dots,x_{n_1+n_2-1})$即为所需要的平稳分布对应的样本集。</p><p><strong>问题</strong>：(c)步骤中，采样接受率$\alpha(x_t,x_*)$可能非常小，如0.1，导致大部分的采样值都被拒绝转移，采样效率很低，有可能采样百万次马尔科夫链还没有收敛，即$n_1$阈值次数需要设置的非常大。此时需要M-H采样。</p><p><strong>解决办法</strong>： M-H采样，解决MCMC采样接受率过低问题</p><p><strong>M-H采样</strong></p><p>Metropolis-Hastings采样的简称。</p><p>对接受率改造如下：<br>$$<br>\alpha(i,j) = \min \left\{ \frac{\pi(j)Q(j,i)}{\pi(i)Q(i,j)},1   \right\}<br>$$<br>M-H采样过程：</p><ol><li><p>输入任意选定的马尔科夫链状态转移矩阵Q，平稳分布$\pi(x)$，设定状态转移次数阈值$n_1$，需要样本个数$n_2$</p></li><li><p>从任意简单概率分布采样得到初始状态值$x_0$</p></li><li><p>for $t=0$ to $n_1+n_2-1$:</p><p>(a)从条件概率分布$Q(x|x_t)$中采样得到样本$x_*$</p><p>(b)从均匀分布采样u~uniform[0,1]</p><p>(c)如果$u &lt; \alpha(x_t,x_<em>) =\min \left\{ \frac{\pi(j)Q(j,i)}{\pi(i)Q(i,j)},1   \right\} $，则接受转移$x_t \rightarrow x_</em>$，即$x_{t+1} = x_*$</p><p>(d)否则不接受转移，即$x_{t+1} = x_t$</p></li></ol><p>样本集$(x_{n_1}，x_{n_1+1},\dots,x_{n_1+n_2-1})$即为所需要的平稳分布对应的样本集。</p><p>如果选择的马尔科夫链状态转移矩阵$Q$是对称的，即满足$Q(i,j) = Q(j,i)$，此时，接受率可以进一步简化为：<br>$$<br>\alpha(i,j) = \min \left\{ \frac{\pi(j)}{\pi(i)},1   \right\}<br>$$<br><strong>问题</strong>：</p><p>（1）大数据时代，数据特征非常多，M-H采样由于接受率计算式$\frac{\pi(j)Q(j,i)}{\pi(i)Q(i,j)}$的存在，在高维需要的计算时间非常可观，算法效率低，同时，由于接受率小于1，计算得到的结果会被拒绝。</p><p>（2）特征维度大，很多时候很难求出目标的各特征维度联合分布，但是可以方便的求出各个特征之间的条件概率分布，需要考虑的是  能否只有各维度之间条件概率分布的情况下方便的采样。</p><p><strong>解决办法</strong>： Gibbs采样。</p><h2 id="Gibbs采样"><a href="#Gibbs采样" class="headerlink" title="Gibbs采样"></a>Gibbs采样</h2><p><strong>重新寻找合适的细致平稳条件</strong></p><p>假设$\pi(x_1,x_2)$是一个二维联合分布，观察第一个特征维度相同的两个点$A(x_1^{(1)},x_2^{(2)}),B(x_1^{(1)},x_2^{(2)})$，有：<br>$$<br>\pi(x_1^{(1)},x_2^{(1)})\pi(x_2^{(2)}|x_1^{(1)}) = \pi(x_1^{(1)})\pi(x_2^{(1)}|x_1^{(1)})\pi(x_2^{(2)}|x_1^{(1)})<br>$$</p><p>$$<br>\pi(x_1^{(1)},x_2^{(2)})\pi(x_2^{(1)}|x_1^{(1)}) = \pi(x_1^{(1)})\pi(x_2^{(2)}|x_1^{(1)})\pi(x_2^{(1)}|x_1^{(1)})<br>$$</p><p>根据条件概率公式可得。</p><p>右侧相等，可得：<br>$$<br>\pi(x_1^{(1)},x_2^{(1)})\pi(x_2^{(2)}|x_1^{(1)}) =\pi(x_1^{(1)},x_2^{(2)})\pi(x_2^{(1)}|x_1^{(1)})<br>$$</p><p>$$<br>\pi(A)\pi(x_2^{(2)}|x_1^{(1)}) =\pi(B)\pi(x_2^{(1)}|x_1^{(1)})<br>$$</p><blockquote><p>如果非周期的马尔科夫链的状态转移矩阵P和概率分布$\pi(x)$对于所有的$i,j$满足：<br>$$<br>\pi(i)P(i,j) = \pi(j)P(i,j)<br>$$<br>称概率分布$\pi(x)$是状态转移矩阵$P$的平稳分布。其中，$P(i,j)$表示从状态$i$到状态$j$的转化概率。</p></blockquote><p>对比可见，在$x_1 = x_1^{(1)}$这条直线上，如果用条件概率分布$\pi(x_2|x_1^{(1)})$作为马尔科夫链的状态转移概率，则任意两点之间的转移满足细致平稳条件。同理，在直线$x_2 = x_2^{(1)}$上。</p><p>构造新的满足细致平稳条件：<br>$$<br>\pi(E)  P(E \rightarrow F) = \pi(F)  P(F \rightarrow E)<br>$$<br><strong>二维Gibbs采样</strong></p><p>需要两个维度之间的条件概率，具体过程如下：</p><p>(1)输入平稳分布$\pi(x_1,x_2)$，设定状态转移次数阈值$n_1$，需要样本个数$n_2$</p><p>(2)随机初始化初始状态值$x_1^{(0)},x_2^{(0)}$</p><p>(3)for $t=0$ to $n_1+n_2-1$：</p><p>​     (a)从条件概率分布$P(x_2|x_1^{(t)})$中采样得到样本$x_2^{t+1}$</p><p>​     (a)从条件概率分布$P(x_1|x_2^{(t+1)})$中采样得到样本$x_1^{t+1}$</p><p>样本集$\{(x_1^{(n_1)},x_2^{(n_1)}), (x_1^{(n_1+1)},x_2^{(n_1+1)}),\dots,(x_1^{(n_1+n_2-1)},x_2^{(n_1+n_2-1)})  \}$即为需要的平稳分布对应的样本集。</p><p>整个采样过程中，通过轮换坐标轴，采样的过程为：<br>$$<br>\left(x_1^{(1)},x_2^{(1)}\right) \rightarrow \left(x_1^{(1)},x_2^{(2)}\right) \rightarrow \left(x_1^{(2)},x_2^{(2)}\right) \rightarrow \dots \rightarrow \left(x_1^{(n_1+n_2-1)},x_2^{(n_1+n_2-1)}\right)<br>$$<br><img src="/blog/2020/05/16/马尔科夫链-蒙特卡罗方法/3.png" title="Gibbs采样"></p><p>采样是在两个坐标轴上不停的轮换，也可以每次随机选择一个坐标轴进行采样。常用的Gibbs采样实现都是基于坐标轴轮换的。</p><p><strong>多维Gibbs采样</strong></p><p>一个n维概率分布$\pi(x_1,x_2,\dots,x_n)$，可以通过在n个坐标轴上轮换采样，来得到新的样本，对于轮换到的任意一个坐标轴$x_i$上的转移，马尔科夫链的状态转移概率为$P(x_i | x_1,x_2,\dots,x_{i-1},x_{i+1},\dots,x_n)$，即固定$n-1$个坐标轴，在某一个坐标轴上移动。</p><p>整个采样过程和<strong>Lasso回归的坐标轴下降法算法</strong>  非常类似，只不过Lasso回归是固定n−1个特征，对某一个特征求极值。而Gibbs采样是固定n−1个特征在某一个特征采样。</p><p>Gibbs采样在高维特征的优势，采样要求数据至少两个维度，一维概率分布的采样无法用Gibbs采样的，此时M-H采样仍然成立。</p><p>Gibbs采样获取概率分布的样本集，蒙特卡罗方法用样本集模拟求和，奠定MCMC算法在大数据时代高维数据模拟求和时的作用。</p><p><a href="https://www.cnblogs.com/pinard/p/6625739.html" target="_blank" rel="noopener">MCMC方法参考资料</a></p><p><a href="https://blog.csdn.net/xiaozhu_1024/article/details/80585151" target="_blank" rel="noopener">Lasso回归</a></p>]]></content>
    
    <summary type="html">
    
      马尔科夫链-蒙特卡罗方法原理简介
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机控制系统</title>
    <link href="https://jiangxj.top/blog/2020/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://jiangxj.top/blog/2020/05/15/计算机控制系统/</id>
    <published>2020-05-14T16:00:00.000Z</published>
    <updated>2020-06-18T01:42:12.971Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考书籍 《计算机控制系统》刘建昌等著</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="一个典型的计算机控制系统的架构"><a href="#一个典型的计算机控制系统的架构" class="headerlink" title="一个典型的计算机控制系统的架构"></a>一个典型的计算机控制系统的架构</h2><img src="/blog/2020/05/15/计算机控制系统/1563412053509.png" title="典型的计算机控制系统架构"><p>数字信号：</p><p>$r(kT)$——给定输入，$y(kT)$——经A/D转换后的系统输出，$u(kT)$——由数字控制器计算的控制的控制信号，$e(kT)=r(kT)-y(kT)$——偏差信号。</p><p>离散模拟信号：</p><p>$y^*(t)$——经过采样开关的被控量信号【时间上离散，幅值上连续】</p><p>模拟信号：</p><p>$y(t)$——系统输出（被控量）</p><p>量化模拟信号：</p><p>$u^*(t)$——经D/A转换后的模拟控制信号【时间上连续，幅值上量化】</p><p>典型的计算机控制系统是：连续-离散混合系统。</p><p><strong>特点</strong>是：模拟、数字和离散模拟信号同在，输入输出均为模拟量的连续环节（被控对象、传感器）、输入和输出均为数字量环节（数字控制器、偏差计算）、输入输出为两类不同量的离散模拟环节（A/D，D/A）共存。</p><h2 id="计算机控制系统的应用要求"><a href="#计算机控制系统的应用要求" class="headerlink" title="计算机控制系统的应用要求"></a>计算机控制系统的应用要求</h2><ul><li>可靠性高</li><li>实时性好。对过程进行实时控制和监测</li><li>环境适应性强</li><li>过程输入和输出配套较好</li><li>系统扩展性好</li><li>系统开放性。在主系统接口、网络通信、软件兼容及升级等方面遵守开放性原则，便于系统扩展，异机种链接、软件的可移植和互换。</li><li>控制软件包功能强。具备丰富的控制算法，同时具备方便的人机交互，实时性好等性能</li></ul><h2 id="计算机控制系统的性能指标"><a href="#计算机控制系统的性能指标" class="headerlink" title="计算机控制系统的性能指标"></a>计算机控制系统的性能指标</h2><p>1、稳定性</p><p>2、稳态指标。</p><p>​       衡量控制系统精度的指标，用稳态误差来表征。稳态误差是输出量$y(t)$的稳态值$y(\infty)$与给定值$y_0$的差值，定义为：<br>$$<br>e(\infty) = y_0-y(\infty)<br>$$<br>其中$e(\infty)$表示控制精度，越小越好。稳态误差$e(\infty)$与控制系统本身的特性（如系统的开环传递函数）、系统的输入信号（如阶跃、速度或加速度输入信号）、反馈通道的干扰（测量干扰或监测回路的干扰）有关。</p><p>3、动态指标</p><p>​       能较为直观的反映控制系统的过渡过程特性。包括<strong>超调量$\sigma \%$、调节时间$t$、</strong>峰值时间$t_p$、<strong>衰减比</strong>$\eta$和振荡次数$N$。</p><p>4、综合指标</p><p>​      设计最优控制系统，常用的综合性能指标是<strong>积分型指标</strong>。如：<br>$$<br>J=\int_0^t e^2(t)dt<br>$$<br>这种“先误差平方后积分”形式的性能指标用于权衡系统总体误差的大小。数学上容易处理，可以得到解析解。</p><h2 id="一个计算机控制系统的典型硬件组成"><a href="#一个计算机控制系统的典型硬件组成" class="headerlink" title="一个计算机控制系统的典型硬件组成"></a>一个计算机控制系统的典型硬件组成</h2><img src="/blog/2020/05/15/计算机控制系统/1563413431889.png" title="计算机系统典型的硬件组成"><p>包括三部分：</p><ol><li>过程装置。包括被控对象、执行机构和测量变送装置</li><li>输入输出通道。包括过程通道和总线接口</li><li>计算机系统。计算机【计算机软件系统=系统软件+应用软件+数据库】和外部设备</li></ol><h3 id="模拟量输入通道"><a href="#模拟量输入通道" class="headerlink" title="模拟量输入通道"></a>模拟量输入通道</h3><p>通常由信号变换器、滤波器、多路模拟开关、前置放大器、采样保持器、A/D转换器、接口和控制电路等部分组成。</p><img src="/blog/2020/05/15/计算机控制系统/1563413702713.png" title="模拟量输入通道"><h3 id="模拟量输出通道"><a href="#模拟量输出通道" class="headerlink" title="模拟量输出通道"></a>模拟量输出通道</h3><p>通常由接口控制电路、D/A转换器（零阶保持期）、滤波器等部分组成。模拟量输出通道有两种结构形式：一是每个通道配置一个D/A转换器，二是通过多路模拟开关共用一个D/A转换器。</p><img src="/blog/2020/05/15/计算机控制系统/1563417797391.png" title="模拟量输出通道"><h3 id="数字量输入通道"><a href="#数字量输入通道" class="headerlink" title="数字量输入通道"></a>数字量输入通道</h3><p>基本功能就是把来自现场的数字信号或开关信号、脉冲信号，按照一定的时序要求送入数字控制器。</p><h3 id="数字量输出通道"><a href="#数字量输出通道" class="headerlink" title="数字量输出通道"></a>数字量输出通道</h3><p>基本功能是把控制器输出的数字控制信号，按照一定的时序要求，送入输出通道中部的<strong>数字执行机构</strong>，如继电器、可编程器件、步进电机等，通过数字执行机的动作实现被控对象的控制作用。</p><h3 id="总线接口"><a href="#总线接口" class="headerlink" title="总线接口"></a>总线接口</h3><h4 id="内部总线"><a href="#内部总线" class="headerlink" title="内部总线"></a>内部总线</h4><p>即计算机内部各外围芯片与处理器之间的总线，用于芯片一级的互连，是<strong>微处理器与外部硬件接口的通路</strong>。</p><p>内部并行总线包括：地址、数据和控制总线</p><img src="/blog/2020/05/15/计算机控制系统/1563418364558.png" title="内部并行总线"><p>内部串行总线SPI的典型结构图如下：</p><img src="/blog/2020/05/15/计算机控制系统/1563418454418.png" title="内部串行总线典型结构"><p>SPI系统使用4条线：串行时钟线（SCK）、主机输入/从机输出数据线MISO、主机输出、从机输入数据线MOSI和低电平有效的从机选择线SS。SCK、MOSI、MISO为共享数据线。</p><h4 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h4><p>计算机和各个插件板与系统板之间的总线（多总线multibus，STD bus，PC bus等）。</p><img src="/blog/2020/05/15/计算机控制系统/1563418835443.png" title="计算机各插件板与系统板之间总线"><p>CPU的总线驱动能力有限，大量的接口芯片不能直接挂在微处理器芯片上；存储器、I/O接口芯片太多，电路板安排不下，采用模块化设计会增加总线负载。此时需要在微处理器芯片和总线之间必须加上<strong>驱动器</strong>。</p><p>系统总线可分为5个主要类型：</p><ul><li>数据线。决定数据宽度</li><li>地址线。决定直接选址范围</li><li>控制线。具有控制、时序和中断功能，决定总线功能和适应性的好坏</li><li>电源线和地线</li><li>备用线</li></ul><h4 id="外部总线"><a href="#外部总线" class="headerlink" title="外部总线"></a>外部总线</h4><p>计算机和计算机之间、计算机和外部其它仪表或设备之间连接通信的总线。</p><h2 id="模数之间转换"><a href="#模数之间转换" class="headerlink" title="模数之间转换"></a>模数之间转换</h2><h3 id="D-A转换"><a href="#D-A转换" class="headerlink" title="D/A转换"></a>D/A转换</h3><p>按照规定的时间间隔T对控制器输出的数字量进行D/A转换。基本原则“按权展开求和”，对数字量中的每一位，按权值分别转换为模拟量，然后通过运放求和，得到相应的模拟量的输出。</p><p>$n$位D/A转换器件（DAC）的输出电压$V_{out}$为：<br>$$<br>V_{out} = V_{FSR}\left(\frac{B_1}{2}+\dots+\frac{B_n}{2^n}\right)<br>$$<br>其中，$V_{FSR}$为输出的满幅值电压；$B_1$是二进制最高有效位，$B_n$为最低有效位。</p><p>D/A转换器包括解码和信号恢复两个变换。<strong>解码</strong>用于把数字量转换为幅值等于该数字量的模拟脉冲信号（离散模拟信号，时间离散，幅值是模拟脉冲信号（电压、电流））。</p><p><strong>信号恢复器（保持器）</strong>将离散的模拟脉冲信号按一定的规则保持规定的时间间隔T，把时间离散变成时间上连续。</p><p><strong>D/A转换的误差</strong>：主要由D/A转换器转换精度（转换器字长）和保持器（采样点之间的插值）的形式以及时间间隔T来决定。</p><h3 id="A-D转换"><a href="#A-D转换" class="headerlink" title="A/D转换"></a>A/D转换</h3><p>四种类型：</p><ol><li>计数器式。速度慢，便宜</li><li>并行比较式。用在高速采样 ，当位数多成本高</li><li>双积分式。精度高，有较强抗干扰能力，速度慢，用在高精度低速度场合</li><li>逐次逼近式。兼顾精度和速度，在16位以下广泛使用</li></ol><p>A/D转换要完成采样、量化和编码3个变换。</p><p><strong>采用保持器</strong>对连续的模拟输入信号按一定时间间隔T进行采样，变成时间离散、幅值等于采样时刻输入信号值的序列信号。</p><p><strong>量化</strong>是将采样时刻的信号幅值按最小量化单位取整过程。量化单位越小，采样时刻信号的幅值与变换成的有限维数的二进制数码的差异越小。精度越高。</p><p><strong>编码</strong>将量化的分层信号变换成二进制数码（只是信号形式的改变），是一个无差的等效变换过程。</p><p><strong>A/D转换误差</strong>主要由A/D转换器转换速率（孔径时间）和转换精度（量化误差）来决定。</p><h2 id="计算机控制系统的理论问题"><a href="#计算机控制系统的理论问题" class="headerlink" title="计算机控制系统的理论问题"></a>计算机控制系统的理论问题</h2><p>1、信号转换问题</p><p>​       计算机控制系统在结构上 通常是模拟和数字部件组成的混合系统。</p><p>2、对象建模与性能分析</p><p>​       计算机控制系统是由纯离散系统的计算机和纯连续系统的被控对象构成的混合系统。为了便于分析和设计，都等效地看成<strong>离散系统</strong>处理。对离散系统通常采用<strong>时域的差分方程、复数域的z变换和脉冲传递函数、频域的频率特性以及离散状态空间方程</strong>作为系统数学描述的基本工具。</p><p>3、控制算法设计</p><p>​       研究对象的日趋复杂化，常规控制理论常常难以解决复杂控制系统的控制问题。</p><p>4、控制系统实现技术</p><p>​       采用数字控制器因而会产生数值误差。</p><h2 id="计算机控制系统的基本类型"><a href="#计算机控制系统的基本类型" class="headerlink" title="计算机控制系统的基本类型"></a>计算机控制系统的基本类型</h2><p>按照功能和结构划分，有：</p><p>1、操作指导控制系统。</p><p>​       提供现场情况和进行异常报警，还按照预先建立的数学模型和控制算法进行运算和处理，得出最优设定值打印显示，操作人员根据计算机给出的操作指导，并根据实际经验，经过分析判断，由人直接改变调节器的给定值或操作执行机构。</p><p>2、直接数字控制系统。</p><p>​       DDC系统是计算机把运算结果直接输出去控制生产过程。属于闭环系统，计算机系统对生产过程各参量进行检测，根据规定的数学模型，如PID算法进行运算，发出控制信号，直接控制生产过程。</p><p>​       不仅能完全取代模拟调节器，而且只要改变程序就可以实现其他的复杂控制规律，如前馈控制、非线性控制等。</p><img src="/blog/2020/05/15/计算机控制系统/1563427170177.png" title="直接数字控制系统"><p>3、计算机监督控制系统。</p><p>​       SCC（supervisory computer control）也称为计算机设定值控制系统。计算机的输出用来直接改变模拟调节器或DDC的设定值。</p><p>​       由两种形式：</p><p>​       <strong>SCC+模拟调节器的系统</strong></p><img src="/blog/2020/05/15/计算机控制系统/1563427343113.png" title="SCC+模拟调节器系统"><p>​      优点：能始终使得生产过程处于最优运行状态，与操作指导控制系统相比，不会因手调设定值的方式不同而引起控制质量的差异。灵活安全，出现故障仍可由模拟调节器单独完成操作。</p><p>​       缺点：需要采用模拟调节器。</p><p>​       <strong>SCC+DCC系统</strong></p><img src="/blog/2020/05/15/计算机控制系统/1563427517053.png" title="SCC+DCC系统"><p>​       SCC的输出直接改变DDC的设定值，两者之间通过数据传输直接实现。通常一台SCC可以控制数个DDC计算机，一旦DDC发生故障，可用SCC计算机代替DDC，确保生产的正常进行。</p><p>4、分级控制系统。</p><p>​       由管理信息系统（MIS）、计算机监督控制（SCC）和直接数字控制（DDC）三级控制组成。</p><img src="/blog/2020/05/15/计算机控制系统/1563427717723.png" title="分级控制系统"><p>SCC级为分级控制的中间级，功能是集中生产过程信息，对生产过程进行优化、实现自适应或最控制等，指挥DCC，接收MIS级命令并向MIS级汇报。</p><p>DDC用于直接控制生产过程，多采用微型机。</p><p>5、集散控制系统</p><p>​       DCS（distributed control system）是由微型机为核心的过程控制单元（PCU）、高速数据通道（DHW）、操作人员接口单元（OIU）和监控计算机等部分组成。</p><img src="/blog/2020/05/15/计算机控制系统/1563427946159.png" title="集散控制系统"><p>由于生产过程的大型化、复杂化和分散化，若采用一台计算机控制和管理，一旦计算机发生故障，整个系统停顿，“危险集中”。</p><p>集散控制的<strong>设计思想</strong>：“危险分散”，将控制功能分散，将监控和操作功能高度集中。</p><ul><li>PCU：由很多模板组成，每个控制模板是以微处理器为核心组成的功能板，可以对几个回路进行PID、前馈等多种控制。一个控件发生故障，只影响与之相关的几个回路，达到“危险分散”目的。PCU可以安装在离变送器和执行机构近的地方，缩短控制回路长度，减少噪声，提高可靠性，达到“地理上”分散。</li><li>DHW：将各个PCU、OIU、监控计算机等有机连接【相互协调不可分】起来以实现高级控制和集中控制。挂在DHW上任一单元发生故障，都不会影响其他单元之间的通信联系和正常工作。</li><li>OIU：实现集中监视和集中操作</li><li>监控计算机：实现最优控制和管理。监控机的功能是存取工厂所有的信息和控制参数，打印综合报告，能进行长期趋势分析以及进行最优化计算机控制，控制各个现场过程控制单元（PCU）工作。</li></ul><p>6、总线控制系统。</p><p>​       现场总线控制系统（field  control system，FCS）的体系结构主要表现在：现场通信网络、现场设备互连、控制功能分散、通信线供电、开放式互联网络等方面。</p><p>​        FCS底层产品都带有<strong>CPU的智能单元</strong>【包括智能传感器、智能执行器等】，突破传统DCS的底层产品4-20mA模拟信号的传输。智能单元靠近现场设备，可以独立地完成测量、校正、调整、诊断和控制功能。现场总线协议将它们连接在仪器，任何一个单元出现故障都不会影响到其他单元，更不会影响全局，实现彻底的分散控制，更安全、可靠。</p><p>7、以太控制网络。</p><p>​       以太控制网络<strong>最典型的应用形式</strong>为：顶层采用Ethernet（以太网，局域网技术，包括<a href="https://baike.baidu.com/item/物理层" target="_blank" rel="noopener">物理层</a>的连线、电子信号和介质访问层<a href="https://baike.baidu.com/item/协议" target="_blank" rel="noopener">协议</a>的内容），网络层和传输层采用TCP/IP协议。嵌入式控制器、智能现场测控仪表和传感器可以很方便的接入以太控制网。</p><p>​       以太控制网容易与信息网络集成，组建统一的企业风格。以太控制避免了现场总线技术游离于计算机网络技术之外，使得现场总线技术和网络技术融合，实现网络控制系统的彻底开放。</p><h1 id="信号转换"><a href="#信号转换" class="headerlink" title="信号转换"></a>信号转换</h1><h2 id="信号变换原理"><a href="#信号变换原理" class="headerlink" title="信号变换原理"></a>信号变换原理</h2><h3 id="计算机控制系统信号转换分析"><a href="#计算机控制系统信号转换分析" class="headerlink" title="计算机控制系统信号转换分析"></a>计算机控制系统信号转换分析</h3><img src="/blog/2020/05/15/计算机控制系统/1563430889330.png" title="计算机控制系统信号"><p>（1）模拟信号。时间上连续，幅值上连续。即连续信号。</p><p>（2）离散模拟信号。时间上离散，幅值上连续的信号。即采样信号</p><p>（3）数字信号。时间上离散，幅值上离散（已经量化）的信号，可用一个序列数字表示</p><p>（4）量化。采用一组数码（多用二进制数码）来逼近 离散模拟信号的幅值，将其转换为数字信号</p><p>（5）采样。将模拟信号按一定的时间间隔抽样成离散模拟信号的过程。</p><img src="/blog/2020/05/15/计算机控制系统/1563431168766.png" title="采样过程"><p>采样函数可以用$x^<em>(t)$、$y^</em>(t)$及$e^<em>(t)$表示，`</em>`表示离散化。</p><p>采样分为：</p><ul><li>均匀采样：采样周期不变</li><li>非均匀采样：采样周期变化</li><li>随机采样：采样间隔大小随机变化</li></ul><h3 id="采样过程及采样函数的数学表示"><a href="#采样过程及采样函数的数学表示" class="headerlink" title="采样过程及采样函数的数学表示"></a>采样过程及采样函数的数学表示</h3><img src="/blog/2020/05/15/计算机控制系统/1563431405728.png" title="采样函数"><p>得到时间上离散的数值序列：<br>$$<br>f^*(t) = \{f(0T),f(1T),f(2T),\dots,f(kT),\dots\}<br>$$<br>其中$T$为采样周期。</p><p>==脉冲采样==：</p><img src="/blog/2020/05/15/计算机控制系统/1563431537001.png" title="脉冲采样"><p>采样周期$T$比采样开关闭合时间$\tau$大很多，即$\tau \ll T$，$\tau$比起被控对象的时间常数也非常小，认为$\tau \rightarrow 0$。</p><p>连续函数$f(t)$，经脉冲采样器调制后输出的一个采样函数$f^*(t)$。其中$\delta_T(t)=\sum\limits_{k=0}^{\infty} \delta(t-kT)$为单位理想脉冲序列。</p><p>采样函数：<br>$$<br>f^<em>(t) = f(t)\delta_T(t)=f(t)\sum\limits_{k=0}^{\infty} \delta(t-kT)<br>$$<br>其中$ \delta(t-kT)$为$t=kT$时刻的理想单位脉冲，定义为：<br>$$<br>\delta(t-kT) =\begin{equation}<br>\left\{<br>\begin{array}{lr}<br> \infty , t=kT\\<br> 0, t \ne kT<br> \end{array}<br> \right.<br>\end{equation}<br>$$<br>且冲量为1，即：<br>$$<br>\int_{0}^{\infty} \delta(t-kT)dt = 1<br>$$<br>得到理想脉冲采样函数数学表达式：<br>$$<br>f^</em>(t) =\sum\limits_{k=0}^{\infty} f(kT)\delta(t-kT)<br>$$<br>其中，$\delta(t-kT)$仅表示脉冲存在的时刻，冲量为1；脉冲的大小由采样时刻的函数值$f(kT)$决定，称为<strong>脉冲强度</strong>。</p><h3 id="采样函数的频谱分析及采样定理"><a href="#采样函数的频谱分析及采样定理" class="headerlink" title="采样函数的频谱分析及采样定理"></a>采样函数的频谱分析及采样定理</h3><p>$$<br>f^*(t) =f(t)\sum\limits_{k=0}^{\infty} \delta(t-kT)<br>$$</p><p>$$<br>\delta_T(t) =  \sum\limits_{k=-\infty}^{\infty}\delta(t-kT)= \sum\limits_{k=-\infty}^{\infty}C_ke^{jkw_st}<br>$$</p><p>其中，$w_s = \frac{2\pi}{T}$为采样角频率；$C_k$为傅里叶系数，表示为：<br>$$<br>C_k = \frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}} \delta_T(t)e^{-jkw_st}dt<br>$$<br>$\delta_T(t)$在$\left[-\frac{T}{2},\frac{T}{2}\right]$时间内，仅在$t=0$时有脉冲，脉冲函数的筛选性，即：<br>$$<br>\int_{-\infty}^{\infty}\delta(t)f(t)dt = f(t) |_{t=0}<br>$$</p><p>$$<br>C_k = \frac{1}{T}e^{-jkw_s t}|_{t=0} = \frac{1}{T}<br>$$</p><p>$$<br>\delta_T(t) = \frac{1}{T}\sum\limits_{k=-\infty}^{\infty}e^{jkw_st}<br>$$</p><p>所以，采样函数可以写成：<br>$$<br>f^<em>(t) = \frac{1}{T}\sum\limits_{k=-\infty}^{\infty}f(t)e^{jkw_st}<br>$$<br>由拉氏变换$F(s) = \int_{0}^{\infty} f(t)e^{-st}dt$可得：<br>$$<br>F^</em>(s) = \int_{0}^{\infty}f^<em>(t)e^{-st}dt=\int_{0}^{\infty}\frac{1}{T}\sum\limits_{k=-\infty}^{\infty}f(t)e^{jkw_et}e^{-st}dt<br>$$<br>根据拉氏变换复位移定理得：<br>$$<br>F^</em>(s) = \frac{1}{T} \sum\limits_{k=-\infty}^{\infty}F(s-jkw_s)<br>$$<br>令$s=jw，n=-k$，直接求得采样函数得傅里叶变换式：<br>$$<br>F^<em>(jw) = \frac{1}{T}\sum\limits_{n=-\infty}^{\infty}F(jw+jnw_s)<br>$$<br>$F^</em>(jw)$为采样函数$f^*(t)$得频谱函数。</p><img src="/blog/2020/05/15/计算机控制系统/1563433414794.png"><p>采样周期$T$的选择会影响$f^<em>(t)$的频谱，<em>*采样定理要解决的问题是</em></em>：采样周期选多大，才能将采样信号较少失真地恢复为原连续信号。</p><p>==shannon采样定理==：<br>$$<br>w_s \ge 2w_{max}<br>$$<br>$$<br>T \le \frac{\pi}{w_{max}}<br>$$</p><p>如果一个连续信号不包含高于频率$w_{max}$的频率分量，完全可以用周期$T&lt; \frac{\pi}{w_{max}}$的均匀采样值来描述，即当采样频率$w_s &gt; 2w_{max}$，可以从采样信号中不失真地恢复原连续信号。</p><h2 id="采样恢复与保持器"><a href="#采样恢复与保持器" class="headerlink" title="采样恢复与保持器"></a>采样恢复与保持器</h2><p>计算机作为信息处理装置，其输出一般有两种形式：一是直接数字量输出，如开关形式、步进电机控制等；一种是需要将数字信号$u(kT)$转换为连续信号$u(t)$。</p><p>数字信号无失真的恢复成连续信号，有Shannon采样定理，采样频率$w_s \ge 2w_{max}$，则在被控对象前加一个理想滤波器：</p><img src="/blog/2020/05/15/计算机控制系统/1563434410526.png" title="采样恢复与保持器"><p>实际所采用的是<strong>保持器</strong>，与理想滤波器特性相近的物理可实现。</p><p>从脉冲序列$u^<em>(t)$的全部信息种恢复原来的连续信号$u(t)$，通过保持器来完成这个恢复过程。实际是一个多项式外推装置。一<strong>个方法是利用$u(t)$的幂级数展开公式</strong>，即：<br>$$<br>u(t)=u(kT) +u’(kT)(t-kT)+\frac{u’’(kT)}{2}(t-kT)^2+\dots,kT\le t&lt;(k+1)T<br>$$<br>若按第一项组成外推器，所用$u(t)$的多项式是零阶的，称为<strong>零阶保持器</strong>，若按前两项组成外推装置，所用的多项式是一阶的，称为<em>*一阶保持器</em></em>。</p><p>导数值可以用各个采样时刻的各阶差商来表示，即：<br>$$<br>u’(kT) = \frac{1}{T}\{u(kT)-u[(k-1)T]\}<br>$$</p><p>$$<br>u’’(kT) = \frac{1}{T}\{u’(kT)-u’[(k-1)T]\}<br>$$</p><p>同理可得$u’[(k-1)T]$，以此类推得：<br>$$<br>u’’(kT) = \frac{1}{T^2}\{u(kT) - 2u[(k-1)T]+u[(k-2)T]\}<br>$$</p><h3 id="零阶保持器"><a href="#零阶保持器" class="headerlink" title="零阶保持器"></a>零阶保持器</h3><p>$$<br>u_h(t) =u(t)= u(kT),kT \le t\le(k+1)T<br>$$</p><p>特点是：零阶保持器把$kT$时刻的采样值，简单的、不增不减地保持到下一个采样时刻$(k+1)T$到来之前。</p><img src="/blog/2020/05/15/计算机控制系统/1563435974531.png" title="零阶保持器"><p>零阶保持器的传递函数：</p><img src="/blog/2020/05/15/计算机控制系统/1563436285801.png" title="零阶保持器传递函数"><p>脉冲响应函数$g_0(t)$分解后线性叠加：<br>$$<br>g_0(t) = l(t)-l(t-T)<br>$$<br>阶跃函数$l(t) = \cases{1,t\ge0 \ 0,t&lt;0}$</p><p>拉氏变换为：<br>$$<br>G_0(s) = L[g_0(t)] = \frac{1}{s}-\frac{1}{s}e^{-st} = \frac{1-e^{-st}}{s}<br>$$<br>输入单位脉冲$\delta(t)$的拉氏变换：<br>$$<br>X(s) = L[\delta(t)]=1<br>$$<br>零阶保持器的传递函数为：<br>$$<br>W_{h0}(s) = \frac{G_0(s)}{X(s)} = \frac{1-e^{-sT}}{s}<br>$$<br>零$s=jw$，得到零阶保持器的频率特性。</p><h3 id="一阶保持器"><a href="#一阶保持器" class="headerlink" title="一阶保持器"></a>一阶保持器</h3><p>$$<br>\begin{equation}<br>\begin{aligned}<br>u_h(t) &amp;= u(kT)+u’(kT)(t-kT),kT  \le t &lt;(k+1)T \ &amp;= u(kT) +\frac{u(kT)-u[(k-1)T]}{T}(t-kT)<br>\end{aligned}<br>\end{equation}<br>$$</p><h2 id="z变换及反变换"><a href="#z变换及反变换" class="headerlink" title="z变换及反变换"></a>z变换及反变换</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>是拉氏变换的特殊形式，在离散系统的分析及设计中发挥重要作用。<br>$$<br>F(s)= L[f(t)] = \int_{-\infty}^{\infty}f(t)e^{-st}dt<br>$$</p><p>$$<br>f^*(t) =\sum\limits_{k=0}^{\infty} f(kT)\delta(t-kT)<br>$$</p><p>其拉氏变换为：<br>$$<br>F^<em>(s) = L[f^</em>(T)] =\sum\limits_{k=0}^{\infty}f(kT)\left[\int_{-\infty}^{\infty}\delta(t-kT)e^{-st}dt\right]<br>$$<br>根据广义脉冲函数$\delta(t)$的性质：<br>$$<br>\int_{-\infty}^{\infty}\delta(t-kT)e^{-st}dt = e^{-skT}=L[\delta(t-kT)]<br>$$<br>令$z= e^{sT}$，得采样函数$f^<em>(t)$的$z$变换为：<br>$$<br>F^</em>(s) = \sum\limits_{k=0}^{\infty}f(kT)e^{-skT}<br>$$<br>$$<br>F(z) = \sum\limits_{k=0}^{\infty}f(kT)z^{-k}<br>$$</p><p>其中$f(kT)$表示时间序列的强度，$z^{-k}$表示时间序列出现的时刻，相对时间的起点，延迟了$k$个采样周期。$F(z)$既包含了信号幅值的信息，又包含了时间信息。</p><p><strong>注意到</strong>：在z变换中，仅仅考虑到采样时刻的采样值，所以$F(z)$只能表征采样函数$f^*(t)$的z变换，只能表征连续时间函数$f(t)$在采样时刻上的特性，不能表征采样点之间的特性。</p><h3 id="z变换方法"><a href="#z变换方法" class="headerlink" title="z变换方法"></a>z变换方法</h3><h3 id="z变换的基本定理"><a href="#z变换的基本定理" class="headerlink" title="z变换的基本定理"></a>z变换的基本定理</h3><h3 id="z反变换"><a href="#z反变换" class="headerlink" title="z反变换"></a>z反变换</h3><p>从$z$变换$F(z)$求出采样函数$f^<em>(t)$，称为$z$反变换，表示为：<br>$$<br>Z^{-1}[F(z)] = f^</em>(t)<br>$$<br>$z$变换得到的是各采样时刻上连续函数$f(t)$的数值序列值$f(kT)$，得不到两个采样时刻之间的连续函数的信息，因此无法用$z$反变换方法求出原连续函数$f(t)$，即$Z^{-1}[F(z)] \ne  f(t)$。</p><h3 id="扩展z变换"><a href="#扩展z变换" class="headerlink" title="扩展z变换"></a>扩展z变换</h3><p>因为$F(z)$只能反映连续信号$f(t)$在各个采样时刻的变换情况 ，而不能反映$f(t)$在采样时刻之间的任何变换信息。$z$变换的分析方法及所得结论只针对一些离散时刻有效，而在这些离散时刻之间的时刻是无效的。</p><p>在计算机控制系统的分析和设计时，不仅需要知道在采样点上的输入、输出关系，还要知道采样点之间的输入、输出关系，需要扩展$z$变换。</p><h1 id="计算机控制系统数学描述与性能分析"><a href="#计算机控制系统数学描述与性能分析" class="headerlink" title="计算机控制系统数学描述与性能分析"></a>计算机控制系统数学描述与性能分析</h1><h2 id="离散系统"><a href="#离散系统" class="headerlink" title="离散系统"></a>离散系统</h2><p>离散时间系统的输入和输出均为离散信号，离散系统可以抽象为一种系统的离散输入信号和系统的离散输出信号之间的数学变换和映射。</p><p>设单输入单输出的离散系统$D$的输入为$e(k)$，输出为$u(k)=u(kT)$。两者都是离散的数值序列。</p><img src="/blog/2020/05/15/计算机控制系统/1563498246228.png" title="离散系统"><p>有：<br>$$<br>u(k) = D[e(k)]<br>$$<br>$$<br>e(k)=ae_1(k) +be_2(k)<br>$$</p><p>$$<br>u(k) = aD[e_1(k)]+bD[e_2(k)]<br>$$</p><p>该系统的变换函数$D$是线性的，$u(k)$与$e(k)$之间是线性关系。</p><p>系统$D$的参数不随时间变化，即系统$D$的响应不取决于输入作用的时刻，系统是常系数的，即<strong>定常系统</strong>。</p><p>线性常系数离散系统一般采用<strong>差分方程</strong>来描述。系统在某一时刻$k$的输出$u(k)$，不仅取决于本时刻的输入$e(k)$，与过去的时刻的输入数值序列$e(k-1),e(k-2),\dots$有关，还与该时刻以前的输出值有关，即：<br>$$<br>\begin{equation}<br>\begin{aligned}<br>&amp; u(k)+a_1u(k-1)+a_2u(k-2)+\dots+a_nu(k-n) \ &amp;=b_0e(k) +b_1e(k-1)+b_2e(k-2)+\dots+b_me(k-m)<br>\end{aligned}<br>\end{equation}<br>$$<br>即：<br>$$<br>u(k) = -\sum\limits_{i=1}^na_iu(k-i) +\sum\limits_{j=0}^mb_je(k-j)<br>$$<br>当系数均为常数时，是一个$n$阶线性常系数差分方程。上式是后向非齐次差分方程。</p><p><strong>前向差分方程和后向差分方程区别</strong>：前向多用于描述非零初始值的离散系统，后向多用于描述全零初始值的离散系统。</p><h2 id="差分方程"><a href="#差分方程" class="headerlink" title="差分方程"></a>差分方程</h2><p>描述离散控制系统，通过差分方程的求解，来分析和设计离散控制系统。</p><p>差分方程的解法有迭代法、经典解法和$z$变换解法。</p><h4 id="差分方程解法"><a href="#差分方程解法" class="headerlink" title="差分方程解法"></a>差分方程解法</h4><h2 id="脉冲传递函数"><a href="#脉冲传递函数" class="headerlink" title="脉冲传递函数"></a>脉冲传递函数</h2><p>线性连续系统的动态特性主要用传递函数来描述 ，线性离散控制系统则主要用<strong>脉冲传递函数</strong>来描述，脉冲传递函数也简称为$z$传递函数。</p><p><strong>脉冲传递函数定义：</strong></p><p>在线性离散控制系统中，在零初始条件下，一个 系统（或环节）输出脉冲序列的$z$变换与输入脉冲序列的$z$变换之比，即：<br>$$<br>W(z)= \frac{Y(z)}{X(z)}=\frac{输出脉冲序列的z变换 }{输入脉冲序列的z变换}<br>$$<br>脉冲传递函数<strong>仅取决于系统本身的特性</strong>，与输入量无关。</p><p>脉冲传递函数的推导：</p><h3 id="计算机控制系统的脉冲传递函数"><a href="#计算机控制系统的脉冲传递函数" class="headerlink" title="计算机控制系统的脉冲传递函数"></a>计算机控制系统的脉冲传递函数</h3><img src="/blog/2020/05/15/计算机控制系统/1563499824430.png" title="计算机控制系统的脉冲传递函数"><p>计算机控制系统由数字部分和连续对象部分构成的闭环控制系统，数字部分表示控制算法，它的输入和输出皆为离散信号序列。</p><p>可用脉冲传递函数$D(z)$来表示输出输入关系。再求出连续系统的等效脉冲传递函数$W_d(z)$，得到控制系统的各种脉冲传递函数。</p><h2 id="计算机控制系统的稳定性分析"><a href="#计算机控制系统的稳定性分析" class="headerlink" title="计算机控制系统的稳定性分析"></a>计算机控制系统的稳定性分析</h2><p>稳定性分析的基础是$z$变换，$z$变换与连续系统$s$变换在数学上的内在联系，可经过一定的变换把分析连续系统稳定性的方法引入到离散控制系统中。</p><p>由$s$平面上稳定性条件来分析$z$平面的稳定条件，然后由$s$平面到$z$平面的映射，分析采样周期对系统稳定性的影响。</p><h3 id="离散系统的稳定性条件"><a href="#离散系统的稳定性条件" class="headerlink" title="离散系统的稳定性条件"></a>离散系统的稳定性条件</h3><p>在连续系统中，闭环传递函数可以写成两个多项式之比：<br>$$<br>\frac{Y(s)}{R(s)} = \frac{b_0s^m +\dots+b_{m-1}s+b_m}{s^n +a_1s^{n-1}+\dots +a_{n-1}s +a_n}<br>$$<br><strong>连续系统稳定条件</strong>：闭环传递函数的全部极点位于$s$平面的做半平面内，或传递函数的极点具有负实部。</p><p>在离散系统中，若输入序列有限，其输出序列也是有限的。</p><p><strong>离散系统稳定性条件</strong>：闭环脉冲传递函数的全部极点位于$z$平面上以原点为圆心的单位圆内。</p><h3 id="采样周期与系统稳定性关系"><a href="#采样周期与系统稳定性关系" class="headerlink" title="采样周期与系统稳定性关系"></a>采样周期与系统稳定性关系</h3><p>计算机控制系统的控制对象是连续系统，等效离散化后的闭环系统的$z$传递函数模型与采样周期选取有关，极点分布也与采样周期的选取有关。</p><p><strong>一般来说，采样周期越小，系统稳定性越高</strong>，采样周期对系统稳定性的影响主要是由计算机控制系统中采样保持器引起的。</p><h2 id="离散系统稳定性的代数判据"><a href="#离散系统稳定性的代数判据" class="headerlink" title="离散系统稳定性的代数判据"></a>离散系统稳定性的代数判据</h2><h3 id="劳斯稳定性判据"><a href="#劳斯稳定性判据" class="headerlink" title="劳斯稳定性判据"></a>劳斯稳定性判据</h3><p>连续系统通过判断系统特征方程的根是否都在$s$平面虚轴左边来确定系统是否稳定。离散系统的稳定边界是$z$平面的单位圆，而不是虚轴，连续系统的Routh判据不能直接应用于离散系统的稳定性判别，需要引入$\omega$<strong>变换（双线性变换）</strong>。</p><p>通过$\omega$变换，把离散系统在$z$平面的稳定边界单位圆映射为新的$\omega$平面的虚轴；把离散系统$z$平面的稳定域——单位圆内部区域映射为新的$\omega$平面的左半平面，并且将离散系统原来以$z$为变量的特征多项式化为以$\omega$为变量的特征多项式。</p><p>$\omega$变换的定义为：<br>$$<br>z= \frac{1+(T/2)\omega}{1-(T/2)\omega}<br>$$<br>其中$T$为采样周期，得到$\omega$的解为：<br>$$<br>\omega = \frac{2}{T}·\frac{z-1}{z+1}<br>$$</p><h3 id="朱利稳定性判据"><a href="#朱利稳定性判据" class="headerlink" title="朱利稳定性判据"></a>朱利稳定性判据</h3><p>Jury稳定性判据是根据系统特征方程的系数判断系统的稳定性，不用求特征方程的根。</p><p>Jury一个重要优点是可以在$z$域直接进行，不需要进行$z-\omega$变换。</p><p>Routh判据不仅可以判断系统的稳定性，还可以判断出不稳定极点的个数，Jury判据只能判断出系统是否稳定。</p><h2 id="计算机控制系统稳态过程分析"><a href="#计算机控制系统稳态过程分析" class="headerlink" title="计算机控制系统稳态过程分析"></a>计算机控制系统稳态过程分析</h2><p>稳态指标是用<strong>稳态误差</strong>来表示，稳态误差是系统过渡过程结束到达到稳态以后，系统参数输入与系统输出之间的偏差。</p><p>稳态误差越小，系统控制稳态精度越高。</p><h2 id="计算机控制系统暂态分析"><a href="#计算机控制系统暂态分析" class="headerlink" title="计算机控制系统暂态分析"></a>计算机控制系统暂态分析</h2><p>暂态分析主要用系统在单位阶跃输入信号作用下的相应特性来描述，反映控制系统的动态过程。</p><p>主要性能指标用超调量$\sigma \%$、上升时间$t_r$、峰值时间$t_p$和调节时间$t_s$表示。</p><h2 id="计算机控制系统的频域特性分析"><a href="#计算机控制系统的频域特性分析" class="headerlink" title="计算机控制系统的频域特性分析"></a>计算机控制系统的频域特性分析</h2><h3 id="离散系统的频域描述"><a href="#离散系统的频域描述" class="headerlink" title="离散系统的频域描述"></a>离散系统的频域描述</h3><p>在连续系统中，一个系统（或环节）的频域特性是指，在正弦信号作用下，系统（或环节）的稳态输出与输入的复数比随输入信号频率变换的特性。</p><p>连续系统的频率特性公式：<br>$$<br>W(jw)= W(s)|_{s=jw}<br>$$<br>可得到离散系统的频率特性公式：<br>$$<br>W(e^{jwT})=W(z)|_{z=e^{jwT}}<br>$$<br>连续系统的频率特性$W(jw)$随着$w$变化，相当于$W(s)$当$s$沿虚轴变化时$s=jw$的特性；</p><p>离散系统的频率特性$W(e^{jwT})$相当于考察传递函数$W(z)$当$z$沿单位圆变化时$z=e^{jwT}$的特性。</p><h3 id="离散系统频域稳定性分析"><a href="#离散系统频域稳定性分析" class="headerlink" title="离散系统频域稳定性分析"></a>离散系统频域稳定性分析</h3><p>在离散系统中，奈奎斯特稳定判据（<strong>奈氏判据</strong>）根据<strong>复变函数的幅角原理，利用开环频率特性来判别闭环系统的稳定性。</strong></p><p>设离散系统的开环脉冲传递函数为$W_K(z) = \frac{M(z)}{N(z)}$，阶次低于$N(z)$的阶次，相应的单位反馈系统的闭环脉冲传递函数为：<br>$$<br>W_B(z) = \frac{W_K(z)}{1+W_K(z)} = \frac{M(z)}{M(z)+N(z)} = \frac{M(z)}{F(z)}<br>$$<br>系统闭环特征方程为：<br>$$<br>P(z) = 1+W_K(z) =\frac{M(z)+N(z)}{N(z)}=\frac{F(z)}{N(z)} =0<br>$$<br>其中$N(z)$是系统开环特征多项式，零点为开环系统极点；$F(z)$为系统闭环特征多项式，零点为闭环系统极点。</p><p>闭环系统稳定的充要条件：$F(z)$(或P(z))在单位圆外无零点。</p><h3 id="离散系统伯德图分析"><a href="#离散系统伯德图分析" class="headerlink" title="离散系统伯德图分析"></a>离散系统伯德图分析</h3><p>伯德图广泛应用于单输入单输出连续系统的设计，原理是利用开环系统的对数频率特性，对系统稳定性、稳态性能和暂态性能及逆行分析，是常用的系统频率特性的性能分析和校正环节的设计方法。</p><h1 id="数字控制器模拟化设计方法"><a href="#数字控制器模拟化设计方法" class="headerlink" title="数字控制器模拟化设计方法"></a>数字控制器模拟化设计方法</h1><img src="/blog/2020/05/15/计算机控制系统/1563504258372.png" title="数字控制器模拟化设计"><p>对于混合计算机控制系统，包括数字信号、模拟信号、离散模拟信号和量化模拟信号。</p><p><strong>模拟化设计方法有两种</strong>：一是利用熟悉的各种模拟系统设计方法（连续域设计方法）设计满意的模拟控制器，然后将其离散化为数字控制器。【<strong>数字控制器的模拟化设计方法</strong>】；二是首先把模拟被控对象连续部分离散化，然后直接在离散域设计数字控制器。【<strong>离散化设计（直接设计）方法</strong>】</p><p>对于数字化控制器模拟化设计方法：关心点在于把混合系统当作模拟系统来设计需要什么约束条件以及模拟控制器的离散化会给系统的性能带来什么影响。</p><h2 id="连续控制器的离散化方法"><a href="#连续控制器的离散化方法" class="headerlink" title="连续控制器的离散化方法"></a>连续控制器的离散化方法</h2><p>连续控制器的离散化是求连续控制器的传递函数$D(s)$的等效离散传递函数$D(z)$。</p><p>离散化的方法包括：$z$变换、差分变换、双线性变换、零极点匹配法等</p><h2 id="数字PID控制器"><a href="#数字PID控制器" class="headerlink" title="数字PID控制器"></a>数字PID控制器</h2><p>PID控制器表示比例（proportional）-积分（integral）-微分（differential）控制规律。控制器的输出和输入是比例-积分-微分关系。</p><p>基本的数字PID控制算法包括<strong>位置式PID控制算法</strong>和<strong>增量式PID控制算法</strong>。</p><p><strong>模拟PID控制器算法</strong>为：<br>$$<br>u(t) = K_p\left[e(t)+\frac{1}{T_i}\int_{0}^{t}e(t)dt+T_d\frac{de(t)}{dt}\right]<br>$$<br>其中，$u(t)$为输出；$e(t)$为输入；$K_p$为比例系数；$T_i$为积分时间常数；$T_d$为微分时间常数。</p><p><strong>模拟PID的传递函数形式</strong>：<br>$$<br>D(s)= \frac{U(s)}{E(s)} = K_p\left(1+\frac{1}{T_is} +T_d s\right)<br>$$<br><strong>模拟PID控制器离散化处理</strong>：用后向差分近似代替微分<br>$$<br>\begin{equation}<br>\left\{</p><p>\begin{array}{lr}<br>u(t)\approx u(kT)\\e(t) \approx e(kT) \ \int_{0}^{t}e(t)dt \approx T\sum\limits_{i=1}^{k}e(iT) \ \frac{de(t)}{dt}\approx \frac{e(kT)-e(kT-T)}{T}<br>\end{array}<br>\right.<br>\end{equation}<br>$$<br>省略采样周期$T$，即$kT=T$，有：<br>$$<br>\begin{equation}<br>\begin{aligned}<br>u(k)&amp;= K_p \left\{ e(k) +\frac{T}{T_i}\sum\limits_{j=1}^{k}e(j) + \frac{T_d}{T}[e(k)-e(k-1)]          \right\} \ &amp;= K_pe(k) +K_i\sum\limits_{j=1}^{k}e(j) +K_d[e(k)-e(k-1)]<br>\end{aligned}<br>\end{equation}<br>$$<br>其中$K_i = K_p\frac{T}{T_i}$为积分系数；$K_d$为微分系数，上式为<strong>位置式数字PID控制算法</strong>。</p><p><strong>增量式数字PID算法</strong>：</p><p>由位置式PID控制算法得：<br>$$<br>u(k-1) = K_pe(k-1) +K_i\sum\limits_{j=1}^{k-1}e(j) +K_d[e(k-1)-e(k-2)]<br>$$</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>\Delta u(k) &amp;= u(k) - u(k-1)\ &amp; = K_p[e(k)-e(k-1)]+K_ie(k) +K_d[e(k) -2e(k-1)+e(k-2)]<br>\end{aligned}<br>\end{equation}<br>$$</p><p>增量式PID算法表示执行机构（如阀门、步进电机等）得调节增量，即$k$时刻相对于$k-1$时刻的调节增量。</p><p><strong>位置式数字PID控制算法一般形式</strong>：</p><p>由增量式PID算法得：<br>$$<br>\begin{equation}<br>\begin{aligned}<br>u(k) &amp;= u(k-1) +\Delta u(k) \ &amp;= u(k-1) +K_p[e(k)-e(k-1)]+K_ie(k) +K_d[e(k)-2e(k-1)+e(k-2)]</p><p>\end{aligned}<br>\end{equation}<br>$$</p><h2 id="数字PID控制器算法工程化改进"><a href="#数字PID控制器算法工程化改进" class="headerlink" title="数字PID控制器算法工程化改进"></a>数字PID控制器算法工程化改进</h2><h3 id="积分分离数字PID算法（PD算法）"><a href="#积分分离数字PID算法（PD算法）" class="headerlink" title="积分分离数字PID算法（PD算法）"></a>积分分离数字PID算法（PD算法）</h3><p>很多控制系统在开始启动、停止或较大幅度改变给定信号时，控制器输入端都会产生较大的偏差（系统给定和输出信号之间的偏差），PID算法中的积分项经过短时间积累就会使得控制量$u(k)$变得很大甚至达到饱和（执行机构的机械极限），此时控制系统会处于一种非线性状态，不能根据控制器输入偏差的变化按预期控制规律来正确地改变控制量。</p><p>积分项很大，需要经过很长时间误差才能被减下来，系统会产生严重超调。</p><p><strong>直接改进方法</strong>是把积分项分离出来，当偏差绝对值超出分离阈值A时，积分不起作用，构成PD控制器。当偏差绝对值在阈值范围内，积分起作用。<br>$$<br>u(k) = K_pe(k)+K_1K_i\sum\limits_{j=1}^{k} e(j) K_d[e(k) - e(k-1)]<br>$$</p><p>$$<br>K_1 = \cases{1, |e(j| \le A \ 0,|e(j)| &gt; A}<br>$$</p><p>其中，$K_1$为逻辑系数；$A$为积分分离阈值。</p><img src="/blog/2020/05/15/计算机控制系统/1563507093264.png" title="PD算法"><p>算法流程：</p><img src="/blog/2020/05/15/计算机控制系统/1563507337946.png" title="算法流程"><h3 id="带死区的数字PID控制算法"><a href="#带死区的数字PID控制算法" class="headerlink" title="带死区的数字PID控制算法"></a>带死区的数字PID控制算法</h3><p>被控变量达到工艺要求的精度，即系统的输出与输入之间的偏差达到要求的控制进度，偏差无限小，代价大；复杂的控制过程中有多个控制系统并存，各个被控变量之间可能存在一定的关联，过分追求一个指标，可能会影响其他指标，只需要达到设定指标即可。</p><img src="/blog/2020/05/15/计算机控制系统/1563507373962.png" title="带死区的数字PID控制算法"><p>死区算法为：<br>$$<br>e’(k) = \cases{e(k), |e(k| &gt;B \ 0,|e(k| \le B}<br>$$<br>有：<br>$$<br>\Delta u(k) =K_p[e’(k) - e’(k-1)] +K_ie’(k) +K_d[e’(k)-2e’(k-1)+e’(k-2)]<br>$$<br>带死区的位置式PID算法为：<br>$$<br>u(k) =u(k-1) +\Delta u(k)<br>$$<br>注意：由于PID控制器积分的<strong>保持作用</strong>，当$e’(k) = 0$时，PID控制器的输出保持$k-1$时刻的值的输出，而非零。</p><h3 id="不完全微分PID算法"><a href="#不完全微分PID算法" class="headerlink" title="不完全微分PID算法"></a>不完全微分PID算法</h3><p>PID控制算法中<strong>微分环节对改善系统超调量等动态性能具有重要作用，但是它对高频干扰信号比较敏感</strong>。</p><p>当控制器输入偏差信号突然变化时，PID控制器中的微分项将很大，持续时间又很短，产生<strong>微分失控</strong>现象。</p><img src="/blog/2020/05/15/计算机控制系统/1563508036395.png" title="不完全微分PID算法"><p>不完全微分PID控制算法中的微分作用持续很长时间，具有更好的抗干扰作用。</p><p>不完全微分PID控制算法增量形式为：<br>$$<br>\Delta u(k) = \alpha \Delta u(k-1) +(1-\alpha)\Delta u’(k)<br>$$<br>其中：<br>$$<br>\Delta u’(k) = K_p[e(k)-e(k-1)] +K_i e(k) +K_d [e(k) -2e(k-1)+e(k-2)]<br>$$</p><h3 id="微分先行PID控制算法"><a href="#微分先行PID控制算法" class="headerlink" title="微分先行PID控制算法"></a>微分先行PID控制算法</h3><p>在给定值频繁升降变换的场合，为了避免系统超调量过大甚至发生振荡，导致执行机构剧烈动作，需要对模拟PID控制器进行改进。</p><img src="/blog/2020/05/15/计算机控制系统/1563513446098.png" title="微分先行PID控制算法"><p>输出微分先行：只对输出微分，不对输入微分。适合给定值频繁升降的场合，可以避免给定值引起的超调量过大。</p><p>偏差微分先行：对给定值和输出量都有微分作用。适合串级控制的副控制回路。</p><h1 id="数字控制器离散化（直接）设计方法"><a href="#数字控制器离散化（直接）设计方法" class="headerlink" title="数字控制器离散化（直接）设计方法"></a>数字控制器离散化（直接）设计方法</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><strong>设计思路</strong>：将连续的控制对象及其零阶保持器用适当的方法离散化后，系统完全变成离散系统，因而可以用离散系统的设计方法直接在$z$域进行控制器的设计。</p><p>这种离散化的设计方法，稳定性好、精度高，一般用于可以精确建立对象的数学模型的情况。是在给定的采样周期下进行设计的，因此采样周期的选择取决于被控对象的特性，不受分析设计方法的限制。</p><img src="/blog/2020/05/15/计算机控制系统/1563514491951.png" title="数字控制器离散化设计方法"><p>闭环系统的脉冲传递函数为：<br>$$<br>W_B(z) = \frac{Y(z)}{R(z)} = \frac{D(z)W_d(z)}{1+D(z)W_d(z)} = \frac{W_K(z)}{1+W_K(z)}<br>$$<br>系统闭环的误差的脉冲传递函数为：<br>$$<br>W_e(z)=\frac{E(z)}{R(z)} = \frac{1}{1+D(z)W_d(z)}<br>$$</p><p>$$<br>W_B(z) = 1-W_e(z)<br>$$</p><p>得到控制器的脉冲传递函数为：<br>$$<br>D(z) = \frac{W_B(z)}{W_d(z)[1-W_B(z)]} = \frac{1-W_e(z)}{W_d(z)W_e(z)} = \frac{W_B(z)}{W_d(z)W_e(z)}<br>$$<br>若已知被控对象的脉冲传递函数$W_d(z)$，并根据性能指标要求确定出整个系统的闭环脉冲传递函数$W_B(z)$或闭环误差脉冲传递函数$W_e(z)$，则数字控制器$D(z)$可以唯一确定。</p><p><strong>数字控制器直接设计法的解析设计过程如下：</strong></p><ol><li>确定被控对象的传递函数模型，是算法设计的基础。直接设计法假定得到了被控对象的精确模型$W(s)$，将其连同前面的零阶保持器一起离散化后，得到被控对象的广义被控模型$W_d(z)$。</li><li>根据控制系统的性能指标要求及其它约束条件，确定出闭环系统的传递函数$W_B(z)$或$W_e(z)$，或者两者同时确定，满足约束条件$W_B(z) = 1-W_e(z)$。</li><li>根据上述$D(z)$计算公式确定控制器传递函数模型$D(z)$。</li><li>根据$D(z)$编制控制算法。</li></ol><p>直接设计方法的<strong>关键</strong>在于：闭环系统的脉冲传递函数$W_B(z)$（或者$W_e(z)$ ）的选择。要满足数字控制器物理可实现性、稳定性、准确性和快速性等方面的要求。</p><h2 id="最小拍控制器的设计方法"><a href="#最小拍控制器的设计方法" class="headerlink" title="最小拍控制器的设计方法"></a>最小拍控制器的设计方法</h2><p><strong>最小拍系统</strong>：最少调整时间系统或最快响应系统，是指系统对单位阶跃输入、单位速度输入或单位加速度输入等典型输入信号，具有最快的响应速度，经过最少个采样周期，使得输出的稳态误差为零，达到输出完全跟踪输入的目的。</p><p>根据以上原则来确定控制器$D(z)$的脉冲传递函数，即计算机控制算法 。</p><h2 id="最小拍控制器工程化改进"><a href="#最小拍控制器工程化改进" class="headerlink" title="最小拍控制器工程化改进"></a>最小拍控制器工程化改进</h2><p>最小拍控制系统存在不足之处：</p><ul><li>输出在采样点之间可能存在波纹</li><li>对各种典型输入函数的适应性差</li><li>对被控对象的模型参数变化敏感</li></ul><h2 id="大林算法"><a href="#大林算法" class="headerlink" title="大林算法"></a>大林算法</h2><p>最小拍控制设计方法，只适合一些计算机控制系统，对于<strong>系统输出的超调量有严格限制</strong>的系统并不理想。</p><p>对于一些纯滞后调节系统，滞后时间比较长，要求没有超调量或很少超调量，而调节时间允许在较多的采样周期内结束，<strong>超调</strong>是主要的设计指标。此时PID算法效果也欠佳。</p><p>大林（Dahlin）算法针对纯滞后的一阶和二阶惯性环节所提出的一种直接综合设计方法，具有良好的控制效果。</p><h3 id="算法设计原理"><a href="#算法设计原理" class="headerlink" title="算法设计原理"></a>算法设计原理</h3><p>设被控对象为带有纯滞后的一阶或二阶环节，即：<br>$$<br>W(s) = \frac{K}{T_1s+1}e^{-\tau s}, \tau = NT<br>$$</p><p>$$<br>W(s) = \frac{K}{(T_1s +1)(T_2s +1)}e^{-\tau s}，\tau = NT<br>$$</p><p>其中，$T_1,T_2$为对象时间常数；$\tau$为对象纯滞后时间，一般是采样周期的整数倍$NT$；$T$为采样周期。</p><p>大林算法的控制目标是：设计合适的数字控制器，使得整个闭环系统的传递函数为带有纯滞后的一阶惯性环节，且要求闭环系统的纯滞后时间等于对象的纯滞后时间，即：<br>$$<br>W_B(s) = \frac{e^{-\tau s}}{T_0s +1},\tau = NT<br>$$<br>其中，$T_0$为等效的闭环系统的时间常数。</p><h2 id="数字控制器程序实现"><a href="#数字控制器程序实现" class="headerlink" title="数字控制器程序实现"></a>数字控制器程序实现</h2><p>从$D(z)$算式的复杂性和控制系统的灵活性出发，采用计算机软件的方法实现更适宜。</p><p>包括直接程序设计、串联程序设计和并行程序设计。</p><h1 id="状态空间模型"><a href="#状态空间模型" class="headerlink" title="状态空间模型"></a>状态空间模型</h1><p>古典控制理论中，常采用线性微分方程和传递函数这两种输入输出的数学模型来描述线性定常动态系统。把系统看成一个“黑箱”来处理，不表征系统内部结构和内部变量，只反映外部变量即输入输出变量间的因果关系，称为<strong>外部描述</strong>。外部描述不能反映系统内部的某些特性。</p><p>现代控制理论中，采用<strong>状态空间</strong>描述，是一种<strong>内部描述</strong>的数学模型。用到外部变量和内部变量，由两个数学表达式组成，一个是反映系统内部状态的变量组$x_1,x_2,\dots,x_n$和输入变量组$u_1,u_2,\dots,u_p$之间因果关系的数学表达式。称为<strong>状态方程</strong>（微分方程或差分方程形式）。</p><p>另一个是表征系统内部状态的变量组$x_1,x_2,\dots,x_n$与输入变量组$u_1,u_2,\dots,u_p$和输出变量组$y_1,y_2,\dots,y_q$之间关系的数学表达式，称为<strong>输出方程</strong>。</p><h2 id="状态空间描述的基本定义"><a href="#状态空间描述的基本定义" class="headerlink" title="状态空间描述的基本定义"></a>状态空间描述的基本定义</h2><p><strong>状态</strong>：</p><p>控制系统的状态是指系统过去、现在和将来的状况。</p><p><strong>状态变量</strong>：</p><p>指能完全表征系统运动状态的最小一组变量。完全表征是指：</p><ol><li>任何时刻$t=t_0$，这组状态变量的值$x_1(t_0),\dots,x_n(t_0)$就表示系统在该时刻的状态。</li><li>当$t \ge t_0$时的输入$u(t)$给定，且上述初始状态确定时，状态变量能完全确定系统在$t \ge t_0$的行为。</li></ol><p>状态变量的最小性体现在：状态变量$x_1(t),\dots,x_n(t)$是为完全表征系统行为所必需最少个数的系统状态变量，减少状态变量个数会破坏表征的完整性，增加变量的个数是不需要的。</p><p><strong>状态向量</strong>：</p><p>若一个系统有$n$个彼此独立的状态变量$x_1(t),\dots,x_n(t)$，构成状态向量$\pmb X(t)$：<br>$$<br>\pmb X(t)=\begin{bmatrix}<br>x_1(t) \ x_2(t)\ \vdots \ x_n(t)<br>\end{bmatrix}<br>$$<br><strong>状态空间</strong>：</p><p>以状态变量$x_1(t),\dots,x_n(t)$为坐标轴构成的$n$维空间为状态空间。系统在任意时刻的状态，都可以用状态空间中的一个点来表示。</p><p>给定初始时刻$t_0$的状态$\pmb X(t_0)$，得到状态空间中的一个初始点，随着时间的推移，$\pmb X(t)$在状态空间中描绘出一条轨迹，称为<strong>状态轨迹</strong>。</p><p><strong>状态方程</strong>：</p><p>系统的状态变量与输入变量之间的关系用一组<strong>一阶微分方程来描述</strong>的数学模型称为状态方程。</p><p><strong>输出方程</strong>：</p><p>输出变量与状态变量、输入变量之间的关系的数学表达式</p><p><strong>状态空间表达式</strong>：</p><p>状态方程和输出方程组合，构成对一个系统动态行为的完整描述，称为状态空间表达式（或状态空间模型）。</p><h2 id="离散系统的状态空间模型"><a href="#离散系统的状态空间模型" class="headerlink" title="离散系统的状态空间模型"></a>离散系统的状态空间模型</h2><p>可以表示成：<br>$$<br>\cases{\pmb X(k+1) = F \pmb X(k) + G\pmb u(k) \ \pmb y(k) = C\pmb X(k) +D\pmb u(k)}<br>$$<br>其中，$\pmb X$为$n$维状态向量；$\pmb u$为$m$维控制向量；$\pmb y$为$p$维输出向量；$F(n\times n)$为离散系统状态转移矩阵；$G(n \times m)$为离散系统的输入矩阵或控制转移矩阵；$C(p \times n)$为状态输出矩阵；$D(p\times m)$为直接传输矩阵。</p><h2 id="系统的能控性和能观性"><a href="#系统的能控性和能观性" class="headerlink" title="系统的能控性和能观性"></a>系统的能控性和能观性</h2><p>对于一个控制系统，特别是多变量控制系统，有如下两个问题：</p><ol><li>在有限时间内，控制作用能否使系统从初始状态转移到要求的状态 【能控性问题】</li><li>在有限时间内，能否通过对系统输出的测定来估计系统的初始状态 【能观性问题】</li></ol><p>对于一个线性离散系统状态空间表示：<br>$$<br>\begin{equation}<br>\left\{<br>\begin{array}{lr}<br>       \pmb X(k+1) = F \pmb X(k) + G\pmb u(k) \ \pmb y(k) = C\pmb X(k)<br>\end{array}<br>\right.<br>\end{equation}<br>$$<br><strong>能控性定义</strong>：如果存在控制向量序列$\pmb u(k),\pmb u(k+1),\dots,\pmb u(N-1)$,使得系统从第$k$步的状态向量$\pmb X(k)$开始，在第$N$步达到零状态，即$\pmb X(N) =0$，其中$N$是大于$k$的有限数，称此系统在第$k$步上是能空的。</p><p>如果对于每个$k$值，系统的所有状态都是能控的，称系统状态是完全能控的，简称<strong>能控</strong>。</p><p><strong>能控性判据</strong>：完全能控的充要条件是矩阵$\pmatrix{G &amp; FG &amp; F^2G &amp; \dots &amp; F^{n-1}G}$的秩为$n$，该矩阵也称为系统的能控性矩阵，以$Q_c$表示，能控性判据为：<br>$$<br>rank Q_c = rank \begin{bmatrix}G &amp;FG &amp;F^2G &amp;\dots &amp; F^{n-1}G\end{bmatrix} = n<br>$$<br><strong>能观性定义</strong>：在已知输入变量$\pmb u(k)$的情况下，若能根据第$i$步及$n-1$步的输出观察值$\pmb y(i),\pmb y(i+1),\dots,\pmb y(i+n-1)$唯一能确定出第$i$步上的状态$\pmb X(i)$，称系统在第$i$步上是能观测的。</p><p>如果系统在任何$i$步上都是能观测的，称系统状态是完全能观测的，简称<strong>能观测</strong>。</p><p><strong>能观性判据</strong>：完全能观性的充要条件是矩阵$\pmatrix{G &amp; FG &amp; F^2G &amp; \dots &amp; F^{n-1}G}^T$的秩为$n$，该矩阵称为系统的能观性矩阵，以$Q_o$表示，能观性判据为：<br>$$<br>rankQ_o = rank<br>\left[<br>\begin{matrix}<br>C \ CF \ \vdots \ CF^{n-1}<br>\end{matrix}<br>\right]<br>=n<br>$$</p><h2 id="状态可测时按极点配置设计控制规律"><a href="#状态可测时按极点配置设计控制规律" class="headerlink" title="状态可测时按极点配置设计控制规律"></a>状态可测时按极点配置设计控制规律</h2><img src="/blog/2020/05/15/计算机控制系统/1563867748410.png" title="极点配置法"><p>系统的动态性能：完全取决于系统闭环传递函数的极点。</p><p><strong>极点配置法的基本思想</strong>：由系统性能要求确定闭环系统期望的极点位置，然后依据期望极点位置确定反馈增益矩阵。</p><p>极点配置设计的控制器包括两部分：一部分是<strong>状态观测器</strong>，根据所测量到的输出量$y(k)$重构出全部状态$\hat{x}(k)$；另一部分是<strong>控制规律</strong>，直接反馈重构的全部状态。</p><p>设控制对象的状态方程为：<br>$$<br>\mathbf x(k+1) = F\mathbf x(k) +G \mathbf u(k)<br>$$</p><p>其中$\pmb x \in R^n,\pmb u\in R^m$，控制规律为线性状态反馈，即：<br>$$<br>\pmb u(k) =-L \pmb x(k)<br>$$<br><strong>如何设计反馈控制规律$L$，使得闭环系统具有所需要的极点配置</strong>。</p><p>闭环系统的状态方程为：<br>$$<br>\pmb x(k+1) = (F-GL)\pmb x(k)<br>$$<br>闭环系统的特征方程为：<br>$$<br>|z I-F+GL|=0<br>$$<br>设所需要的闭环系统的极点为$\beta_i(i=1,2,\dots,n)$，得到闭环系统的特征方程为：<br>$$<br>\alpha_c(z) = (z-\beta_1)(z-\beta_2)\dots(z-\beta_n)= z^n +\alpha_1z^{n-1}+\dots + \alpha_n =0<br>$$<br>结合上面两个式子，可得到反馈控制$L$应满足的方程：<br>$$<br>|zI - F+GL| = \alpha_c(z)<br>$$<br>对于任意的极点配置，$L$具有唯一解的充要条件是控制对象完全能控，即：<br>$$<br>rank\begin{bmatrix}G &amp;FG&amp; \dots &amp; F^{n-1}G\end{bmatrix}=n<br>$$<br><strong>物理意义</strong>：只有当系统的所有状态都是能控的，才能通过适当的状态反馈控制使得闭环系统的极点配置到任意指定的位置上。</p><p><strong>关于解反馈控制$L$的方程方法有：</strong></p><p>1、首先根据相应连续的系统性能指标的要求来给定$s$平面中的极点，然后再根据$z_i = e^{s_i T}(i=1,2,\dots,n)$的关系来求得$z$平面的极点分布，其中$T$为采样周期。</p><p>2、如果将闭环系统的极点均配置在原点，即$\alpha_c(z) = z^n$，最后会得到最小拍控制。所有的状态在经过最多的$n$拍后变能回到零（平衡状态）。采用最小拍控制避免了给定闭环系统极点的困难。有一个缺点：当选取较小的采样周期时，要求很大的控制量。</p><p>3、直接方法，展开反馈控制$L$的方程的左边行列式，通过与已知的$\alpha_c(z)$比较系数得到$L$各个元素，此法对于低阶系统合适，对于高阶系统十分困难。</p><p>4、对控制对象的离散状态方程$\pmb x(k+1) = F\pmb x(k) + G \pmb u(k)$实行非奇异变换$\bar{\pmb x}(k) = P \pmb x(k)$，使得控制对象的状态方程变为能控标准型。具体如下：<br>$$<br>\bar{\pmb x}(k+1) = \bar{F}\bar{\pmb x}(k) + \bar{G}\pmb u(k)<br>$$<br>其中：<br>$$<br>\bar{F} = PFP^{-1} = \pmatrix{0 &amp; \dots &amp; \ \vdots &amp; I_{n-1}&amp; \ 0 &amp; &amp; \-a_n &amp;\dots &amp; -a_1},\bar{G} = PG = \pmatrix{0 \ \vdots \\0\\1}<br>$$<br>对于新的状态$\bar{\pmb x}(k)$，控制规律变为：<br>$$<br>\pmb u(k) = - \bar{L}\bar{\pmb x}(k)<br>$$<br>其中：<br>$$<br>\bar{L} = L P^{-1}<br>$$<br>这样有：<br>$$<br>\bar{\pmb x}(k+1) =(\bar{F} - \bar{G}\bar{L})\bar{\pmb x}(k) = H\bar{\pmb x}(k)<br>$$</p><p>$$<br>H= \pmatrix{0 &amp; \dots &amp; \ \vdots &amp; I_{n-1}&amp; \ 0 &amp; &amp; \-a_n &amp;\dots &amp; -a_1}-\pmatrix{0 \ \vdots \\0\\1}\pmatrix{\bar{L}_1 &amp; \dots &amp; \bar{L}_n } = \pmatrix{0 &amp; \dots &amp; \ \vdots &amp; I_{n-1}&amp; \ 0 &amp; &amp; \-(a_n+\bar{L}_1) &amp;\dots &amp; -(a_1+\bar{L}_n)}<br>$$</p><p>$H$为特征多项式的伴随矩阵形式，得到闭环系统的特征方程为：<br>$$<br>z^n + (a_1 + \bar{L}_n) z^{n-1} + \dots + (a_n+ \bar{L}_1)=0<br>$$<br>又因为：$\alpha_c(z) =  z^n +\alpha_1z^{n-1}+\dots + \alpha_n =0$，可得到：<br>$$<br>\bar{L}_1 = a_n-a_n,\dots,\bar{L}_n = a_1-a_1<br>$$<br>向量形式：<br>$$<br>\bar{L} = \pmatrix{a_n &amp;a_{n-1} &amp; \dots &amp; a_1} - \pmatrix{a_n &amp;a_{n-1} &amp; \dots &amp; a_1}<br>$$<br>可得到所需要的反馈系数矩阵为：<br>$$<br>L = \bar{L} P<br>$$<br>关键在于非奇异矩阵$P$的计算。</p><p>最后可得到：<br>$$<br>L = \pmatrix{0&amp; \dots 0 &amp;1} \pmatrix{G&amp;FG &amp; \dots &amp; F^{n-1}G}^{-1}\alpha_c(F)<br>$$<br>上式是利用极点胚子设计控制规律的实用算法，称为<strong>Ackermann公式</strong>。</p><h2 id="按极点配置设计观测器"><a href="#按极点配置设计观测器" class="headerlink" title="按极点配置设计观测器"></a>按极点配置设计观测器</h2><p>实际上，按极点配置设计控制规律时，所有的状态不能直接用于反馈。</p><p>常用的方法是：找到一个算法，能够根据所测量到的输出量重构出全部状态，记$\hat{\pmb x}(k)$为实际状态$\pmb x(k)$的重构或称为$\pmb x(k)$的估计。用$\pmb u(k) = -L\hat{\pmb x}(k)$代替实际状态的反馈。</p><p>这种能够根据输出量来重构系统状态的算法称为<strong>观测器</strong>。</p><h2 id="状态不可测时控制器的设计"><a href="#状态不可测时控制器的设计" class="headerlink" title="状态不可测时控制器的设计"></a>状态不可测时控制器的设计</h2><h3 id="分离性原理"><a href="#分离性原理" class="headerlink" title="分离性原理"></a>分离性原理</h3><p>闭环系统的$2n$个极点由两部分组成：一部分是按极点配置设计控制规律所给定的$n$个极点即<strong>控制极点</strong>。另一部分是按极点配置设计观测器给定的$n$个极点即<strong>观测极点</strong>。</p><p>根据分离性原理可以使得控制规律和观测器的设计分开设计，简化。</p><p>控制极点是根据系统的性能要求设计的，因此，闭环系统的性能应主要取决于控制极点，即<strong>控制极点应是整个闭环系统的主导极点</strong>。</p><p>观测器的引入，通常会使得系统的性能变差，为减少观测器极点的影响，观测器的极点所决定的状态重构的跟随速度应远远大于控制极点所决定的系统响应速度，极限状态下，观测器极点放置在原点，此时，状态重构具有最快的跟随速度。</p><h3 id="按极点配置控制器设计步骤"><a href="#按极点配置控制器设计步骤" class="headerlink" title="按极点配置控制器设计步骤"></a>按极点配置控制器设计步骤</h3><p>1、按对系统的性能要求给定$n$个控制极点</p><p>2、按极点配置设计出控制规律$L$</p><p>3、合适给定观测器的极点，对全阶观测器给定$n$个极点，对于降阶观测器给定$n-1$个极点。若测量不存在较大的误差或噪声，可考虑将所有的观测器极点放置在原点；反之，考虑按状态重构的跟随速度比控制极点所对应的系统响应速度快4-5倍的要求给定观测器的极点。</p><p>4、选择所采用的观测器类型。</p><p>​      若测量较准确，而且测量量便是其中一个状态，考虑选用降阶观测器，否则选用全阶观测器。若控制器的计算延时和采样周期的大小处于同一量级，可考虑采用预报观测器，否则考虑采用现时观测器。</p><p>5、根据给定的观测器极点及所选定的观测器类型计算增益矩阵$K$</p><p>6、根据所设计的控制规律及观测器由计算机加以实现。</p><h1 id="先进控制规律的设计方法"><a href="#先进控制规律的设计方法" class="headerlink" title="先进控制规律的设计方法"></a>先进控制规律的设计方法</h1><p>先进控制的任务是用来处理常规控制效果不好，甚至无法控制的复杂工业过程控制的问题。</p><p><strong>先进控制的主要特点</strong>是：</p><p>1、是一种基于模型的控制策略，可以是一种精确的数学模型，如最优控制。可以是一种不精确的模型，如自校正控制、模型预测控制，或者是基于知识的控制，如模糊控制。</p><p>2、通常用于处理复杂的多变量过程控制问题，如大时滞、多变量耦合、被控变量与控制变量存在各种约束等。</p><p>3、实现需要足够的计算能力作为支撑平台。</p><h2 id="线性二次型最优控制器设计"><a href="#线性二次型最优控制器设计" class="headerlink" title="线性二次型最优控制器设计"></a>线性二次型最优控制器设计</h2><p>极点配置法主要设计参数是闭环极点得位置，仅限于说明单输入单输出系统。</p><p>最优控制寻求一种最优控制策略，使某一性能指标最佳，这一性能指标常以对状态及控制作用得二次型积分<strong>（称为代价函数）</strong>表示。称为<strong>线性二次型LQ（linear quadratic）控制问题</strong>。</p><p>LQ控制是状态反馈，不仅能用于单输入单输出系统，同时也能用于多输入多输出及时变系统。</p><p>设线性时不变系统得离散状态方程为：<br>$$<br>\pmb x(k+1) = F\pmb x(k) + G\pmb u(k)<br>$$<br>初始条件是：$\pmb x(0) = \pmb x_0$；$\pmb x(k)$是$n$维状态向量；$\pmb u(k)$是$m$维控制向量；$F,G$分别是$n \times n,n\times m$系数矩阵。</p><p>给定二次型性能指标函数：<br>$$<br>J= \pmb x^T(N) Q_0 \pmb x(N)+ \sum\limits_{k=0}^{N-1}[\pmb x^T(k)Q_1\pmb x(k) + \pmb u^T(k) Q_2\pmb u(k)]<br>$$<br>其中，$Q_0,Q_1$是非负定对称阵，$Q_2$是正定对称阵。</p><p>要求确定控制序列$\pmb u(k)(k=0,1,\dots,N)$，使得$J$所示的性能指标函数极小，这样的控制序列$\pmb u(k)$为线性二次型控制问题的<strong>最优控制</strong>。$\pmb x(k)$为相应的<strong>最优轨迹</strong>，$J$为<strong>最优性能值</strong>。</p><p><strong>线性最优控制问题</strong>有：</p><p>1、有限时间最优问题，此时末时刻$N$固定且有限</p><p>2、无线时间最优问题，$N=\infty$</p><p><strong>线性二次型最优控制问题</strong>可分为：</p><p>1、调解问题。综合$\pmb u(k)$，使得系统由初始状态$\pmb x(0)$转移到平衡状态$\pmb x_e =0$，同时使得性能指标$J$极小，称为<strong>LQR(linear quadratic regular)问题</strong>。</p><p>2、跟踪问题。综合$\pmb u(k)$，使得系统输出$\pmb y(k)$跟踪某参考信号$\pmb y_r(k)$，同时使相应的二次型性能指标$J$极小。</p><h2 id="自校正控制器设计"><a href="#自校正控制器设计" class="headerlink" title="自校正控制器设计"></a>自校正控制器设计</h2><p>自适应控制器本身具有逐步减小系统不确定的能力，本身能不断地检测系统参数或运行指标，根据参数的变化或运行指标的变化，改变控制参数或改变控制作用，使得系统运行于最优或接近最优工作状态。</p><img src="/blog/2020/05/15/计算机控制系统/1563938622094.png" title="自校正控制器设计"><p>自校正<strong>基本思想</strong>：</p><p>将参数递推估计算法与对系统运行指标的要求结合起来，形成一个能自动校正控制器参数的实时计算机控制系统。</p><p>自校正<strong>组成部分</strong>：</p><p>1、参数估计器。根据对象的输入$u$和输出$y$的实测数据，用在线递推辨识方法，辨识被控对象的参数向量$\theta$和随机干扰的数学模型</p><p>2、控制器参数计算。按照辨识求得的参数向量估计值$\hat{\theta}$，计算控制器的参数</p><p>3、控制器。按照辨识求得的参数向量估计值$\hat{\theta}$和对系统运行指标的要求，随时调整调节器或控制器参数，给出最优控制$u$，使得系统适应于本身参数的变化和环境干扰的变化，处于最优工作状态。</p><p>设计自校正控制器<strong>主要问题</strong>：</p><p>用递推辨识算法辨识系统的参数，然后根据系统运行指标来确定控制器的参数。</p><p>在实际应用中，常以递推<strong>最小二乘法为参数估计方法</strong>，以<strong>最小方差为控制目标函数</strong>。</p><h3 id="最小二乘法参数辨识算法"><a href="#最小二乘法参数辨识算法" class="headerlink" title="最小二乘法参数辨识算法"></a>最小二乘法参数辨识算法</h3><p>==一次完成最小二乘法==</p><p>设被辨识的系统模型为：<br>$$<br>A(z^{-1})y(k) = B(z^{-1})u(k) + \xi(k)<br>$$<br>其中：<br>$$<br>A(z^{-1}) = 1+a_1 z^{-1} + \dots + a_n z^{-n}<br>$$</p><p>$$<br>B(z^{-1}) = b_0 + b_1 z^{-1} + \dots + b_m z^{-m}<br>$$</p><p>$z^{-1}$为时间向后平移算子，$y(k),u(k)$为系统的输出和输入，$\xi(k)$为不可测随机干扰，$n,m$为模型阶次。</p><p>上述模型是<strong>受控自回归积分滑动平均(CARIMA)模型中$C(z^{-1}) = 1$形式</strong>。</p><p>把待估计的模型参数和$k$时刻以前的观测数据记为向量形式，有：<br>$$<br>\pmb \theta = \begin{bmatrix} a_1,a_2, \dots ,a_n,b_0,b_1,\dots,b_m \end{bmatrix}^T<br>$$</p><p>$$<br>\varphi^T(k) = \begin{bmatrix} -y(k-1),\dots,-y(k-n),u(k),\dots,u(k-m)\end{bmatrix}<br>$$</p><p>辨识系统模型可写为：<br>$$<br>y(k) = \varphi^T(k) \pmb \theta + \xi(k)<br>$$<br>把$k=1,2,\dots,n,\dots,n+N$的全部数据代入可得到$N$个方程，矩阵形式表示为：<br>$$<br>\pmb Y_N = \pmb \Phi_N \pmb \theta +\pmb \xi_N<br>$$<br>其中：<br>$$<br>\pmb Y_N = \begin{bmatrix}y(n+1) \ y(n+2) \ \vdots \ y(n+N)\end{bmatrix}_{N\times 1} , \pmb \xi_N = \begin{bmatrix} \xi(n+1) \\\xi(n+2) \ \vdots \ \xi(n+N)\end{bmatrix}_{N\times 1}<br>$$<br>最小二乘法估计<strong>原理</strong>：从模型参数向量$\pmb \theta$中找到估计量$\hat{\pmb {\theta}}$，使得模型的输出与实际输出之间的<strong>误差的平方和最小</strong>。估计准则为：<br>$$<br>J= \sum\limits_{k=n+1}^{n+N}[y(k)- \varphi^T(k) \hat{\pmb{\theta}}]^2 =\pmb (Y_N - \pmb \Phi_N \pmb{\hat{ \theta}})^T (Y_N - \pmb \Phi_N \pmb{\hat{ \theta}})<br>$$<br>两边对$\pmb {\hat{\theta}}$求导，得到使得$J$最小的$\pmb {\hat{\theta}}$。可得：<br>$$<br>\pmb {\hat{\theta}} = (\pmb{\Phi_N^T} \pmb{\Phi_N})^{-1}\pmb{\Phi_N^T}\pmb Y_N<br>$$<br>若获得$k=1,2,\dots,n,\dots,n+N$的全部观测数据后，估计量$\pmb {\hat{\theta}}$一次计算出来，称为<strong>一次完成最小二乘算法</strong>。</p><p>==递推最小二乘算法==</p><p>一次完成最小二乘法需要存储全部观测数据，随着$N$增大，相应的计算量和存储空间将迅速增加。解决最小二乘法的在线辨识问题。</p><p>在进行$n+N$次观测后，又获得了一组新的观测数据$\{u(m+N+1),y(n+N+1)\}$,可构成$\pmb Y_{N+1},\pmb \Phi_{N+1}$，并计算出$\pmb {\hat{\theta}}_{N+1}$。</p><p>递推最小二乘法公式为：<br>$$<br>\cases{\pmb {\hat{\theta}}(k) = \pmb {\hat{\theta}}(k-1)+\pmb K(k)[y(k)- \varphi^T(k) \hat{\pmb{\theta}}(k-1)]\ \ \pmb K(k) = \pmb P(k-1)\varphi(k)[1+\varphi^T(k)\pmb P(k-1)\varphi(k)]^{-1}\ \ \pmb P(k) = [I-\pmb K(k)\varphi^T(k)]\pmb P(k-1)      }<br>$$<br>公式<strong>物理意义</strong>：</p><p>新的参数估计值$\pmb {\hat{\theta}}(k)$是由前一步的估计值$\pmb {\hat{\theta}}(k-1)$和修正项组成，修正项正比于新的观测数据$y(k)$与前一步模型预测量$\varphi^T(k)\pmb {\hat{\theta}}(k-1)$的偏差，$\pmb K(k)$为修正系数矩阵，$\pmb P(k)$正比于参数估计误差的方差，$\pmb P(k)$越大表示参数估计值越不准确，越小表示参数估计值越接近真值。</p><p>==带遗忘因子的递推最小二乘法==</p><p>当系统参数随时间变化时，新数据比老数据更能反映参数变化的状况，因此要使<strong>参数估计能够适应系统参数的时变特性</strong>，需要用指数加权的方法来逐渐削弱或“遗忘”老数据的影响。</p><p>带遗忘因子的最小二乘法公式为：<br>$$<br>\cases{\pmb {\hat{\theta}}(k) = \pmb {\hat{\theta}}(k-1)+\pmb K(k)[y(k)- \varphi^T(k) \hat{\pmb{\theta}}(k-1)]\ \ \pmb K(k) = \pmb P(k-1)\varphi(k)[\lambda+\varphi^T(k)\pmb P(k-1)\varphi(k)]^{-1}\ \ \pmb P(k) = \frac{1}{\lambda}[I-\pmb K(k)\varphi^T(k)]\pmb P(k-1)      }<br>$$<br>遗忘因子$\lambda$越小，表示遗忘越快，越重视当前数据，越能反映当前系统的变化，适用于参数变化速度相对于辨识速度较快的时变系统。</p><p>$\lambda$越大，重视更多的历史数据，得到更多的系统信息，辨识精度越高，适用于参数变化速度远低于辨识速度的慢时变系统。</p><p>==增广最小二乘递推算法==</p><p>被辨识的系统的模型为CARMA形式，且其$C(z^{-1} ) \ne 1$，即：<br>$$<br>A(z^{-1})y(k) = B(z^{-1})u(k) +C(z^{-1})\xi(k)<br>$$<br>其中：$C(z^{-1}) = 1+ c_1 z^{-1} + \dots + c_n z^{-n}$</p><p>$\xi{(k)}$是零均值白噪声序列，多项式$C(z^{-1})$各项系数未知，需要辨识。这类模型参数的辨识可采用增广最小二乘法来获得模型未知参数的估计。</p><p>增广最小二乘法递推算法公式为：<br>$$<br>\cases{\pmb {\hat{\theta}}(k) = \pmb {\hat{\theta}}(k-1)+\pmb K(k)[y(k)- \hat{\varphi}^T(k) \hat{\pmb{\theta}}(k-1)]\ \ \pmb K(k) = \pmb P(k-1)\hat{\varphi}(k)[1+\hat{\varphi}^T(k)\pmb P(k-1)\hat{\varphi}(k)]^{-1}\ \ \pmb P(k) = [I-\pmb K(k)\hat{\varphi}^T(k)]\pmb P(k-1)      }<br>$$<br>增广最小二乘法不仅能获得系统控制通道模型参数估计，还能获得噪声通道模型的参数估计，算法与最小二乘法基本相同，不同的只是参数向量$\pmb {\theta}$和数据向量$\varphi^T(k)$的维数扩充了，每次估计都需要计算一次噪声估计值$\hat{\xi}(k)$。</p><h3 id="自校正控制器设计-1"><a href="#自校正控制器设计-1" class="headerlink" title="自校正控制器设计"></a>自校正控制器设计</h3><p><strong>基本思想</strong>：</p><p>将参数估计递推算法与各种不同类型的控制算法相结合，以形成能自动校正控制器参数的实时计算机控制系统。</p><h2 id="模型预测控制器设计"><a href="#模型预测控制器设计" class="headerlink" title="模型预测控制器设计"></a>模型预测控制器设计</h2><p>模型预测控制（MPC）<strong>主要特征</strong>：</p><p>以预测模型为基础，采用二次在线滚动优化性能指标和反馈校正的策略，克服受控对象建模误差和结构、参数与环境等不确定因素的影响。</p><p><strong>研究现状</strong>：</p><p>预测控制开始与极点配置、自适应控制、鲁棒控制、精确线性化、解耦控制和非线性控制结合；</p><p>并且随着智能控制技术的发展，预测控制向着智能预测控制方向发展，如：模糊预测控制、神经网络预测控制、遗传算法预测控制以及自学习预测控制等；</p><p>将人工智能、大系统递阶原理等引入预测控制，构成多层智能预测控制的模式。</p><p><strong>核心</strong>：</p><p><strong>基于滚动时域原理，算法中包含了预测模型、滚动优化和反馈校正</strong>三个基本原理，即</p><p>1、在当前时刻，基于过程的动态模型，对未来某段时域内的过程输出序列做出预测，预测值是当前和未来控制作用的函数。</p><p>2、按照某个目标函数确定当前和未来控制作用大小，控制作用将使未来输出预测序列沿着某个参考轨迹“最优地”达到期望的输出设定值，但只实施当前控制量。</p><p>3、在下一时刻，根据最新实测数据对前一时刻的过程输出预测序列做出校正，并重复1，2。</p><img src="/blog/2020/05/15/计算机控制系统/1563951796173.png" title="模型预测控制器"><h3 id="预测模型"><a href="#预测模型" class="headerlink" title="预测模型"></a>预测模型</h3><p>是以对象的内部模型，即对象在脉冲或阶跃信号作用下的时间响应为基础，用以估计系统在输入序列作用下的输出。</p><h3 id="预测控制算法"><a href="#预测控制算法" class="headerlink" title="预测控制算法"></a>预测控制算法</h3><p>常用的主要是<strong>模型算法控制</strong>和<strong>动态矩阵控制</strong>两种。</p><p>==模型算法控制==（MAC）基本上包括四个部分：预测模型、反馈校正、参考轨迹和滚动优化。</p><p>==动态矩阵控制==（DMC）是一种基于对象阶跃响应的预测控制算法，适用于有时滞、开环渐近稳定的非最小相位系统。算法包括：预测模型、反馈校正和滚动优化。</p><h2 id="模糊控制器设计"><a href="#模糊控制器设计" class="headerlink" title="模糊控制器设计"></a>模糊控制器设计</h2><p>模糊控制器不要求掌握被控对象的精确数学模型，根据人的经验规则组织控制决策表，由该决策表决定控制量的大小。</p><h3 id="模糊数学"><a href="#模糊数学" class="headerlink" title="模糊数学"></a>模糊数学</h3><h3 id="模糊控制原理"><a href="#模糊控制原理" class="headerlink" title="模糊控制原理"></a>模糊控制原理</h3><p>核心部分是采用模糊控制器。</p><p>模糊控制器主要包括：输入量的模糊化接口、知识库、推理机和输出清晰化接口四个部分。</p><img src="/blog/2020/05/15/计算机控制系统/1563952613926.png" title="模糊控制器"><p>==模糊化==</p><p>仿照人的思维进行模糊控制，必须把输入通道采样得到的精确量变成模糊推理需要的模糊量，通过模糊化接口完成。</p><p>==知识库==</p><p>由数据库和规则库两部分组成。</p><p>数据库：模糊控制器而得输入变量、输出变量经模糊化处理后，其全部模糊子集的隶属度或隶属函数存放在模糊控制器的数据库中。</p><p>规则库：用来存放全部模糊控制规则，在推理时为“推理机”提供控制规则。</p><p>==推理机==</p><p>模糊控制器中，根据输入模糊量和知识库（数据库、规则库）完成模糊推理并求解模糊关系方程，从而获得模糊控制量的功能部分。</p><p>模糊控制规则是模糊决策，是人们在控制生产过程中的经验总结。</p><p>==清晰化接口==</p><p>被控对象每次只能接收一个精确的控制量，需要将模糊控制量转换成精确量，称为去模糊。方法有：最大隶属度方法、加权平均法和中位数判决法等。</p><h3 id="模糊PID控制器设计"><a href="#模糊PID控制器设计" class="headerlink" title="模糊PID控制器设计"></a>模糊PID控制器设计</h3><img src="/blog/2020/05/15/计算机控制系统/1563953080889.png" title="模糊PID控制器设计"><p>采用的是双模糊控制器（FC1、FC2）结构，$r,y$分别为系统的设定值和输出，$d$为外部扰动输入，$e$为设定值和输出的偏差，$\Delta e$为系统输出$y$的增量。</p><h1 id="网络控制系统-NCS"><a href="#网络控制系统-NCS" class="headerlink" title="网络控制系统(NCS)"></a>网络控制系统(NCS)</h1><p>网络控制在计算机控制系统的基础上，在控制器和被控对象之间加入通信网络（有线或无线网络），使得传感器到控制器的反馈通道信息传输和控制器到执行器的前向通道信息传输通过通信网络进行，实现对被控对象的计算机远程控制。</p><img src="/blog/2020/05/15/计算机控制系统/1563953558247.png" title="网络控制系统"><p>通信网络的不确定性和复杂性，相当于在控制器和控制对象之间增加了一个<strong>不确定的动态环节</strong>，$p_k^{sc}(·)$表示反馈通道的动态特性，$p_k^{ca}(·)$表示前向通道的动态特性。</p><p>反馈通道的信息$y(k)$经过网络传输到控制器变成$\bar{y}(k) = p_k^{sc}[y(k)]$；</p><p>前向通道的信息$u(k)$经过网络传输到执行器变成$\bar{u}(k) = p_k^{ca}[u(k)]$</p><p>网络的加入使得控制对象结构发生了变化，增加了通信接收器和通信发送器。</p><p><strong>通信接收器</strong>：包括通信网络接口和D/A转换器，作用于执行器</p><p><strong>通信发送器</strong>：包括A/D转换器和通信网络接口，变成数字信号，通过网络接口将数字信号打包发送到网络上。</p><p><strong>通信网络引入控制系统优劣</strong>：</p><p>连接智能现场设备和自动化系统，实现现场设备控制的分布化和网络化，具有信息资源共享、连接线数大大较少、易于扩展、易于维护、高效、可靠和灵活；</p><p>增加控制系统的复杂性，由于网络通信带宽、承载能力和服务能力的限制，使数据的传输不可避免存在时延、丢包、多包传输及抖动等诸多问题，导致系统性能下降甚至不稳定，给系统分析、设计带来很大的困难。</p><h2 id="网络控制系统概述"><a href="#网络控制系统概述" class="headerlink" title="网络控制系统概述"></a>网络控制系统概述</h2><p>传感器、控制器和执行器机构通过通信网络形成闭环控制系统。NCS中控制部件间通过共享通信网络进行信息（对象输出、参考输入和控制器输出等）交换。</p><img src="/blog/2020/05/15/计算机控制系统/1563954451180.png" title="网络控制系统结构 网络控制系统存在两种结构：直接结构和分层结构。 {% asset_img 1563954505257.png 网络控制系统结构分类"><p><strong>直接结构</strong>：控制信号封装在帧或报文中，通过网络发送到被控对象，被控对象传感器的测量数据同样以帧或数据包的形式通过网络发送到控制器。</p><p>典型应用包括远程学习实验室和直接电动机的速度控制等。</p><p><strong>分层结构</strong>：主控制器通过网络将计算好的参考信号发送到远程系统，远程系统根据参考信号来执行本地的闭环控制，并将传感器测量数据返回主控制器。</p><p>网络控制回路具有比本地控制回路更长的采样周期，典型应用包括移动机器人、遥控操作系统、汽车控制以及航天器等。</p><p><strong>对NCS评价的标准</strong>：网络服务质量（QoS）和系统控制性能（QoP）.</p><p>QoS：包括网络吞吐量、传输效率、误码率、时延可预测性和任务的可调度性</p><p>QoP：与常规控制系统一样，包括稳定性、快速性、准确性、超调和振荡等。</p><h2 id="网络控制系统的研究内容"><a href="#网络控制系统的研究内容" class="headerlink" title="网络控制系统的研究内容"></a>网络控制系统的研究内容</h2><p>包括对网络的控制(control of network)、通过网络的控制(control through network)和着眼于网络控制系统总体性能指标的综合控制(integrated control and network)。</p><p><strong>1、对网络的控制</strong></p><p>围绕网络的服务质量、从拓扑结构、任务调度算法和介质访问控制层协议等不同角度提出解决方案，满足系统对实时性的要求，减小网络时延、时序错乱、数据包丢失等一系列问题。</p><p>可以通过<strong>运筹学</strong>和<strong>控制理论</strong>的方法来实现。</p><p>包括：NCS体系结构和通信协议的研究、NCS时延分析和网络调度、NCS数据包的传送问题、NCS中带通信约束的控制问题、NCS的系统与信息的集成。</p><p><strong>2、通过网络的控制</strong></p><p>在现有的网络条件下，设计相适应的NCS控制器，保证NCS良好的控制性能和稳定性。</p><p>可以通过建立NCS数学模型并运用控制理论方法进行研究。</p><p><strong>NCS数学模型</strong>：</p><p>NCS中被控对象的连续工作状态方程为：<br>$$<br>\cases{\dot{\pmb x}(t) = A\pmb x(t) +B\pmb u(t-\tau) \ \ \pmb y(t) = C\pmb x(t)  }<br>$$<br>其中$\tau$为网络时延。</p><p>节点工作方式分为时间驱动和事件驱动两种，根据节点不同的工作方式，可以得到不同的系统离散事件模型。</p><p><strong>NCS的常规控制规律设计方法</strong>：</p><p>将NCS看成一个参数或时延时变系统，将常规的PID控制、Smith预估控制等，进行相应的改进，使之适应NCS控制性能的要求。</p><p><strong>NCS先进控制规律设计方法</strong>：</p><p>包括极点配置设计方法、最优化控制设计方法、鲁棒控制设计方法、智能控制设计方法等。<strong>基本思想</strong>：利用先进的控制律设计方法，设计网络控制系统的控制器，适应网络控制系统复杂特性的情况，进一步提高网络的控制性能。</p><p><strong>3、综合控制</strong></p><p><strong>协同考虑控制与调度</strong>：NCS闭环性能不仅依赖于控制算法的设计，还依赖于网络资源的调度，需要同时考虑网络协议和控制器的设计。</p><p><strong>NCS并行计算</strong>：存在大量费时的计算密集问题，并行计算需要多处理器协同工作和相互通信，NCS为并行计算提供必要的硬件环境。<strong>需要设计适合控制系统的并行算法</strong>。</p><h2 id="实时控制网络"><a href="#实时控制网络" class="headerlink" title="实时控制网络"></a>实时控制网络</h2><p>控制网络的实时性一般采用两种技术来实现：</p><p>1、<strong>简化技术</strong>。将网络形式简化成线型，将通信模型简化为只有物理层、数据链路层和应用层，将节点信息简化到只有几比特。</p><p>2、<strong>采用网络管理和数据链路调度技术</strong>。分时式实时系统的响应具有可预知性，但资源利用率低；抢先式实时系统资源利用率高，但响应具有不可预知性。很多控制网络将两者结合，达到某种平衡。</p><h3 id="控制网络的拓扑结构"><a href="#控制网络的拓扑结构" class="headerlink" title="控制网络的拓扑结构"></a>控制网络的拓扑结构</h3><p>网络拓扑指网络形状，物理上的连通性。以星型拓扑、总线拓扑、环型拓扑三种结构为基础。</p><blockquote><p><strong>拓扑</strong>：</p><p>把实体抽象为与其大小、形状无关的“点”，把连接实体的线路抽象为“线”，进而以图的形式来表示点与线之间的关系的方法。目的是在于研究这些点、线之间相连的关系。</p><p>表示点和线之间的关系的图称为<strong>拓扑结构</strong>图。</p><p><strong>几何结构</strong>：考察的是点、线之间的位置关系，强调的是点和线所构成的形状及大小。不同的几何结构可能具有相同的拓扑结构。</p><p><strong>网络拓扑结构</strong>：在计算机网络中，把计算机、终端、通信处理机等设备抽象成点，把连接这些设备的通信线路抽象成线，并将由这些点和线所构成的拓扑称为网络拓扑结构。</p><p>网络拓扑反映网络的结构关系。常见有总线型、星型、环型、树型和网状型等。</p><p><a href="https://blog.csdn.net/starshinning975/article/details/53511343" target="_blank" rel="noopener">参考博客</a></p></blockquote><img src="/blog/2020/05/15/计算机控制系统/1564017899902.png" title="控制网络的拓扑结构"> <p><strong>星型网络</strong>：各站点通过点到点的链路与中心站相连，数据的安全性和优先级容易控制，易实现网络监控，但中心节点的故障会引起整个网络瘫痪。</p><p><strong>总线型网络</strong>：所有站点共享一条数据通道，安装方便，成本低，但介质的故障会导致网络瘫痪，安全性低，监控困难。</p><p><strong>环型网络</strong>：各站点通过通信介质连成一个封闭的环型，容易安装和监控，但容量有限，网络建成以后，难以增加新的站点。</p><p><strong>树型拓扑</strong>：从总线拓扑演化而来，树根接收各站点发送的数据，然后广播发送到全网。</p><p><strong>网型拓扑</strong>：通信站点的互连结构</p><p><strong>混合拓扑</strong>：将两种或两种以上的单一拓扑结构混合起来，取两者的优点构成的拓扑。</p><h3 id="控制网络的协议模型"><a href="#控制网络的协议模型" class="headerlink" title="控制网络的协议模型"></a>控制网络的协议模型</h3><p>开放系统互连(OSI)参考模型共分为七层：物理层、数据链路层、网络层、传送层、会话层、表示层和应用层。</p><p>控制网络一般由OSI参考模型的物理层、数据链路层、应用层三层体系结构和通信媒质构成。</p><img src="/blog/2020/05/15/计算机控制系统/1564018591539.png" title="控制网络协议模型"><p>1、物理层。采用EIA-RS-232、EIA-RS-422/RS-485等协议。</p><p>2、数据链路层。考虑现场设备故障较多，更换频繁，数据链路层媒体访问控制多采用<strong>受控访问协议</strong>（包括轮询和令牌）协议，通常各PC、PLC作为主站，传感器、变送器等作为从站。需要支持点对点、点对多和广播通信方式。</p><p>3、应用层。解决应用怎样的高级语言（或过程控制语言）来作为面向用户的编程（或组态）语言，包括设备名称、网络变量与配置（捆绑）关系，参数与功能调用及相关说明，一般应具有符合IEC1131-3标准的图形用户界面（GUI）。</p><h3 id="控制网络的媒体访问技术"><a href="#控制网络的媒体访问技术" class="headerlink" title="控制网络的媒体访问技术"></a>控制网络的媒体访问技术</h3><p>媒体访问技术是挂在通信子网上的站点向通信介质存信息或者从通信介质上取信息的控制规则。</p><p>是对媒体的使用进行管理，将传输介质的频带有效地分配到网络上各个站点的方法，位于数据链路层中。</p><p>媒体访问控制是通信子网的核心内容，各个网络的性能在很大程度上取决于所采用的媒体访问控制方式，受其直接影响的性能有：网络的实时性、网络的吞吐量和有效利用等。</p><p><strong>媒体访问控制技术</strong>：</p><p>有冲突的媒体访问控制：在站点访问媒体时，可能会由于多个站点同时访问媒体而产生冲突，应用较多的协议：带有冲突检测的载波监听多路访问的CSMA/CD控制。   </p><p>无冲突的媒体访问控制：在网络上的站点访问传输媒体时，不会发生多个站点同时访问媒体的情况。应用较多的控制协议：<strong>令牌控制和主从控制</strong>。</p><h3 id="控制网络的类型"><a href="#控制网络的类型" class="headerlink" title="控制网络的类型"></a>控制网络的类型</h3><p>按<strong>通信方式</strong>分为：主从型、客户与服务器型、环型和通信型四种类型。</p><p><strong>主从型</strong>：通信由一个主站控制，主站轮询方式对子站“逐个”通信，简单，但危险集中，主站出问题，整个系统瘫痪。</p><p><strong>客户与服务器型</strong>：面向“事件”方式构建，无主站，有需要通信的“事件”发生，优先通信，即时响应好，是发展的主流方向。</p><p><strong>环型</strong>：所有的通信子站连成“一个环”，以数据移位的方式通信，简单有效，传输效率是目前控制网络最高的，但一个站出问题，通信中断。</p><p><strong>通信型</strong>：带有完整的OSI网络通信模型，是通信功能最强的控制网络。</p><p>按<strong>通信协议</strong>的特点分为：CSMA方式、TokenBus方式和主从Polling方式。</p><p><strong>CSMA方式</strong>：Ethernet、CAN、DeviceNet和LONWorks等</p><p><strong>TokenBus方式</strong>：Profibus、P-Net及ControlNet等</p><p><strong>主从Polling方式</strong>：FIP、CC-link以及某些专用的主从RS-422/RS-485网络</p><h3 id="EtherNet网络"><a href="#EtherNet网络" class="headerlink" title="EtherNet网络"></a>EtherNet网络</h3><p>采用的是有冲突的媒体访问控制方式的协议，工作过程是完全随机的，既不预先规定时间，也不预先建立每个节点传送信息的先后顺序，而是根据各个节点和传输线路的具体情况来确定。</p><p><strong>网络监听算法（CSMA）</strong>是CSMA/CD的核心，是一种“先听后讲”的算法，一个准备发送报文的站首先监听网络，以确定网络上是否有其他的站点在发送信号，即确定网络是否空闲。</p><p>1、非坚持的CSMA：网络空闲，则可以发送数据。如果网络忙，则等待由概率分布决定的、一定量的随机延迟时间，再监听网络的情况，即在这段随机延迟的时间内不监听网络。网络利用率低。</p><p>2、1-坚持CSMA：网络忙就一直监听，直到网络空闲，便立即发送数据。若有冲突，则等待一个随机时间间隔，重新监听。不可避免地有冲突发生，不利于网络吞吐量的提高。</p><p>3、P-坚持CSMA：网络忙，站点继续监听直到网络空闲，但发现网络空闲时，不立即发送数据，为减少冲突，以概率P发送数据，以概率（1-P）延迟一个时间单位，再监听网络。这个时间单位通常为网络上最大传播延迟的两倍，P值选择过大，增加冲突，P值过小，媒体利用率大大降低。</p><p>EtherNet网络作为最为广泛应用的网络协议，将成为过程级和控制级的主要传输技术。EtherNet能够与工厂信息管理系统进行直接地、无缝地连接，而不需要任何专用设备。</p><h3 id="CAN网络"><a href="#CAN网络" class="headerlink" title="CAN网络"></a>CAN网络</h3><p>CAN(controller area network)是串行总线控制器局域网络，与一般的通信网络相比，CAN的数据通信具有突出的可靠性、实时性和灵活性的特点。</p><img src="/blog/2020/05/15/计算机控制系统/1564022478527.png" title="CAN网络"><p>通过相应的CAN接口连接工业设备，构成低成本的网络。直接连接不仅<strong>提供了设备级故障诊断通通道</strong>，而且提高了通信效率和设备互换性。</p><p>CAN应用一种面向无损伤仲裁方法来解决媒体多路访问带来的冲突问题。<strong>仲裁过程</strong>是：</p><p>当网络空闲时，线路表现为“隐性”电平（recessive level），此时任何节点均可发送报文。发送节点发出的帧起始字段产生一个“显性”电平（dominant level），标志着发送开始。所有节点以首先开始发送节点的帧起始前沿来同步，若多个节点同时发送，在发送的仲裁场进行逐位比较。</p><blockquote><p><strong>网络仲裁</strong>：当网络多个节点同时发送 网络请求时，网络应如何做出选择，以保证网络最多只能被一个节点传送数据占据。</p></blockquote><p><strong>CAN仲裁原则</strong>：</p><p>（1）每个节点只能使用唯一的标识符发送数据</p><p>（2）对于任一标识符，只有具有相应标识符的节点发送带有此标识符的数据帧，而其他节点只能发送带有此标识符的远程帧</p><p>（3）不同的节点发送相同的标识符的远程帧时，必须由唯一确定的请求节点发送，或者不同的节点配以不同的<strong>DLC（数据帧长度）</strong>。</p><h3 id="ControlNet网络"><a href="#ControlNet网络" class="headerlink" title="ControlNet网络"></a>ControlNet网络</h3><p>是基于改型的CAN技术的一种高速确定性网络。作为一种高速串行通信系统和一种确定加预测的模式进行运作，适用于<strong>需要实时应用信息交换的设备之间的通信</strong>。</p><p>ControlNet网络是一种用于对信息传送有时间苛刻要求的、高速确定性网络，同时，它允许传送无时间苛求的报文数据。</p><p>ControlNet采用的令牌总线（TokenBus）控制方式。是最为普遍的无冲突介质访问控制协议。是将CSMA/CD和令牌环两种协议相结合，取其优点。</p><p>TokenBus只有取得<strong>令牌</strong>（一组具有特定格式的位）的站点才能发送数据帧，其他节点只能接收信息，或者被动地传送信息（在拥有令牌的节点的要求下发送信息）。发送完后，站点将令牌传递给下一个站点。</p><img src="/blog/2020/05/15/计算机控制系统/1564023588944.png" title="ControlNet网络"><p>在分布式主站系统中，ControlNet应用时间触发方式采取一个特殊的<strong>令牌传递机制</strong>：</p><p>网络上每个节点分配一个唯一的物理地址，持有令牌的节点可以发送数据，但是，网络上并没有真正的令牌在传输，而是每个节点监视收到的其数据帧的源节点地址，在该数据帧结束之后，每个节点设置一个隐性的令牌寄存器，其值为收到的物理地址+1，如果隐性令牌寄存器的值等于某个节点的物理地址，该节点发送数据。</p><p>网络中存在唯一的隐性令牌，在由主站构成的逻辑环中循环传递，主站之间通过一定的逻辑调度算法获得令牌的调度权，然后由它发起对其他主站或所属的从站的通信。</p><p><strong>令牌轮询技术</strong>：<br>通过任务调度来满足周期数据的不同实时性要求，既有静态的事先约定，也可以动态调整。优点是周期任务的实时性好且具有确定的或可预测的最大网络时延。<strong>主要缺点</strong>：无法处理突发事件。</p><p>ControlNet应用了<strong>数据分类</strong>技术解决这个问题：</p><p>（1）周期性数据：对应周期数据，按时传输，如数据采样</p><p>（2）事件性通信：对应突发数据，在事件发生时传输，如报警</p><p>（3）报文通信：对应非实时数据，被请求时传输，如程序下载</p><p>网络的媒体存储通过限制时间存储算法来控制，即：采用<strong>并行时间域多路存取（CTDMA）</strong>，控制各个节点在<strong>网络刷新时间（NUT）</strong>内传送信息的机会。</p><p>NUT包括三个部分：预先信息传送时间、非预定信息传送时间和网络维护时间。</p><p><strong>通信技术</strong>：<br>ControlNet采用的是多信道广播技术，如生产者/客户模式。这种通信模式是基于多信道广播的，允许网络上的所有节点，同时从单个数据源存储相同的数据。</p><p>在控制网链路上，由生产者发送的每个报文都包含一个连接标识符，已经组态的节点在收听广播时，可以识别其应收报文的连接标识符，变成一个客户以接收数据。</p><p>若该节点要发送信息，变成生产者，提高了网络的效率，特别是对组态信息等公共数据，多信道广播技术是一种有效的通信方式。</p><h3 id="CC-Link网络"><a href="#CC-Link网络" class="headerlink" title="CC-Link网络"></a>CC-Link网络</h3><p>是高速现场总线，不但处理信息数据，也处理控制数据。通过简单的总线，可以将工业设备连接成为分布式控制系统或设备层的网络，同时这个总线可以方便地连接到其他网络。</p><p>CC-Link采用<strong>单主从轮询工作模式</strong>，控制方式：网络的各节点间明显具有上下级特征，上级为主导节点，并由主导节点分配通信媒体的使用权，适用于自动化中的分布式系统，是一种集中控制，主要用于星型网络。</p><p>CC-Link<strong>数据链路层通信协议</strong>：EIA485协议</p><img src="/blog/2020/05/15/计算机控制系统/1564025332252.png" title="CC-Link网络"><h2 id="网络控制系统控制器的设计"><a href="#网络控制系统控制器的设计" class="headerlink" title="网络控制系统控制器的设计"></a>网络控制系统控制器的设计</h2><h3 id="PID网络控制器设计"><a href="#PID网络控制器设计" class="headerlink" title="PID网络控制器设计"></a>PID网络控制器设计</h3><p>理想的模拟PID控制器的传递函数为：<br>$$<br>D(s) = \frac{U(s)}{E(s)} = K_P +\frac{K_I}{s} + K_ds<br>$$<br>其中，$K_P$为比例系数，通过加大$K_P$的值来增加系统动态响应速度；$K_I$为积分系数，消除 系统稳态误差；$K_D$为微分系数，改变系统的动态性能。</p><p>采用双线性变换法，将上式离散化，得到：<br>$$<br>D(z) = D(s)|_{s=\frac{2}{h} ·\frac{1-z^{-1}}{1+z^{-1}}} = \frac{U(z)}{E(z)} = K_P +\frac{K_Ih}{2}·\frac{1-z^{-1}}{1+z^{-1}} +\frac{2K_D}{h}·\frac{1-z^{-1}}{1+z^{-1}}<br>$$<br>其中，$h$为采样周期。</p><p>常规PID控制器应用于网络控制系统的环境，由于网络特性的影响，PID控制器所控制的广义对象（包括网络和控制对象）实际上是一个<strong>时变系统</strong>，因此需要对PID参数$K_P,K_I,K_D$进行<strong>在线修正</strong>，以适应于网络控制系统的要求。</p><h3 id="极点配置网络控制器设计"><a href="#极点配置网络控制器设计" class="headerlink" title="极点配置网络控制器设计"></a>极点配置网络控制器设计</h3><p>在NCS中，首先建立系统的随机时变模型，然后对模型进行一系列的处理后设计控制器。控制器设计分为 <strong>控制规律的设计和状态观测器的设计</strong>。</p><p>根据给定的<strong>闭环系统的极点</strong>和<strong>观测器极点</strong>分别设计控制规律和观测器。</p><p>控制规律作用：根据系统的状态产生控制量。</p><p>观测器作用：利用带延迟的部分状态信息估计系统的全部状态。</p><p><strong>1、网络控制系统的模型分析</strong></p><p>通信网络的存在使得数据传输变得不确定，相当于在闭环中增加了时变的不确定的控制对象。闭环引入网络后，被控对象有了扩展，是包含<strong>直接控制对象和通信网络</strong>的广义被控对象。</p><p><strong>2、控制规律的设计</strong></p><p>假设控制器反馈的是系统的全部增广状态，控制规律为线性状态反馈，即：<br>$$<br>\pmb u(k) = -L^k \pmb z(k)<br>$$<br>目的是设计$L^k$使得闭环系统具有所需要的极点配置。</p><p><strong>3、状态观测器的设计</strong></p><p>实际控制中，控制器不能得到所有对象的状态，只能得到被控对象的输出，因此，在控制器中，要用被控对象的输出来重构出系统的所有的状态，这需要设计状态观测器。</p><p><strong>4、控制器的设计</strong></p><p>控制器包含观测器和控制规律，目的是设计$L^k$使得闭环系统取得好的性能指标。基于广义的被控对象的控制器的设计依然遵循<strong>分离性原理</strong>。</p><p>即闭环系统的极点由两部分组成，一部分是按照真实状态反馈设计控制规律的控制极点；另一部分是状态观测器的极点。</p><h1 id="计算机控制系统设计实现"><a href="#计算机控制系统设计实现" class="headerlink" title="计算机控制系统设计实现"></a>计算机控制系统设计实现</h1><h2 id="设计原则与设计方法"><a href="#设计原则与设计方法" class="headerlink" title="设计原则与设计方法"></a>设计原则与设计方法</h2><h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>总体上包括三个方面内容：计算机部分、执行机构与驱动技术、检测机构与传感器技术。</p><p><strong>常见的驱动技术</strong>：</p><p>采用电动机及其驱动器构成的电气传动系统直接驱动机械设备，在精度不高的情况下，一般采用通用型的传动系统，主要有：直流电气传动系统、交流电气传动系统、同步电动机传动系统等。</p><p>在高精度要求下，通常采用伺服驱动系统、直线电动机驱动系统等高精度传动系统。</p><p><strong>检测机构与传感器技术</strong>：</p><p>传感器：能够感受规定的被测量并按照一定规律转换成可用输出信号的器件和装置，通常由<strong>敏感元件和转换元件</strong>组成。</p><p>在计算机控制系统中，对检测机构与传感器基本要求：检测精度，检测机构的量程以及适用的环境等。</p><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p>包括监控软件、控制软件和信息管理软件三部分组成。</p><h3 id="数字控制器的实现问题"><a href="#数字控制器的实现问题" class="headerlink" title="数字控制器的实现问题"></a>数字控制器的实现问题</h3><p>数字控制器的设计是计算机控制系统设计的关键所在，包括数字控制器的理论设计与程序实现两部分。</p><p>数字控制器的理论设计：是根据被控对象和所确定的计算机控制系统的指标，设计出数字控制器的输入和输出函数的差分方程数学表达式。</p><h3 id="信号的数字滤波技术"><a href="#信号的数字滤波技术" class="headerlink" title="信号的数字滤波技术"></a>信号的数字滤波技术</h3><p>在模拟系统中，信号的处理是采用不同形式的有源或无源滤波器，如低通、高通、带通和带阻滤波器等。</p><p>在计算机控制系统中，采用数字滤波器，由软件编程实现。</p><p><strong>1、均值滤波</strong></p><p>在一个采样周期内，连续采样几个值，取其平均值为实际测量值。数学表达式为：<br>$$<br>Y = \frac{1}{N} \sum\limits_{i=1}^N X_i<br>$$<br>其中，$Y$是数字滤波器输出；$X_i$为第$i$次采样值；$N$为采样次数。</p><p>均值滤波实质是对信号的平滑处理，其平滑程度取决于采样次数$N$。$N$越大，计算结果越准确，但灵敏度降低，应折中处理。</p><p><strong>2、中值滤波</strong></p><p>连续采样三次$X_1,X_2,X_3$，去掉最大值和最小值，取中间值为本次采样值。数学表达式为：<br>如果$X_1 \le X_2 \le X_3$，则中值滤波器的输出为$Y = X_2$。</p><p>中值滤波对去掉脉动性的干扰比较有效，但不宜用于快速变化的变量的处理。</p><p><strong>3、抗干扰中值滤波</strong></p><p>消除脉冲型干扰信号。</p><p>连续采样$N$次，得到$X_1,X_2,\dots,X_N$，按数值由小到大额排列$X_1 \le X_2 \le \dots \le X_N$，去掉最小值$X_1$和最大值$X_N$，然后对剩余的采样值进行均值运算，结果作为滤波器的输出$Y$，计算公式为：<br>$$<br>Y = \frac{1}{N-2}\sum\limits_{i=2}^{N-1}X_i<br>$$<br><strong>4、限幅滤波</strong></p><p>大的随机干扰或者采样电路的不稳定，使得采样数据明显偏离实际值，或者两次采样之间的变化很大。</p><p>基本思路：根据被滤波信号的实际变化范围及变化的频率，确定滤波器的参数，即上下极限幅度$Y_h ,Y_l$及变化极限$\Delta Y_0$，对于一个采样值$x(k)$，滤波器的输出$y(k)$输出为：<br>$$<br>y(k) = \cases{x(k), \qquad Y_1 \le x(k) \le Y_h,|x(k)-y(k-1)|\le \Delta Y_0 \ \ y(k-1) + \Delta Y_0 ,\qquad  x(k) - y(k-1) &gt; \Delta Y_0 \ \ y(k-1) - \Delta Y_0 , \qquad x(k)-y(k-1) &lt; -\Delta Y_0 \ \ Y_h ,\qquad x(k) &gt; Y_h \ \ Y_1 , \qquad x(k) &lt; Y_1      }<br>$$<br>其中，滤波器参数$Y_h$和$Y_l$为被滤波信号的最大允许值和最小允许值，与被测信号的变换范围有关；$\Delta Y_0$与采样周期及被测信号的正常变化率有关。</p><p>限幅滤波器是针对特定的被测信号而设计的，加入了较多的人工干预成分，对参数选择有一定要求。</p><p><strong>5、惯性滤波</strong></p><p>是由连续域中的一阶惯性滤波器，经离散化处理后得到的。数学表达式为：<br>$$<br>y(k) = \alpha y(k-1) +(1-\alpha)y(k), \qquad 0&lt; \alpha &lt; 1<br>$$<br>滤波器当前时刻的输出值$y(k)$，是上次采样时刻的输出值$y(k-1)$与本次输入采样值$x(k)$的加权平均值，参数$\alpha$是$y(k-1)$的权，成为<strong>滤波系数</strong>。</p><p>$\alpha$越大，则表示上次滤波器的输出值在本次滤波器输出值中所占比重越大，即惯性越大。</p><h2 id="数字控制器程序实现性能分析"><a href="#数字控制器程序实现性能分析" class="headerlink" title="数字控制器程序实现性能分析"></a>数字控制器程序实现性能分析</h2><p>计算机控制系统数值误差的来源：</p><p>1、建立控制器离散数学模型时，需对其参数进行量化，因而会产生参数量化误差。</p><p>2、在信号转换过程中，由于A/D转换器的数字量字长有限，同时，受A/D转换时间和采样周期的影响，因此会在检测的反馈信号中产生采样量化误差。</p><p>3、因计算机控制系统的实时性要求，在计算机编程中所采用的数字量的字长也是有限的，会产生计算误差。</p><h2 id="量化效应与采样周期误差分析"><a href="#量化效应与采样周期误差分析" class="headerlink" title="量化效应与采样周期误差分析"></a>量化效应与采样周期误差分析</h2><h3 id="A-D转换的量化误差"><a href="#A-D转换的量化误差" class="headerlink" title="A/D转换的量化误差"></a>A/D转换的量化误差</h3><p>是在一定范围内变化的随机变量，通常所称的量化误差是相应变化范围的最大值，假定A/D转换器对输入模拟信号的转换量程为$0-X_m$，转换字长为$n$，量化误差为：<br>$$<br>q = \frac{X_m}{2^n}<br>$$</p><h3 id="孔径误差"><a href="#孔径误差" class="headerlink" title="孔径误差"></a>孔径误差</h3><p>设$T$为采样周期，$T_c$为A/D转换器的转换时间，假定$T\ge T_c$。只在$T_c$时间内观察到输入信号$x(t)$的变化，相当于一个时间窗口，$T_c$称为$A/D$转换器的孔径时间。</p><img src="/blog/2020/05/15/计算机控制系统/1564040994361.png" title="孔径误差"><p>A/D转换器的孔径时间对于变化的信号在转换过程中会形成一定的误差，若被转换的模拟信号不是一个恒定常量，而是随时间变化形成了连续时间函数$y(t)$，则在有一定的孔径时间$T_c$的情况下，A/D转换器将产生孔径误差。</p><p>最终的A/D转换的采样值为：<br>$$<br>y(t_2) = y(t_1) + \Delta y<br>$$<br>其中$\Delta y$为孔径误差，可以表示为：<br>$$<br>\Delta y = T_c \frac{dy}{dt}<br>$$<br>其中$T_c = t_2-t_1$。</p><p>若孔径误差过大，可通过选用转换速度更高的A/D转换器或者A/D之前加<strong>采样保持器</strong>来解决。</p><h3 id="采样周期造成的误差"><a href="#采样周期造成的误差" class="headerlink" title="采样周期造成的误差"></a>采样周期造成的误差</h3><p>一般采样周期$T$远大于A/D转换器的孔径时间$T_c$，对变换的模拟信号的影响远超A/D转换器的孔径时间的影响。</p><p>设被转换的模拟信号为正弦函数$x(t) = X_{max} \sin(\omega t + \theta_0)$，信号周期为$T_0 = \frac{2\pi}{\omega}$，采样周期为$T$时，$x(t)$的实际采样函数为：<br>$$<br>x^<em>(t) = X_{max} \sin (\omega kT + \theta_0), \quad kT \le t &lt; kT +T<br>$$<br>设$\frac{T_0}{T} =m$，$m$为自然数，$x^</em>(t)$是周期为$T_0$的周期函数，可表示为如下三角函数形式的傅里叶级数表达式：<br>$$<br>\cases{x^<em>(t) = a_0 \sum\limits_{n=1}^{\infty} [a_n \cos(n\omega t) + b_n \sin(n\omega t)]\ \ a_0 = \frac{1}{T_0} \int_{t-T_0}^{t}x^</em>(t) dt \ \ a_n = \frac{2}{T_0}\int_{t-T_0}^t x^<em>(t) \cos (n\omega t) dt \ \ b_n = \frac{2}{T_0} \int_{t-T_0}^t x^</em>(t) \sin (n\omega t)dt    }<br>$$<br>采样前的模拟信号只有基波分量，分析采样前后的误差情况，实际上就是将实际采样函数$x^*(t)$的基波信号的幅值相位与模拟信号相比较，只需要求出基波的系数$a_1$和$b_1$。<br>$$<br>a_1 = \frac{2X_{max}}{T_0} \sum\limits_{i=k-m}^{k-1} \int_{iT}^{(i+1)T} \sin (\omega iT+ \theta_0) \cos(\omega t)dt \ = -\frac{mX_{max}}{\pi} \sin(\frac{\pi}{m}) \sin (\frac{\pi}{m} -\theta_0) +A<br>$$<br>其中，$A = \frac{X_{max}}{\pi} \sin (\frac{\pi}{m}) \sum\limits_{i=k-m}^{k-1} \sin \left(\frac{4\pi}{m} i + \theta_0 + \frac{\pi}{m}\right)$。<br>$$<br>b_1 = \frac{2X_{max}}{T_0} \sum\limits_{i=k-m}^{k-1} \int_{iT}^{(i+1)T} \sin (\omega iT+ \theta_0) \sin(\omega t)dt \ = \frac{mX_{max}}{\pi} \sin(\frac{\pi}{m}) \cos (\frac{\pi}{m} -\theta_0) +B<br>$$<br>其中，$B = -\frac{X_{max}}{\pi} \sin (\frac{\pi}{m}) \sum\limits_{i=k-m}^{k-1} \cos \left(\frac{4\pi}{m} i + \theta_0 + \frac{\pi}{m}\right)$。</p><p>可得到实际采样函数的基波$x^<em>_1(t)$的幅值和相位，表达式为：<br>$$<br>x^</em>_1(t) = \sqrt{a_1^2 + b_1^2} \sin (\omega t + \theta_1)<br>$$<br>其中，$\theta_1 = \arctan(a_1/b_1)$。</p><p>与原函数相比，幅值误差为：<br>$$<br>\Delta X = X_{max} - \sqrt{a^2 + b^2}<br>$$<br>相位误差为：<br>$$<br>\Delta \theta = \theta_0 - \theta_1<br>$$</p><h2 id="计算机控制系统可靠性"><a href="#计算机控制系统可靠性" class="headerlink" title="计算机控制系统可靠性"></a>计算机控制系统可靠性</h2><p>提高可靠性的<strong>设计原则</strong>：</p><p>1、保证系统的硬件和软件自身质量，降低自身损坏和冲突的概率</p><p>2、提高硬件和软件对外部信号的抗干扰、扛冲击能力</p><p>3、系统的硬件和软件要有<strong>冗余设计和备份</strong></p><p>4、硬件和软件设计要使系统有<strong>故障诊断能力</strong>，将事故危害范围降到最低限度。</p><p><strong>软件部分的措施</strong>：</p><p>1、采用模块化设计。对系统及软件功能的分析和研究，合理地进行软件的模块划分，并明确每个模块所要完成的功能及与其他模块的调用和被调用关系。</p><p>2、充分测试，避免软件的自身冲突。</p><p>3、对输入信号的抗干扰设计。软件中设计滤波器，抑制和消除干扰的影响</p><p>4、系统的软件应具有一定的<strong>故障诊断能力和自修复能力</strong>。</p><p>5、看门狗技术。是一种CPU监控定时器，看门狗的运行靠硬件和相应软件的配合实现。<strong>工作机理</strong>：</p><p>​       在一个预先设定的时间内，若没有得到来自CPU的清零脉冲信号，则看门狗定时器将向CPU的复位端输出一个复位脉冲信号，这样可以使得因故障而导致程序陷入死循环的计算机系统重新从头开始工作。</p><h2 id="消除或抑制干扰影响的方法"><a href="#消除或抑制干扰影响的方法" class="headerlink" title="消除或抑制干扰影响的方法"></a>消除或抑制干扰影响的方法</h2><h1 id="伺服运动控制系统"><a href="#伺服运动控制系统" class="headerlink" title="伺服运动控制系统"></a>伺服运动控制系统</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>伺服系统是可以<strong>按照一定的指令控制电动机执行规定的运行动作</strong>，一般由伺服电动机、传感器和控制器三部分构成闭环，完成精密控制。</p><p>伺服系统的<strong>基本要求</strong>：稳定性好、精度高，一般在0.001-0.01mm之间、快速响应性好，一般在200ms以内，甚至小于几十毫秒。</p><p>伺服系统对控制系统要求可分为如下几种形式：</p><p>1、点位运动控制。仅对终点位置有要求，与运动的中间过程（运动轨迹无关）。</p><p>2、连续轨迹（轮廓控制）运动控制。主要应用在数控系统、切割系统的运动轮廓控制中。</p><p>3、同步运动控制。多个轴之间的运动协调控制，可以是多个轴在运动全程中进行同步，也可以是在运动过程中的局部速度同步。</p><p>伺服系统<strong>主要特点</strong>：精确的检测装置、多种反馈比较原理和方法、高性能伺服电机、宽调速范围的速度调节系统、靠偏差工作。</p><img src="/blog/2020/05/15/计算机控制系统/1564043367055.png"><img src="/blog/2020/05/15/计算机控制系统/1564043379505.png"><p>伺服系统一般由电流环、速度环和位置环组成，其中电流环采用矢量控制，速度环和位置环采用PID控制。</p><img src="/blog/2020/05/15/计算机控制系统/1564043445173.png" title="伺服控制系统">]]></content>
    
    <summary type="html">
    
      计算机控制系统原理简介，包括PID，DCS等
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>信号处理涉及的几种变换</title>
    <link href="https://jiangxj.top/blog/2020/05/14/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%98%E6%8D%A2/"/>
    <id>https://jiangxj.top/blog/2020/05/14/信号处理涉及到的几种变换/</id>
    <published>2020-05-13T16:00:00.000Z</published>
    <updated>2020-06-18T02:42:24.492Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小波可以进行伸缩平移，源自傅里叶变换，都是频率变换的方法。</p><blockquote><p>傅里叶变换、短时傅里叶变换、小波变换</p><p>内积，基，归一化正交，投影，Hilbert空间，多分辨率，父小波，母小波</p></blockquote><p>==1、基==</p><p>傅里叶变换的基是不同频率的正弦曲线，把信号波分解成不同频率的正弦波的叠加和。</p><p>小波变换把信号分解成一系列的小波，小波种类多，同一种小波可以进行尺度变换，<strong>小波的特性是在整个时间范围内幅度的平均值是0，具有有限的持续时间和突变的频率和振幅，可以是不规则，不对称的</strong>。正弦波不是小波。</p><p><strong>基的特性是</strong>：</p><ul><li><p>非冗余性</p></li><li><p>完备性：即使基不是正交的，有相关性，若去掉其中一个，不成为基，</p></li><li><p>唯一性：给定一族基对一个函数的表达是唯一的</p></li><li><p>非正交性：一般情况下是非正交的，称为exact frame（resize basis），此时要表示信号可以将基正交化成唯一的正交基（对偶为其自身）；也可以求其对偶框架（dual frame），其对应了小波变换的双正交情形，信号可以依框架进行分解，然后用对偶框架重构。</p></li></ul><p><strong>框架</strong>：</p><p>在基集中添加一些新的向量，并随意调整空间位置，可能成为框架。把函数与基或框架作内积（函数空间到系数空间的变换），若变换后的能量（内积的平方和度量）仍然有一个大于0的上下界，才可以成为框架。</p><p>框架具有冗余性，系数的表达不具有唯一性。</p><p>若上下界相等，则为紧框架，且界表示冗余度；</p><p>若上下界相等且为1，成为pasval identity frame，此时不一定为正交基（相当于把一组正交基中的某一个拆成两个同方向的基之和，pasval identity 仍然成立），此时若再加上基的长度均为1的条件，则框架退化为正交基。</p><p>很多信号表示方法不能构成基，但能构成框架，如短时傅里叶变换中如要求窗函数满足基条件，则可推出函数具有很差的时频局部化性质（退化为傅里叶变换）。</p><p>==2、内积==</p><p>在Hilbert空间中，用来刻画两个向量的夹角，当内积为0时，两个向量正交。</p><p>若$g$为Hilbert空间里的正交基，内积为$f$向基上的正交投影，有如下推导：<br>$$<br>f·g = f^Tg= = \int f(t) \bar{g(t)}dt = f_1g_1 +f_2g_2 = |f||g|cos \theta<br>$$<br>如果两个向量内积为0，即正交；如果一个向量序列相互对偶正交，并且长度为1，是正交归一化。</p><p>对于$f(t) \in L^2(R)$（平方可积），存在$L^2(R)$上的一组标准正交基$g_i(t),i=1,2,\dots,$，使得：<br>$$<br>f(t) = \sum\limits_{i=1}^{\infty}f_ig_i(t)<br>$$<br>$L^2(R)$上任意一个函数$f(t)$都可以由$L^2(R)$的一个规范正交基$g_i(t)$进行线性组合表示出来。</p><p>==3、傅里叶变换==</p><p><strong>Fourier分析不能刻画时间域上信号的局部特性</strong></p><p><strong>Fourier分析对突变和非平稳信号的效果不好，没有时频分析</strong></p><p>傅里叶变换将函数投影到三角波上，将函数分解为不同频率的三角波，对于平稳信号的表示，近似最优表示。但是日常信号不是一直光滑的，而且奇异是非凡的，傅里叶在奇异点的表现不是很好，用大量的不同频率的三角波去逼近其系数衰减程度相当缓慢，而且会产生<strong>Gibbs效应</strong>。（内在原因是其基为全局性基，没有局部化能力，以致于局部一个小小的摆动会影响全局的系数，实际应用中很需要时频局部化，傅里叶缺乏此能力）。</p><p>对于非平稳信号，只知道包含哪些频率成分不够，还需要知道各个成分出现的时间。知道信号频率随时间变化的情况，各个时刻的<strong>瞬时频率</strong>及其值——<strong>时频分析</strong>。</p><blockquote><p><strong>瞬时频率</strong>：绝对意义上的瞬时频率是不存在的，单看一个时刻点的一个信号值，得不到它的频率，可以用很短的一段信号的频率作为该时刻的频率，得到的是时间分辨率有限的近似分析结果（SIFT）。小波等时频分析方法，用如衰减的基函数去测定信号的瞬时频率，思想类似。</p></blockquote><p>==4、短时傅里叶变换(SIFT)==</p><p>SIFT针对于傅里叶变换的时域太长而改进，也称为加窗傅里叶变换，这样有了局部化能力。</p><p><strong>SIFT定义</strong>：把整个时域过程分解为无数个等长的小过程，每个小过程近似平稳，再傅里叶变换，这样可以知道在哪个时间点上出现了什么频率了。即在时域上分成一段一段做FFT。</p><p><strong>窗的大小的影响</strong>：窗太窄，窗内信号太短，会导致频率分析不够精准，频率分辨率差；窗太宽，时域上不够精细，时间分辨率低。</p><blockquote><p>用<strong>海森堡不确定性原理</strong>解释：类似不能同时获取一个粒子的动量和位置，依次，也不能同时获取信号绝对精准的时刻和频率，是一对不可兼得的矛盾体。不知道在某个瞬间哪个频率分量存在，只知道在一个时间段内某个频带的分量存在，所以绝对意义的瞬时频率是不存在的。</p><p>很多物理量有这样的特征，比如能量和时间、角动量和角度。信号领域就是时域和频域，更为准确的描述是：一个信号不能在时空域和频域上同时过于集中，一个函数时域越“窄”，经傅里叶变换后的频域就越“宽”。</p></blockquote><p>对于时变的非稳态信号，高频适合小窗口，低频适合大窗口，SIFT的窗是固定的，在一次的SIFT中宽度不会变化，所以<strong>SIFT无法满足非稳态信号变化的频率的需求</strong>。</p><p>==5、小波变换==</p><p>小波是基于加窗傅里叶变换的窗口大小改变的思想，但是，SIFT是给信号加窗，分段做FFT；小波变换并没有采用的窗的思想，也没有做傅里叶变换，小波直接将傅里叶变换的基更换——<strong>将无限长的三角函数基换成了有限长的会衰减的小波基，这样获得频率，也可以定位到时间</strong>。</p><blockquote><p><strong>基函数</strong>：会伸缩、会平移（是两个正交基的分解）。缩得窄，对应高频；伸得宽，对应低频。基函数不断和信号做相乘。某一个尺度（宽窄）下乘得结果，可以看成信号所包含得当前尺度对应频率成分有多少。</p><p>基函数会在某些尺度下，与信号相乘得到一个很大的值，这样就知道信号包含该频率的成分的多少。小波的改变将无限长的三角函数基换成了有限长的会衰减的小波基。</p></blockquote><p><strong>小波公式</strong>：<br>$$<br>WT(a,\tau)= \frac{1}{\sqrt{a}}\int_{-\infty}^{\infty}f(t)*\psi(\frac{t-\tau}{a})dt<br>$$</p><img src="/blog/2020/05/14/信号处理涉及到的几种变换/20160705113512598.png" title="小波变换"><p>变量只有频率$w$，小波变换只有两个变量：尺度$a$（scale）和平移量$\tau$（translation）。尺度$a$控制小波函数的伸缩，平移量$\tau$控制小波函数的平移。尺度对应于频率（反比），平移量$\tau$对应于时间。</p><img src="/blog/2020/05/14/信号处理涉及到的几种变换/20160705113633849.png" title="平移-伸缩"><p>当伸缩、平移到上面这一种重合情况时，也会相乘得到一个大的值，与傅里叶不同的是，这不仅知道信号有这样频率的成分，而且知道在时域上存在的具体的位置。【解决局部性问题】当在每个尺度下都平移着和信号都乘过一遍后，能够知道在每个位置都包含哪些频率成分，这样可以做时频分析。【解决时频分析问题】</p><p>具体的还有<strong>子空间、多分辨率、母小波的变换，如何构造想要的小波函数，离散小波变换、正交小波变换、二维小波变换、小波包的应用</strong>。</p><p>每一个小波有一个mother wavelet，同时还有一个father wavelet，即scaling function。而小波的basis函数是对这个母小波和父小波的缩放和平移形成的，缩放倍数都是2的级数，平移大小与当前缩放的程度有关。</p><p>不同的母小波，衍生的小波基完全不同，<strong>小波展开的近似形式</strong>为：<br>$$<br>f(t) = \sum\limits_k \sum\limits_{j}a_{j,k}\psi_{j,k}(t)<br>$$<br>即小波级数，这些级数组合形成了小波变换中的基basis。与傅里叶级数不同的是，小波级数通常是orthonormal basis（规范化正交基），即不仅两两正交，还归一化的。</p><p>小波变换的<strong>三个特点</strong>：小波级数是二维的，能定位时域和频域，计算很快。</p><p><strong>小波的完整形式</strong>：</p><p>小波basis的形成，是基于基本的小波函数，即母小波来做缩放和平移的，母小波并非唯一的原始基，在构建小波基函数的集合时，通常用到一个尺度函数scaling function 。即成为父小波，两者都是归一化的，并且满足一个性质，它和对自己本身周期平移函数两两正交：<br>$$<br>f(t) = \sum\limits_k \sum\limits_{j}a_{j,k}\psi_{j,k}(t)<br>$$</p><p>$$<br>&lt;\varphi(t),\varphi(t-kT)&gt; = 0 ,\forall k<br>$$</p><p>完整的小波展开由父小波和母小波共同定义的：<br>$$<br>f(t) = \sum\limits_{k=-\infty}^{\infty}c_k\varphi(t-k)+\sum\limits_{k=-\infty}^{\infty}\sum\limits_{j=0}^{\infty}d_{j,k}\psi(2^jt-k)<br>$$<br>其中$\psi(t)$是母小波，$\varphi(t)$是父小波。</p><p><strong>小波的一些优势：</strong></p><p>对于突变信号，傅里叶变换存在吉布斯效应，用无限长的三角函数拟合不好突变信号，使用衰减的小波，只有小波函数和信号突变处重叠时，系数不为0.</p><p>小波可以实现<strong>正交化</strong>，短时傅里叶变换不能。采用正交基，变换域的系数会没有冗余信息，等于是用最少的数据表达最大的信息量，有利于数值压缩等领域。但是比如在图像增强领域，有时候反而希望能有一些冗余信息，更有利于对噪声的抑制和对某些特征的增强。</p><p><strong>小波变换的缺点</strong>：</p><p>作为图像处理方法，【和多尺度几何分析方法（超小波）比较】：对于图像这种二维信号，二维小波只能沿着2个方向进行，对图像中点的信息表达还可以，但是对线的信息表达比较差。此时ridgelet(脊波)、curvelet(曲波)等多尺度几何分析方法更有优势。</p><p>作为时频分析方法，【和HHT比】：小波变换没能脱离海森堡测不准原理的束缚，某种尺度下，不能在时间和频率上同时具有很高的精度，此外小波是非适应性的，基函数选定后不再修改。</p><p>==5、S变换==</p><p>S-transform可以看成是小波变换和SIFT的继承和法阵，傅里叶变换只能作用于收敛信号，SIFT的窗函数不可变，小波变换虽然窗函数可变，能进行多分辨率分析，但是其基函数选取困难。ST介于两者之间，<strong>可以自适应调节分辨率且其逆变换无损可逆</strong>。</p><p>ST是由地球物理学家Stockwell在1996年提出的一种时频分析方法，定义为：<br>$$<br>S(\tau,f)= \int_{-\infty}^{\infty}h(t)\frac{|f|}{\sqrt{2\pi}}e^{-\frac{(\tau-t)^2f^2}{2}}e^{-i2\pi ft}dt<br>$$<br>其中：$\tau$为时间，控制窗口函数在时间轴上的位置；$h(t)$为分析信号；$f$为频率；$S(\tau,f)$为变换得到的时频谱矩阵。</p><p>ST可以写成傅里叶频谱$H(f)$的形式：<br>$$<br>S(\tau,f) = \int_{-\infty}^{\infty}H(\alpha+f)e^{-\frac{2\pi^2 \alpha^2}{f^2}}e^{i2\pi \alpha \tau}d\alpha,(f \ne 0)<br>$$</p><p>对于离散信号，有：<br>$$<br>H\left[\frac{n}{NT}\right] = \frac{1}{N}\sum\limits_{K=0}^{N-1}h[KT]e^{-\frac{i2\pi nk}{N}}<br>$$<br>其中：$K$为离散的时间点，$k=0,1,\dots,N-1;N$为离散时间信号长度；$T$为采样时间间隔。</p><p>对于离散信号，令$f = \frac{n}{NT}$,$\tau = jT$，最终的离散信号的S变换可以表示为：<br>$$<br>S\left(jT,\frac{n}{NT}\right)= \sum\limits_{m=0}^{N-1}H\left[\frac{m+n}{NT}\right]e^{-\frac{2\pi^2m^2}{n^2}}e^{\frac{i2\pi mj}{N}},(n\ne 0)<br>$$<br><strong>ST克服了SIFT窗口的时宽不变的缺陷，能根据频率的变化和自适应调整分析时宽和提供直观的时间频率特征，且无须选择窗口函数域分析尺度</strong>。</p><p><strong>广义S变换公式推导</strong>：</p><p>对于傅里叶变换，其正变换为：<br>$$<br>H(f) = \int_{-\infty}^{\infty}h(t)\exp(-i2\pi ft)dt<br>$$<br>其中：$h(t)$为待分析的时间信号序列；$f$为频率；$t$表示时间；$H(f)$时是信号$h(t)$的傅里叶变换。</p><p>加入对时间序列$h(t)$加上一个窗函数$g(t)$，则其谱变为：<br>$$<br>H(f) = \int_{-\infty}^{\infty}h(t)g(t)\exp(-i2\pi ft)dt<br>$$<br>对于ST，首先定义一个<strong>高斯窗函数</strong>：<br>$$<br>g(t) = \frac{1}{\sigma \sqrt{2\pi}}\exp\left(\frac{t^2}{2\sigma^2}\right)<br>$$<br>其中：$\sigma$为高斯函数的方差，对上述高斯窗函数进行伸缩与平移，得到$S$变换的公式为：<br>$$<br>S(\tau,f,\sigma) = \int_{-\infty}^{\infty} h(t) \frac{1}{\sigma \sqrt{2\pi}}\exp \left[-\frac{(t-\tau)^2}{2\sigma^2}\right]·\exp(-i2\pi ft)dt<br>$$<br>其中：$\tau$表示高斯窗函数在时间上的平移量。</p><p>实际上：S变换就是<strong>把小波基函数用高斯窗来代</strong>替，也被定义为“相位正交”的连续小波变换。</p><p>信号$x(t)$的ST定义如下：<br>$$<br>\cases{S(\tau,f) = \int_{-\infty}^{\infty}x(t)w(t-\tau,f)e^{-i2\pi ft}dt  \ w(t-\tau,f) = \frac{|f|}{\sqrt{2\pi}}e^{\frac{-f^2(t-\tau)^2}{2}}}<br>$$<br>其中：$w(t-\tau,f)$为高斯窗函数；$\tau$为时移因子，控制高斯窗在时间轴的位置；$f$为频率。</p><p>由上式可知：</p><p>高斯窗口克服了短时傅里叶变换窗口高度和宽度固定的缺陷，其随频率而变化。因此，ST既可以获得某一时刻的频率信息，也可获得在某一频率上信号的幅值信息。</p><p><strong>S变换的应用</strong>：</p><p>将ST应用在PQD检测和分类的研究成果最多。PQD（Power Quality Disturbances）<strong>电能质量扰动</strong>会导致设备过热、电机停转、保护失灵以及计量不准等严重后果。</p><p><strong>基于S变换的PQD检测：</strong>PQD 检测包括扰动起止时刻的定位、 扰动持续时间和扰动幅值的测量等方面的内容。文献首次提出采用 S 变换模矩阵的等值线检测扰动的发生，并发现时频曲线的标准差与扰动幅值存在一一对应关系，可以用来测量扰动幅值，但该文对 S 变换应用于 PQD 检测仅是探索性的，并未形成一套完整可行的方法。</p><p>目前 S 变换应用于 PQD 检测主要集中于扰动频率与幅值、扰动起止时刻与持续时间这些常规参数的检测，而且只是考虑了稳态或存在稳定段的扰动幅值检测，对不存在稳定段的暂态扰动如振荡暂态、脉冲暂态等幅值的检测并没有提出有效的方法，同时对于 S 变换应用于振荡暂态衰减因子、电压切口深度及宽度等参数的检测尚未见文献报道。</p><p><strong>基于S变换的PQD分类</strong>：PQD的识别实际是一个模式分类问题，关键思想是针对PQD特征选定一个较优的分类器进行模式识别。目前基于S变换的PQD识别方法一般是从待分析的PQD信号的S变换模矩阵中提取特征，然后借助人工智能分类器实现分类。</p><ol><li>基于S变换和ANN的PQD分类。</li><li>基于S变换和SVM的PQD分类。</li><li>基于S变换和规则判别的PQD分类。</li></ol><p>S变换在PQD应用方面有待进一步研究的方面有：</p><ul><li>S变换的结果是二维复矩阵，能够提供丰富的时频信息，其相位和原始信号保持直接的联系，目前对相位信息的利用很少，对于PQD的某些应用如扰动源的定位利用相位信息比幅值信息应该更有效。</li><li>由于 S 变换的运算量很大，在实际应用时对计算环境会有很高的要求，因此，对 S 变换算法或计算过程进行改进，在保证 PQD 分析精度的基础上提高其运算实时性，是其现实广泛应用的前提。</li><li>对 PQD 最精确和全面的检测应该是将描述其数学模型的所有参量进行准确的估计，而目前S 变换应用于 PQD 检测主要集中于稳态扰动的参数检测，对暂态扰动如振荡暂态的最大幅值和衰减因子等参量的检测并没有提出有效的方法。</li><li>S 变换作为 PQD 信号的特征提取工具，如何针对具体应用情况从 S 变换提取最有效的特征量尚缺乏全面和系统的研究。</li><li>除检测和分类之外， S 变换在 PQD 其他方面的应用如信号去噪、扰动源定位尚不多见，同时，开发新形式的 S 变换为PQD 分析提供更适宜的时频分辨率，研究确定最优时频分辨率的理论依据也值得进一步研究。</li><li>S 变换在 PQD 分析的应用尚处于算法仿真阶段，其在具体硬件环境中的实现及实际应用效果的评价鲜见报道。</li></ul><p><strong>参考文献：</strong></p><blockquote><p>易吉良； 彭建春； 谭会生．S变换在电能质量扰动分析中的应用综述：电力系统保护与控制，2011</p></blockquote>]]></content>
    
    <summary type="html">
    
      小波变换&amp;傅里叶变换&amp;S变换等
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>概率图模型</title>
    <link href="https://jiangxj.top/blog/2020/05/12/%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>https://jiangxj.top/blog/2020/05/12/概率图模型/</id>
    <published>2020-05-11T16:00:00.000Z</published>
    <updated>2020-06-18T01:52:03.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概率图模型"><a href="#概率图模型" class="headerlink" title="概率图模型"></a>概率图模型</h2><p>概率图模型(graphical model)是概率论和图论之间的桥梁，概率图模型的基本想法来自模块的概念，即一个复杂的系统是由简单的部分所联合而成，概率部分告诉我们哪些部分是耦合在一起的，然后提供推断模型的方法，图论的作用是给出一个直观的认识，把拥有相互关系的变量看成是数据结构，从而导出一般化的方法来解决问题。</p><p>概率图模型刻画模型的随机变量在变量层面的依赖关系，反映问题的概率结构以及推理的难易程度，为推理算法提供可操作的数据结构。概率图模型的表示方法常用的有贝叶斯网络、马尔科夫网络、因子图等。</p><p>在概率图模型中，点代表随机变量，点与点之间边的存在与否代表点与点之间存在条件依赖，点与边的组合描绘了联合概率分布的特征结构。假设有$N$个二元随机变量，在没有任何信息的帮助下，联合分布$P(X_1,\dots,X_N)$，需要$O(2^N)$个参数。而通过概率图描绘点与点之间的条件关系之后，表示联合分布，所需要的参数会减少很多，利于之后模型的推断和学习。</p><p>基本的概率图模型可以分为两类：贝叶斯网络(bayesian network)和马尔科夫随机场(markov random field)。</p><p>贝叶斯网络采用有向无环图(directed acyclic graph)来表示因果关系，马尔科夫随机场采用无向图(undirected graph)来表达变量间的相互作用。无向图多用于物理和图像领域，有向图多用于机器学习。</p><p>贝叶斯网络的每一个节点都对应于一个先验概率分布或者条件概率分布，因此整体的联合分布可以直接分解为所有的单个节点所对应的分布的乘积；马尔科夫场，变量之间没有明确的因果关系，它的联合概率分布通常会表示为一系列的势函数(potential function)的乘积。通常情况下，还需要对这些乘积进行归一化，形成一个有效的概率分布——这给参数估计造成很大的困难。</p><p>在实际使用的模型，很多时候是它们的某种形式的结合，如一个马尔科夫随机场可以整体成为一个更大的贝叶斯网络的节点，或者，多个贝叶斯网络可以通过马尔科夫随机场联系，构建混合模型。</p><p><a href="https://blog.csdn.net/yangliuy/article/details/9335697" target="_blank" rel="noopener">PGM综述-by MIT 林达华博士</a></p><p><a href="http://www.cs.cmu.edu/~epxing/Class/10708-14/lecture.html" target="_blank" rel="noopener">CMU概率图模型课程</a></p><p><a href="https://blog.csdn.net/thither_shore/article/details/52185758" target="_blank" rel="noopener">概率图模型资源分享</a></p><h3 id="PGM概述"><a href="#PGM概述" class="headerlink" title="PGM概述"></a>PGM概述</h3><p><strong>PGM应用场景</strong></p><p>一个是用于医学诊断。医生根据掌握的病人的相当数量的信息、各种测试结果、症状等，推断出病人的病情，不同的治疗方案会有怎样的结果等。</p><p>另一个是图像分割。给图像中的每个像素贴上类别标签。</p><p>这两个问题的共同点是：</p><p>1、都具有大量的我们需要从中推理的变量，在图像分割中，不同的像素或者像素构成的小区域的标签称为superpixels。</p><p>2、不管算法设计如何清晰，但是正确的结果仍然具有不确定性。</p><p><strong>Model是什么</strong></p><p>模型是我们理解世界的形象化表示(Declarative representation)。是理解周围世界的声明或者表达方式，在计算机内，一个模型包括我们对若干变量的理解，如变量的含义、变量之间的交互。</p><p>模型的特性使得我们能够将新的算法加入模型内部，同时加入新的外界知识，比如专家知识是知道模型，通过学习的方法改善模型。</p><p><strong>Probability是什么</strong></p><p>首先解释不确定性(uncertainty)，产生不确定性的原因主要有：</p><p>1、对世界认知状态的不完整</p><p>2、含有噪声的观测(Noisy observation)</p><p>3、模型未能覆盖所有实际现象</p><p>4、固有的随机性</p><p>概率论，通常具有清晰的表达式，强推理模式，可建立的学习方法</p><p><strong>Graphical是什么</strong></p><p>是一种复杂的数据结构，通常包括顶点和连接顶点的边。</p><p><strong>Graphical Models图模型</strong></p><p>基本的概率图模型可以分为两类：贝叶斯网络(bayesian network)【有向无环图】和马尔科夫随机场(markov random field)【无向图】</p><p>顶点表示随机变量，边表示随机变量之间的概率依赖关系。</p><p><strong>分布(Distributions)</strong></p><p>联合分布概率密度函数</p><p>条件概率分布</p><h3 id="PGM模型分类简介"><a href="#PGM模型分类简介" class="headerlink" title="PGM模型分类简介"></a>PGM模型分类简介</h3><h4 id="概率模型"><a href="#概率模型" class="headerlink" title="概率模型"></a>概率模型</h4><p>Probabilistic models常用来描述不同的随机变量之间的关系，主要针对变量或变量间的相互不确定性的概率关系建模。</p><p>1、参数模型：由一堆有限维参数构成的分布集合$\mathcal{P} = \{\mathbb{P} _{\theta} : \theta \in \Theta\}$。$\theta$是参数，$\Theta \subseteq \mathbb{R}^d$是其可行欧几里得子空间。</p><p>2、非参数模型：由一组无限维参数构成的概率分布函数集合，可表示为$\mathcal{P} = \{所有的分布\}$。</p><p>PGM是概率模型的一种，通过利用有向图或者无向图来表示变量之间的概率关系，可以将复杂的概率模型转换为纯粹的代数运算。常见的PGM的分类有：<img src="/blog//jiangxj.top/blog/2020/05/12/概率图模型/1.jfif" alt="1"></p><h4 id="PGM中的factor"><a href="#PGM中的factor" class="headerlink" title="PGM中的factor"></a>PGM中的factor</h4><p>factors影响因子，在PGM模型中，一个factor可以看成是graph中的一个节点，两个factor之间的联系用图的边来表示。</p><p>一个PGM模型最终可以建模为所有factor的联合概率分布，然后根据factor之间的运算规则，可以将联合概率分布转化为可运算的概率分布的乘积。</p><img src="/blog/2020/05/12/概率图模型/1.jfif" title="PGM分类衍生"><img src="/blog/2020/05/12/概率图模型/2.jfif" title="PGM概率分布"><h4 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h4><p>是一种典型的图模型，它对感兴趣变量(variables of interest)及变量之间的关系(relationship)进行建模。贝叶斯模型和统计技术一起使用，具有如下优势：</p><p>(1)    贝叶斯学习能够方便的处理不完全数据。例如考虑具有相关关系的多个输入变量的分类或回归问题，对标准的监督学习算法而言，变量间的相关性并不是它们处理的关键因素，当这些变量中有某个缺值时，它们的预测结果就会出现很大的偏差。而贝叶斯学习则提供了较为直观的概率关联关系模型。</p><p>(2)    贝叶斯学习能够学习变量间的因果关系。因果关系是数据挖掘中极为重要的模式。原因有二：在数据分析中，因果关系有利于对领域知识的理解；在干扰较多时，便于作出精确的预测。</p><p>(3)    贝叶斯网络与贝叶斯统计相结合能够充分利用领域知识和样本数据的信息。任何从事过实际建模任务的人都会知道先验信息或领域知识在建模方面的重要性，尤其是在样本数据稀疏或数据较难获得的时候，一些商业方面的专家系统完全根据领域专家知识来构建就是一个很好的例证。贝叶斯网络用弧表示变量间的依赖关系，用概率分布表来表示依赖关系的强弱，将先验信息与样本知识有机结合起来。<br>贝叶斯学习理论在数据挖掘中获得了成功的应用。对贝叶斯学习理论研究最大的动力就是它在实际应用中的巨大作用和潜力。目前，贝叶斯学习理论已成功地应用到智能用户接口、信息滤波、车辆自动导航、武器制导、医疗诊断、经济预测和文本分类等诸多领域。</p><p>(4)贝叶斯统计方法可以和贝叶斯网络一起使用，避免了数据过度拟合（the overfiting of data）。</p><p><strong>基本概念</strong></p><p>是有向无环图模型(directed acyclic graphical model)，是一种概率图型模型。通过有向无环图得知一组随机变量$\{X_1,\dots,X_n\}$及其$n$组条件概率分配(conditional probability distributions，CPDs)性质。</p><p>例如，贝叶斯网络可以表示疾病和其相关症状间的概率关系，假若已知某种症状下，贝叶斯网络就可以用来计算各种可能罹患疾病的发生概率。</p><p>一般而言，贝叶斯网络的有向无环图的节点表示随机变量，它们可以是可观察的变量或隐变量，未知参数等连接两个节点的箭头表示之间具有因果关系或是非条件独立。</p><p>节点中变量之间若没有箭头相互连接，称变量彼此之间为条件独立；若以单箭头连接在一起，一个是因(parents)，另一个是果(descendants or children)。</p><p>令$G =(I,E)$表示一个有向无环图(DAG)，其中$I$代表所有节点的集合，$E$代表有向连接线段的集合，令$X = X_i, i \in I$，为其有向无环图中的某一节点$i$代表的随机变量，若节点$X$的联合概率分布可以表示为：<br>$$<br>p(x) = \prod\limits_{i \in I} p(x_i |x_{pa(i)})<br>$$<br>称$X$为相对于一有向无环图$G$的贝叶斯网络，其中$x_{pa(i)}$表示节点$i$的 因</p><p>对任意的随机变量，其联合分布可由各自的局部条件概率分配相乘得出：<br>$$<br>P(X_1 = x_1,\dots, X_n = x_n) = \prod_{i=1}^n P(X_i = x_i | X_{i+1} = x_{i+1},\dots,X_n = x_n)<br>$$<br>对于贝叶斯网络的联合概率而言：<br>$$<br>P(X_1 = x_1,\dots, X_n = x_n) = \prod_{i=1}^n P(X_i = x_i | X_{j} = x_{j},对比每个相对于X_i的 因变量X_j而言)<br>$$<br>主要区别在于<em>在贝叶斯网络中，若已知因变量下，某些节点会与其因变量条件独立，只有与因变量有关的节点才会有条件概率的存在。</em></p><p><strong>独立与分割</strong></p><p>独立：令$X,Y,Z$代表概率事件，如果$X,Y$满足$P(X,Y) = P(X) \times P(Y)$，称相互独立(independent)；如果$P(X,Y,Z)$正比于$\phi_1(X,Z)\times \phi_2(Y,Z)$，称$X,Y$在条件$Z$下独立。</p><p>有向分割(D-Separated)：对于变量集合$Z$中任意一个变量，如果$X,Y$之间没有活动路径，称$X,Y$为有向分割。</p><p><strong>推理(inference)</strong></p><p>贝叶斯网络可以利用变量之间的条件独立对联合分布进行分解，降低参数个数，推理是通过计算回答查询的过程。</p><p>（1）变量消元算法(Variable elimination)</p><p>利用概率分解降低推理的复杂度。</p><p>使用运算局部化。消元过程实质上就是一个边缘化的过程。</p><p>最优消元顺序：最大势搜索，最小缺边搜索。</p><p>（2）团树传播算法</p><p>利用步骤共享来加快推理的算法。团树（clique tree）是一种无向树，其中每一个节点代表一个变量集合，称为团（clique）。团树必须满足变量的连通性，即包含同一变量的所有团所导出的子图必须是连通的。</p><p>基本步骤：</p><blockquote><p>将贝叶斯网络转化为团树</p><p>团树初始化</p><p>在团树中选一个团作为枢纽</p><p>全局概率传播：collect_message;distribute_message</p><p>边缘化，归一化</p></blockquote><p><strong>构建贝叶斯网络</strong></p><p>包括（1）变量的定义；（2）结构学习；（3）参数学习</p><p>包含两个任务：</p><p>一是在领域专家的指导下选取合适的研究问题领域内的变量，同时在有些情况下也需要一定的策略，从专家提供的变量中选择重要因子。</p><p>二是构建出一个有向无环图并给出图中每个结点的分布参数，即每个节点都对应一个条件概率分布表(CPT)。</p><p>一般情况下，有两种不同方式构造贝叶斯网络：</p><p>（1）完整学习：完全由人主观定义网络的结构和参数，有领域专家确定贝叶斯网络的变量，通过专家知识确定贝叶斯网络的结构，并指定分布参数。这样构建的网络，会因为人的知识的有限性，导致出现很大的偏差。</p><p>（2）部分学习：由人主观定义网络的节点变量，然后通过大量的训练数据来学习网络的结构和参数。这完全是一种数据驱动的方法，具有很强的适应性。</p><h3 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h3><p>朴素贝叶斯分类器(Naive Bayes Classifier)特别适用于输入数据维数较高的情况。</p><img src="/blog/2020/05/12/概率图模型/3.gif" title="朴素贝叶斯分类器"><p>先验知识：知道一个球要么是红色要么是绿色。假定红球20，绿球40个</p><p>任务：当有新的输入(new cases)时，给出的新输入的物体的类别（红或绿），即贝叶斯分类器的标签-label。</p><p>图中，绿球的数量明显大于红球，有理由认为，新输入更有可能是绿球。<br>$$<br>\rm{ prior  probability  for  GREEN  = } \frac{ \rm{ number  of  GREEN  objects}}{\rm{Total  number  of  objects}} = \frac{40}{60}<br>$$</p><p>$$<br>\rm{ prior  probability  for  RED  = } \frac{ \rm{ number  of  RED  objects}}{\rm{Total  number  of  objects}} = \frac{20}{60}<br>$$</p><p>似然(likehood)：有了先验知识，可以对新的输入(白色圈表示)进行分类，如果要取得比较准确的分类结果，猜测是绿色比较保险，即新物体与绿球的likehood比与红球的likehood更大。<br>$$<br>\rm{ Likehood  of  X  given    GREEN  = } \frac{ \rm{ number  of  GREEN  in  the vicinity  of  X}}{\rm{Total  number  of  GREEN  cases}} =\frac{1}{40}<br>$$</p><p>$$<br>\rm{ Likehood  of  X  given    RED  = } \frac{ \rm{ number  of  RED  in  the vicinity  of  X}}{\rm{Total  number  of  RED  cases}} = \frac{3}{20}<br>$$</p><p>存在情况是：对于先验知识，$X$是绿球的可能性比红球更大，但是似然(likehood)的表现是相反的</p><p>在贝叶斯分析中，最后的类别是上述两个概率（先验和似然），即：<br>$$<br>\rm{ posterior  probability  of  X  being  GREEN =} \frac{ \rm{ prior  probability  for  GREEN} \times \rm{Likehood  of  X  given    GREEN}}{在圈内球的概率 = \frac{4}{60}} = \frac{1}{4}<br>$$</p><p>$$<br>\rm{ posterior  probability  of  X  being  RED =} \frac{ \rm{ prior  probability  for  RED} \times \rm{Likehood  of  X  given    RED}}{在圈内球的概率 = \frac{4}{60}} = \frac{3}{4}<br>$$</p><p>实际使用过程中，需要进行<strong>归一化(normalized)处理</strong>。</p><h3 id="Factor之间的推理"><a href="#Factor之间的推理" class="headerlink" title="Factor之间的推理"></a>Factor之间的推理</h3><p>Factor之间的推理（Reasoning Patterns）可以分类为：</p><p>1、causal reasoning：因果推理</p><p>2、evidential reasoning：证据推理</p><p>也称为D-S推理。将假设看成一个集合，引入信任函数、似信度函数、类概率函数等描述命题的精确信任程度、信任程度和估计信任程度，对命题的不确定性作多角度的描述。</p><p>对从不同性质的数据源中提取证据，利用正交求和方法综合证据，通过证据的积累缩小集合，从而获得问题的解。</p><p>3、intercausal reasoning：混合推理</p><p>结合因果推理和证据推理。</p><p><a href="https://blog.csdn.net/polly_yang/article/category/1243538" target="_blank" rel="noopener">PGM课程笔记-coursera</a></p>]]></content>
    
    <summary type="html">
    
      概率图模型原理简介
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>makefile简介</title>
    <link href="https://jiangxj.top/blog/2020/05/11/makefile/"/>
    <id>https://jiangxj.top/blog/2020/05/11/makefile/</id>
    <published>2020-05-10T16:00:00.000Z</published>
    <updated>2021-06-29T03:03:43.867Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一个工程的源文件很多，按类型、功能、模块分别放在若干个目录中，makefile定义了一系列规则来指定，包括文件的编译的先后顺序，甚至进行更复杂的功能操作。makefile类似一个shell脚本，其中可执行操作系统的命令。</p><p>makefile写好，需要一个make命令，整个工程完全自动编译，提高软件开发的效率。make是一个解释makefile中指令的命令工具，一般大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。【GNU是关于Linux内核的标准，一切有关Linux的开发必须符合GNU的规定】</p><h1 id="关于程序的编译和链接"><a href="#关于程序的编译和链接" class="headerlink" title="关于程序的编译和链接"></a>关于程序的编译和链接</h1><p>程序的编译，无论c/c++，还是pascal，首先把源文件编译成中间代码文件，win下是<code>.obj</code>文件，UNIX下是<code>.o</code>文件，即<code>object File</code>，编译（compile）操作。然后把大量的<code>Object File</code>合成可执行文件，即作链接（link)。</p><p>编译时，编译器需要的语法是正确的，函数和变量的声明的正确。函数和变量的声明是需要告诉编译器的头文件所在位置，【头文件只是声明，定义在c/c++文件中】，只要所有语法正确，编译器就可以编译出中间目标文件，一般来说，每个源文件都应该对应于一个中间目标文件（o文件或是obj文件）。</p><p>链接时，主要是链接函数和全局变量，可以使用这些中间目标文件（o文件或是obj文件）来链接应用程序。链接器不管函数所在的源文件，只负责中间文件（o文件或是obj文件）。大多数时候，由于源文件太多，编译生成的中间目标文件太多，链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，要给这些目标文件打个包，在win下这种包叫做“库文件”（Library File），即<code>.lib</code>文件，在UNIX下，是“Archive File”，即<code>.a</code>文件。</p><p>总结一下：</p><p>源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。若未声明，编译器会给出警告，但可以生成Object File。</p><p>链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，就会报Linker Error。在VC下，这种错误一般是Link 2001错误。</p><h1 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h1><p>make命令执行时，需要一个Makefile文件，告诉make命令需要如何去编译和链接程序。</p><p>给定一个示例，工程有8个c文件，和3个头文件，需要写一个makefile来告诉make命令如何编译和链接这几个文件，规则是：</p><ol><li>如果这个工程没有被编译过，所有的c文件都要被编译并被链接</li><li>若某几个文件被修改，只编译被修改的c文件，并链接目标程序</li><li>若工程的头文件被改变了，需要编译引用这几个头文件的c文件，并链接目标程序</li></ol><p>写好Makefile文件，make命令会自动智能地根据当前文件的修改情况来确定哪些文件需要重新编译，从而自己编译所需要的文件和链接目标程序。</p><h2 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="Makefile的规则"></a>Makefile的规则</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...  (冒号两边有空格)</span><br><span class="line">          command               (用tab键开头)</span><br><span class="line">          ...</span><br><span class="line">          ...</span><br></pre></td></tr></table></figure><p>target可以是一个或多个目标文件，可以是Object File，也可以是执行文件，甚至是一个标签（Label）。</p><p>prerequisites是要生成那个target所需要的文件或目标（即所需条件）</p><p>命令是生成目标所需要执行的脚本。（任意的shell命令）</p><p>这是一个<strong>文本依赖关系</strong>，target依赖于prerequisites中的文件，其生成规则定义在command中。</p><p>即：<strong>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行</strong>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o /</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line">       cc -o edit main.o kbd.o command.o display.o /</span><br><span class="line">                  insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h  (目标文件 ： 依赖文件)</span><br><span class="line">         cc -c main.c    (定义如何生成目标文件的操作系统命令，tab键开头)</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">         cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">         cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">            cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">            cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">            cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">            cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">            cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">            rm edit main.o kbd.o command.o display.o /</span><br><span class="line">               insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><p>反斜杠表示换行符，Makefile易读，内容保存在名为<code>Makefile</code>或<code>makefile</code>的文件中，然后该目录下直接输入命令<code>make</code>生成可执行文件edit。如果要删除执行文件和所有的中间目标文件，执行<code>make clean</code>操作。</p><p>其中，目标文件（target）包含：执行文件edit和中间目标文件<code>.o</code>文件。依赖文件（prerequisites）即冒号后面的<code>.c</code>和<code>.h</code>文件。</p><p>每一个<code>.o</code>文件都有一组依赖文件，而本身<code>.o</code>文件又是执行文件edit的依赖文件。<strong>依赖关系的实质就是说明目标文件是由哪些文件生成的，即目标文件是哪些文件更新的</strong>。</p><p><strong>定义好依赖关系，后续的那一行定义如何生成目标文件的操作系统命令，以一个Tab键作为开头</strong>。<code>make</code>只管执行所定义的命令，会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期比targets文件日期要新，或者target不存在，<code>make</code>会执行后续定义的命令。</p><p><code>clean</code>是一个操作名称，不是一个文件，若其冒号后面没有，<code>make</code>就不会自动去找文件的依赖性，不会执行其后所定义的命令。若要执行其后的命令，需要在<code>make</code>命令后明显得指出命令标签的名字，比如用<code>make clean</code>指令。这样可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序备份等。</p><h2 id="Makefile工作方式"><a href="#Makefile工作方式" class="headerlink" title="Makefile工作方式"></a>Makefile工作方式</h2><p>默认方式，只输入make命令。</p><ol><li>make在当前目录下找到<code>makefile</code>或<code>makefile</code>的文件</li><li>找到后，会找文件中的第一个目标文件（target），上例中找到<code>edit</code>文件，并把这个文件作为最终的目标文件</li><li>若edit文件不存在，或是edit所依赖的后面<code>.o</code>文件的文件修改时间要比edit这个文件新，那么，会执行后面的定义的命令来生成edit这个文件</li><li>若edit所依赖的<code>.o</code>文件也存在，make会在当前文件中找目标<code>.o</code>文件的依赖性，如果找到则再根据那一个规则生成<code>.o</code>文件（类似一个堆栈的过程）</li><li>C文件和H文件存在，make会生成<code>.o</code>文件，然后再用<code>.o</code>文件声明，make所处理的最终任务，就是执行edit文件</li></ol><p>make会一层一层的去找文件的依赖关系，直到最终编译出第一个目标文件，make只管文件的依赖性，不负责所定义的命令的错误或是编译不成功。找到依赖关系后，冒号后面的文件还是不存在，make指令不工作。</p><p>上例中，若修改了其中一个源文件，如<code>file.c</code>，根据依赖性，目标<code>file.o</code>会被重编译，变为最新的，<code>file.o</code>文件修改时间要比<code>edit</code>要新，所以<code>edit</code>会被重新链接。</p><p>如果修改了<code>command.h</code>，那么<code>kdb.o</code>、<code>command.o</code>和<code>files.o</code>都会被重编译，并且，<code>edit</code>会被重链接。</p><h2 id="Makefile变量使用"><a href="#Makefile变量使用" class="headerlink" title="Makefile变量使用"></a>Makefile变量使用</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o /</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line">       </span><br><span class="line">       cc -o edit main.o kbd.o command.o display.o /</span><br><span class="line">                  insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><p><code>.o</code>文件的字符串被重复了两次，如果要加入一个新的<code>.o</code>文件，需要在三个地方添加（包括<code>clean</code>）。当makefile复杂时，可能会漏，导致编译失败，便于makefile维护，在makefile中使用变量，makefile的变量是一个字符串（相当于c语言的宏）。</p><p>例如：</p><p>声明一个变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o\</span><br><span class="line">          insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><p>在makefile中以<code>$(object)</code>的方式来使用这个变量。</p><p><a href="/blog/download/makefile陈皓.pdf">参考文章——makefile陈皓</a></p>]]></content>
    
    <summary type="html">
    
      makefile简介
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu使用教程</title>
    <link href="https://jiangxj.top/blog/2020/05/10/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://jiangxj.top/blog/2020/05/10/ubuntu环境配置/</id>
    <published>2020-05-09T16:00:00.000Z</published>
    <updated>2020-05-18T03:16:23.175Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Ubuntu磁盘操作"><a href="#Ubuntu磁盘操作" class="headerlink" title="Ubuntu磁盘操作"></a>Ubuntu磁盘操作</h2><p>需要root权限</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">su</span></span><br><span class="line"><span class="keyword">su</span> ***</span><br></pre></td></tr></table></figure><p>用命令<code>fdisk -l</code>查看系统识别磁盘情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Device     Boot     <span class="keyword">Start</span>       <span class="keyword">End</span>   Sectors   <span class="keyword">Size</span> <span class="keyword">Id</span> <span class="keyword">Type</span></span><br><span class="line">/dev/sda1  *         <span class="number">2048</span> <span class="number">960335871</span> <span class="number">960333824</span> <span class="number">457.9</span>G <span class="number">83</span> Linux</span><br><span class="line">/dev/sda2       <span class="number">960337918</span> <span class="number">976771071</span>  <span class="number">16433154</span>   <span class="number">7.9</span>G  <span class="number">5</span> <span class="keyword">Extended</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: <span class="number">2.7</span> TiB, <span class="number">3000592982016</span> <span class="keyword">bytes</span>, <span class="number">5860533168</span> sectors</span><br><span class="line">Units: sectors <span class="keyword">of</span> <span class="number">1</span> * <span class="number">512</span> = <span class="number">512</span> <span class="keyword">bytes</span></span><br><span class="line">Sector <span class="keyword">size</span> (<span class="keyword">logical</span>/<span class="keyword">physical</span>): <span class="number">512</span> <span class="keyword">bytes</span> / <span class="number">4096</span> <span class="keyword">bytes</span></span><br><span class="line">I/O <span class="keyword">size</span> (<span class="keyword">minimum</span>/<span class="keyword">optimal</span>): <span class="number">4096</span> <span class="keyword">bytes</span> / <span class="number">4096</span> <span class="keyword">bytes</span></span><br><span class="line">Disklabel <span class="keyword">type</span>: gpt</span><br><span class="line">Disk identifier: <span class="number">1</span>AB82561-C5FD<span class="number">-47</span>A9<span class="number">-9</span>A29<span class="number">-31835617</span>EBD3</span><br><span class="line"></span><br><span class="line">Device     <span class="keyword">Start</span>        <span class="keyword">End</span>    Sectors  <span class="keyword">Size</span> <span class="keyword">Type</span></span><br><span class="line">/dev/sdb1   <span class="number">2048</span> <span class="number">5860532223</span> <span class="number">5860530176</span>  <span class="number">2.7</span>T Microsoft basic <span class="keyword">data</span></span><br></pre></td></tr></table></figure><p>可以看到磁盘的挂载点。</p><h2 id="ubuntu配置nVidia驱动"><a href="#ubuntu配置nVidia驱动" class="headerlink" title="ubuntu配置nVidia驱动"></a>ubuntu配置nVidia驱动</h2><p>一、禁用现有的开源驱动</p><p>Ubuntu默认安装了一个开源的驱动：<code>nouveau</code>。安装官方的驱动需要先禁用这个开源驱动，依次执行：</p><p><code>sudo bash -c &quot;echo blacklist nouveau &gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf&quot;</code></p><p><code>sudo bash -c &quot;echo options nouveau modeset=0 &gt;&gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf&quot;</code></p><p>执行完两条指令，使用命令：<code>cat /etc/modprobe.d/blacklist-nvidia-nouveau.conf</code>是否成功禁用了开源驱动，出现如下，表示成功：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> /etc/modprobe.d/blacklist-nvidia-nouveau.<span class="keyword">conf</span></span><br><span class="line">blacklist nouveau</span><br><span class="line"><span class="keyword">options</span> nouveau modeset=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>二、获取显卡型号</p><p>终端输入：<code>ubuntu-drivers devices</code>查看显卡硬件型号，会显示推荐安装驱动版本。</p><p>三、获取对应显卡驱动</p><p>去<a href="https://www.nvidia.com/Download/index.aspx" target="_blank" rel="noopener">NVIDIA driver search page</a>查看支持对应显卡的驱动的最新版本的版本号。</p><p>为防止最新版本不稳定，可以从<a href="https://www.geforce.cn/drivers" target="_blank" rel="noopener">geforce drivers</a>处查询支持当前显卡的所有驱动版本。</p><p>四、安装</p><p>终端命令：<code>sudo apt-get install nvidia-384</code>（当前安装的是384版本）。</p><p>如果命令出错，执行下面命令：</p><p><code>sudo apt-get upgrade</code></p><p><code>sudo apt-get update</code></p><p>五、测试nvidia driver是否安装成功</p><p>首先需要重新启动系统，然后在终端输入：<code>nvidia-smi</code>查看驱动是否安装成功。</p><hr><h2 id="Ubuntu16-04配置cuda9-0-cudnn7-0安装"><a href="#Ubuntu16-04配置cuda9-0-cudnn7-0安装" class="headerlink" title="Ubuntu16.04配置cuda9.0+cudnn7.0安装"></a>Ubuntu16.04配置cuda9.0+cudnn7.0安装</h2><p>GPU加速必须在cuda9以上才可以完成加速，cuda9以后的版本在Linux系统上只支持Ubuntu16.04和Ubuntu17.04。</p><h3 id="一、设备要求"><a href="#一、设备要求" class="headerlink" title="一、设备要求"></a>一、设备要求</h3><p>系统：Ubuntu16.04及以上</p><p>显卡驱动：NVIDIA系列（384以上）</p><p>驱动检查：终端命令<code>nvidia-smi</code></p><blockquote><p>新安装的Ubuntu系统安装NVIDIA驱动步骤:</p><p>a.删除旧驱动：</p><p>`sudo apt-get remove –purge nvidia* </p><p>b.禁用自带的nouveau nvidia驱动：</p><p>看下Nouveau是否已经被禁用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; lsmod | grep nouveau  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果已经没有任何显示说明不用禁用了，否则继续下面操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sudo vim /etc/modprobe.d/blacklist-nouveau.conf <span class="comment">#创建一个文件（注：按一下i键，表示现在进行内容插入）</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>并添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; blacklist nouveau</span><br><span class="line">&gt; options nouveau modeset=0 </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="二、安装cuda9-0"><a href="#二、安装cuda9-0" class="headerlink" title="二、安装cuda9.0"></a>二、安装cuda9.0</h3><p><a href="https://developer.nvidia.com/cuda-90-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1604&amp;target_type=runfilelocal" target="_blank" rel="noopener">官网下载</a>。有对应的deb和.run文件，有具体的安装命令。</p><p>推荐.run文件，因为deb文件安装，可能会修改已安装好的驱动和。</p><p>进入下载目录，给文件添加运行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./cuda_9.0.176_384.81_linux.run</span><br></pre></td></tr></table></figure><p>运行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./cuda_9.0.176_384.81_linux.run</span><br></pre></td></tr></table></figure><p>启动安装程序，一直按空格到最后（可以选择Ctrl+c跳过），不用担心，到99%的时候，输入accept接受条款</p><p>注意：第一个提醒你是否安装驱动时，选“n”，其余都“y”，安装路径选择默认的路径。</p><p><strong>以上为两种cuda的安装方法，不过并没有结束，安装完毕后必须添加环境</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在文件末尾添加环境变量</span></span><br><span class="line">export LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span><span class="symbol">:/usr/local/cuda-</span><span class="number">9.0</span>/lib64</span><br><span class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/usr/local/cuda-</span><span class="number">9.0</span>/bin</span><br><span class="line">export CUDA_HOME=<span class="variable">$CUDA_HOME</span><span class="symbol">:/usr/local/cuda-</span><span class="number">9.0</span></span><br></pre></td></tr></table></figure><p>添加完后，终端命令：<code>source ～/.bashrc</code></p><p>终端命令查看是否安装成功：<code>nvcc -V</code>，若出现nvcc未安装，</p><p>执行了 sudo apt-get install nvidia-cuda-toolkit 命令，nvcc命令可以正常执行，但是运行nvcc –version发现版本为5.5，与原来安装的CUDA 10.0不匹配，这将会导致一系列不兼容问题（比如在python中使用sk-cuda库就报错，因为nvcc版本不一致），遂通过如下步骤解决：</p><p>1、使用sudo apt-get autoremove nvidia-cuda-toolkit 卸载5.5版本</p><p>2、查看/usr/local/cuda/bin下是否有nvcc可执行程序，如果没有说明cuda没有正常安装，需要重新安装。</p><p>3、如果有nvcc可执行程序，切换到管理员权限，重新执行上面步骤，添加环境。</p><h3 id="三、安装cudnn7-3-1"><a href="#三、安装cudnn7-3-1" class="headerlink" title="三、安装cudnn7.3.1"></a>三、安装cudnn7.3.1</h3><p>去<a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">官网下载</a>，此处下载的是<code>cuDNN v7.3.1 Library for Linux</code>版本。是一个.tgz文件。</p><p>下载完直接解压，解压会出现一个cuda文件夹，里面有两个文件include 和lib64，把里面的文件<code>copy到/usr/local/cuda-9.0</code>里面相应的目录里，具体命令如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp cuda<span class="regexp">/include/</span>cudnn.h <span class="regexp">/usr/</span>local<span class="regexp">/cuda-9.0/i</span>nclude</span><br><span class="line">sudo cp cuda<span class="regexp">/lib64/</span>libcudnn* <span class="regexp">/usr/</span>local<span class="regexp">/cuda-9.0/</span>lib64</span><br><span class="line">sudo chmod a+r <span class="regexp">/usr/</span>local<span class="regexp">/cuda-9.0/i</span>nclude<span class="regexp">/cudnn.h /u</span>sr<span class="regexp">/local/</span>cuda-<span class="number">9.0</span><span class="regexp">/lib64/</span>libcudnn*</span><br></pre></td></tr></table></figure><p>查看cudnn版本，检查是否安装好：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> /usr/<span class="keyword">local</span>/cuda/<span class="keyword">include</span>/cudnn.<span class="keyword">h</span> | grep CUDNN_MAJOR -A 2</span><br></pre></td></tr></table></figure><h3 id="四、卸载"><a href="#四、卸载" class="headerlink" title="四、卸载"></a>四、卸载</h3><p>（1）卸载CUDA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/local/cuda-9.0/bin/uninstall_cuda_9.0.pl</span><br></pre></td></tr></table></figure><p>（2）卸载CUDNN</p><p>删除原来的cudnn文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /usr/local/cuda-9.0/lib64/libcudnn*</span><br><span class="line">sudo rm -rf /usr/local/cuda-9.0/include/cudnn.h</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/58114055" target="_blank" rel="noopener">Ubuntu16.04下cuda9.0+cudnn7.0安装参考教程1</a></p><p><a href="https://www.jianshu.com/p/6a6fbce9073f" target="_blank" rel="noopener">Ubuntu 多版本Cuda(8.0,9.0)以及CuDnn安装参考教程2</a></p><hr><h2 id="pytorch-gpu环境配置"><a href="#pytorch-gpu环境配置" class="headerlink" title="pytorch_gpu环境配置"></a>pytorch_gpu环境配置</h2><p>前提是已经配置好cuda9.0和cudnn7.0</p><p>在Anaconda环境下，新建一个pytorch-gpu环境，安装pytorch。</p><p>一、创建新的虚拟环境</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">create</span> -n pytorch_gpu python=<span class="number">3.7</span></span><br><span class="line">conda <span class="keyword">activate</span> pytorch_gpu /<span class="keyword">source</span> <span class="keyword">activate</span> pytorch_gpu <span class="comment">#激动虚拟环境</span></span><br></pre></td></tr></table></figure><p>二、安装对应的cuda和cudnn</p><p>三、安装pytorch</p><p><a href="https://pytorch.org/" target="_blank" rel="noopener">官网下载对应版本</a>的安装脚本，考虑操作系统、包、cuda版本、语言版本等。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision <span class="attribute">cudatoolkit</span>=9.0 -n pytorch_gpu -c pytorch</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/baidu_26646129/article/details/88380598" target="_blank" rel="noopener">Anaconda环境安装GPU版本Pytorch参考教程</a></p><hr><h2 id="tensorflow-gpu-keras环境配置"><a href="#tensorflow-gpu-keras环境配置" class="headerlink" title="tensorflow_gpu_keras环境配置"></a>tensorflow_gpu_keras环境配置</h2><p>Keras其实就是TensorFlow和Keras的接口（Keras作为前端，TensorFlow或theano作为后端），它也很灵活，且比较容易学。可以把keras看作为tensorflow封装后的一个API。</p><p>目前Keras是tensorflow官方的API。</p><h3 id="查看已经安装的Python版本"><a href="#查看已经安装的Python版本" class="headerlink" title="查看已经安装的Python版本"></a>查看已经安装的Python版本</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> | <span class="keyword">grep</span> <span class="keyword">python</span></span><br></pre></td></tr></table></figure><h3 id="将pip服务器更换为国内的镜像服务器"><a href="#将pip服务器更换为国内的镜像服务器" class="headerlink" title="将pip服务器更换为国内的镜像服务器"></a>将pip服务器更换为国内的镜像服务器</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果不存在此文件夹，则创建之</span></span><br><span class="line">mkdir ~<span class="string">/.pip</span></span><br><span class="line">vim ~<span class="string">/.pip/pip.conf</span></span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">index-url</span>=http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"><span class="section">[install]</span></span><br><span class="line"><span class="attr">trusted-host</span>=mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h3 id="tensorflow-gpu和keras安装"><a href="#tensorflow-gpu和keras安装" class="headerlink" title="tensorflow-gpu和keras安装"></a>tensorflow-gpu和keras安装</h3><h4 id="一、新建虚拟环境"><a href="#一、新建虚拟环境" class="headerlink" title="一、新建虚拟环境"></a>一、新建虚拟环境</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">create</span> -n tensorflow_gpu python=<span class="number">3.6</span> (ipykernel) <span class="meta">#选择加如jupyter notebook内核</span></span><br></pre></td></tr></table></figure><p>找到环境支持的对应的版本：</p><p><img src="https://img-blog.csdnimg.cn/20190819221921944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RZVVRfeGlhb21pbmc=,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="二、安装tensorflow-gpu"><a href="#二、安装tensorflow-gpu" class="headerlink" title="二、安装tensorflow-gpu"></a>二、安装tensorflow-gpu</h4><p>终端命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --ignore-installed --upgrade https:<span class="regexp">//</span>storage.googleapis.com<span class="regexp">/tensorflow/</span>linux<span class="regexp">/gpu/</span>tensorflow_gpu-<span class="number">1.6</span>.<span class="number">0</span>-cp36-cp36m-linux_x86_64.whl</span><br></pre></td></tr></table></figure><h4 id="三、测试tensorflow-gpu是否安装成功"><a href="#三、测试tensorflow-gpu是否安装成功" class="headerlink" title="三、测试tensorflow-gpu是否安装成功"></a>三、测试tensorflow-gpu是否安装成功</h4><p>测试代码如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">a = tf.constant([1.,2.,3.,4.,5.,6.], shape=[2,3], <span class="attribute">name</span>=<span class="string">'a'</span>)</span><br><span class="line">b = tf.constant([1.,2.,3.,4.,5.,6.], shape=[3,2], <span class="attribute">name</span>=<span class="string">'b'</span>)</span><br><span class="line">c = tf.matmul(a,b)</span><br><span class="line"></span><br><span class="line">with tf.Session(config= tf.ConfigProto(<span class="attribute">log_device_placement</span>=<span class="literal">True</span>)) as sess:</span><br><span class="line">    <span class="builtin-name">print</span>(sess.<span class="builtin-name">run</span>(c))</span><br></pre></td></tr></table></figure><p>成功检测到GPU，表明安装成功，且可以调用GPU运行。</p><p>GPU使用率：terminal下run：<code>nvidia-smi -q -g 0 -d UTILIZATION -l</code><br>or run：<code>watch -n 2 nvidia-smi</code></p><p>注意可能会出现tensorflow-gpu版本和cuda，cudnn版本的不匹配问题，需要卸载</p><p><a href="https://blog.csdn.net/linhai1028/article/details/79525507" target="_blank" rel="noopener">ubuntu下tensorflow-gpu环境搭建</a></p><h4 id="四、查看tensorflow-gpu安装版本"><a href="#四、查看tensorflow-gpu安装版本" class="headerlink" title="四、查看tensorflow-gpu安装版本"></a>四、查看tensorflow-gpu安装版本</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在<span class="keyword">python</span>环境中输入：</span><br><span class="line"></span><br><span class="line">import tensorflow <span class="keyword">as</span> <span class="keyword">tf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">tf</span>.__version__     (查看版本）</span><br><span class="line"></span><br><span class="line"><span class="keyword">tf</span>.__path__        （查看路径）</span><br></pre></td></tr></table></figure><h4 id="五、卸载命令"><a href="#五、卸载命令" class="headerlink" title="五、卸载命令"></a>五、卸载命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip <span class="keyword">uninstall</span> tensorflow</span><br><span class="line">sudo pip3 <span class="keyword">uninstall</span> tensorflow</span><br></pre></td></tr></table></figure><h4 id="六、安装Keras"><a href="#六、安装Keras" class="headerlink" title="六、安装Keras"></a>六、安装Keras</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> keras -U <span class="comment">--pre</span></span><br></pre></td></tr></table></figure><h4 id="七、验证安装"><a href="#七、验证安装" class="headerlink" title="七、验证安装"></a>七、验证安装</h4><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入python命令环境</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> keras</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Keras测试：</span><br><span class="line"></span><br><span class="line">Keras中mnist数据集测试 下载Keras开发包</span><br><span class="line"></span><br><span class="line">conda install git</span><br><span class="line"></span><br><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/fchollet/keras.git</span><br><span class="line"></span><br><span class="line"><span class="keyword">cd</span> keras/examples/</span><br><span class="line"></span><br><span class="line"><span class="keyword">python</span> mnist_mlp.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p>在《Tensorflow技术解析与实战》一书中提到，keras安装后需要选择依赖的后端，在~/.Keras/keras.json下修改最后一行backend对应的值，（默认后端是tensorflow，不用修改）也就是：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">｛</span><br><span class="line"></span><br><span class="line"><span class="string">"image_dim_ordering"</span><span class="symbol">:<span class="string">"tf"</span></span>,</span><br><span class="line"></span><br><span class="line"><span class="string">"epsilon"</span><span class="symbol">:le-</span><span class="number">07</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">"floatx"</span><span class="symbol">:<span class="string">"float32"</span></span></span><br><span class="line"></span><br><span class="line"><span class="string">"backend"</span>: <span class="string">"tensorflow"</span></span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h4 id="八、出现问题"><a href="#八、出现问题" class="headerlink" title="八、出现问题"></a>八、出现问题</h4><p>安装keras出现：<code>ImportError: cannot import name &#39;tf_utils&#39;</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> tensorflow</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> keras</span><br><span class="line">Using TensorFlow backend.</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  <span class="built_in">File</span> <span class="string">"&lt;stdin&gt;"</span>, <span class="built_in">line</span> <span class="number">1</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">  <span class="built_in">File</span> <span class="string">"/home/reyhan/project/.virtualenvs/keras_tf/lib/python3.6/site-packages/keras/__init__.py"</span>, <span class="built_in">line</span> <span class="number">3</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">from . <span class="keyword">import</span> utils</span><br><span class="line">  <span class="built_in">File</span> <span class="string">"/home/reyhan/project/.virtualenvs/keras_tf/lib/python3.6/site-packages/keras/utils/__init__.py"</span>, <span class="built_in">line</span> <span class="number">6</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">from . <span class="keyword">import</span> conv_utils</span><br><span class="line">  <span class="built_in">File</span> <span class="string">"/home/reyhan/project/.virtualenvs/keras_tf/lib/python3.6/site-packages/keras/utils/conv_utils.py"</span>, <span class="built_in">line</span> <span class="number">9</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">from .. <span class="keyword">import</span> backend as K</span><br><span class="line">  <span class="built_in">File</span> <span class="string">"/home/reyhan/project/.virtualenvs/keras_tf/lib/python3.6/site-packages/keras/backend/__init__.py"</span>, <span class="built_in">line</span> <span class="number">1</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">from .load_backend <span class="keyword">import</span> epsilon</span><br><span class="line">  <span class="built_in">File</span> <span class="string">"/home/reyhan/project/.virtualenvs/keras_tf/lib/python3.6/site-packages/keras/backend/load_backend.py"</span>, <span class="built_in">line</span> <span class="number">90</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">from .tensorflow_backend <span class="keyword">import</span> *</span><br><span class="line">  <span class="built_in">File</span> <span class="string">"/home/reyhan/project/.virtualenvs/keras_tf/lib/python3.6/site-packages/keras/backend/tensorflow_backend.py"</span>, <span class="built_in">line</span> <span class="number">13</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">from tensorflow.python.keras.utils <span class="keyword">import</span> tf_utils</span><br><span class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">'tf_utils'</span></span><br></pre></td></tr></table></figure><p>安装的keras版本是2.3.1的，卸载安装keras2.1.5版本，解决该问题，首先卸载现有keras版本：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pip uninstall keras</span></span><br></pre></td></tr></table></figure><p>安装keras2.1.5版本：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install keras==<span class="number">2.1</span><span class="number">.5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      包括基本操作，nVidia驱动，pytorch，tensorflow环境配置等
    
    </summary>
    
      <category term="教程" scheme="https://jiangxj.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Ubuntu" scheme="https://jiangxj.top/blog/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>受限玻尔兹曼机和深度置信网络</title>
    <link href="https://jiangxj.top/blog/2020/04/20/RBM&amp;DBN/"/>
    <id>https://jiangxj.top/blog/2020/04/20/RBM&amp;DBN/</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-06-18T02:15:30.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="受限玻尔兹曼机"><a href="#受限玻尔兹曼机" class="headerlink" title="受限玻尔兹曼机"></a>受限玻尔兹曼机</h2><p>梯度下降法（相关的L-BFGS(拟牛顿法)等）在使用初始化权重的深度网络上效果不好的原因：</p><p>在使用BP算法计算导数时，随着网络的深度增加，反向传播的梯度（从输出层到网络的最初几层）的幅度值急剧减小，造成整体的损失函数相对于最初的几层的权重的导数非常小，使得最初几层的权重变化非常缓慢，以至于不能从样本中进行有效的学习。称为“梯度弥散”。</p><p>与此相关，当神经网络的最后几层含有足够的神经元后，可能单独这几层就可以对有标签数据进行建模，而不用最初几层的帮助。因此，对所有层都使用随机初始化方法训练得到的整个网络的性能将会与训练得到的浅层网络（仅有最后几层构成的浅层网络）的性能类似。</p><p>Hinton提出了的RBM，是一类具有两层结构的、对称链接无自反馈的随机神经网络模型(一种特殊的马尔科夫随机场)。</p><img src="/blog/2020/04/20/RBM&DBN/1.jpg" title="RBM结构图"><p>一个RBM中，v表示所有可见单元，h表示所有隐藏单元，确定模型，需要模型的三个参数$\theta = \{W,A,B\}$即可。分别是权重矩阵$W$，可见层单元偏置$A$，隐藏单元偏置$B$。</p><p>一个RBM包含一个由随机隐单元构成的<strong>隐藏层</strong>（一般是伯努利分布）和一个随机的观测单元构成的<strong>可见层</strong>（一般是伯努利分布或高斯分布）。RBM可以表示成一个二分图模型，所有的可见单元和隐单元之间存在连接，隐单元两两之间和可见单元两两之间不存在连接，即<strong>层间全连接，层内无连接</strong>（区别：<strong>BM模型层间、层内全连接</strong>）。</p><p>每一个可见层节点和隐藏层节点都有两种状态，激活和未激活。节点激活的概率由可见层和隐藏层节点的分布函数计算。</p><p>假设一个RBM有n个可见单元和m个隐藏单元，$v_i$表示第i个可见单元，$h_j$表示第j个隐单元，参数形式为：</p><p>$W = \{w_{i,j} \in R^{n \times m}\}，w_{i,j}$表示第i个可见单元和第j个隐单元之间的权值</p><p>$A = \{a_i\} \in R^m,a_i$表示第i个可见单元的偏置阈值</p><p>$B = \{b_j\} \in R^n,b_j$表示第i个隐单元的偏置阈值</p><p>给定一组状态下的$(v,h)$的值，假设可见单元和隐藏单元均服从伯努利分布，RBM的能力公式为：<br>$$<br>E(v,h|\theta) = - \sum\limits_{i=1}^n a_i v_i - \sum\limits_{j=1}^m b_jh_j - \sum\limits_{i=1}^n \sum\limits_{j=1}^mv_i W_{ij}h_j<br>$$<br>其中，令$\theta = \{W_{ij},a_i,b_j\}$是RBM模型的参数，能量函数表示在每一个可见节点的取值和每一个隐藏层节点的取值之间都存在一个能量值。</p><p>对<strong>能量函数的指数化和正则化</strong>后可以得到可见层节点集合和隐藏节点集合分别处于某一种状态下$(v,h)$联合概率分布公式：<br>$$<br>P(v,h|\theta) = \frac{e^{-E(v,h|\theta)}}{Z(\theta)}<br>$$</p><p>$$<br>Z(\theta) = \sum\limits_{v,h} e^{-E(v,h|\theta)}<br>$$</p><p>$Z(\theta)$为归一化因子或<strong>配分函数(partition function)</strong>，表示对可见层和隐藏层节点集合的所有可能状态的(能量指数)的求和。</p><p>对于参数的求解使用似然函数求导的方法，已知联合概率分布$P(v,h|\theta)$，通过对隐藏层节点集合的所有状态求和，可以得到可见层节点集合的边缘分布$P(v|\theta)$：<br>$$<br>P(v|\theta) = \frac{1}{Z(\theta)} \sum\limits_h e^{-E(v,h|\theta)}<br>$$<br><strong>边缘分布</strong>表示的是可见层节点集合处于某一种状态分布下的概率，也被称为<strong>似然函数</strong>。</p><p>RBM模型性质：</p><p>（1）在给定可见单元的状态时，各个隐含层单元的激活状态之间是条件独立的，此时，第j个隐单元的激活概率为：<br>$$<br>P(h_j = 1|v) = \sigma(b_j + \sum\limits_iv_i W_{ij})<br>$$<br>（2）当给定隐单元的状态时，可见单元的激活概率同样是条件独立的：<br>$$<br>P(v_i = 1|h) = \sigma(a_i + \sum\limits_j W_{ij}h_j)<br>$$<br>其中，$\sigma(x) = \frac{1}{1+\exp(-x)}$，sigmoid函数可以使得无论模型的可见层输入节点数据处于一个多大的范围内，都可以通过sigmoid函数求得它相应的函数值，即节点的激活概率值。</p><h3 id="模型参数求解"><a href="#模型参数求解" class="headerlink" title="模型参数求解"></a>模型参数求解</h3><p>训练一个RBM主要任务是调参，以拟合给定的训练样本，使得在该参数下RBM表示的可见层节点概率分布尽可能与训练数据相符合。</p><p>首先，确定可见层和隐含层节点个数，可见层节点数等于输入数据的维数，隐藏层节点个数一般需要根据使用而定，或者参数一定的情况下，使得模型的能量最小时的隐藏层节点个数。</p><p>其次，求解模型的三个参数，$\theta = \{W_{ij},a_i,b_j\}$，参数求解使用到似然函数的对数对参数求导。</p><p>具体求解过程：<br>$$<br>P(v|\theta) = \frac{1}{Z(\theta)} \sum\limits_h e^{-E(v,h|\theta)}<br>$$<br>能力E与概率P是成反比的关系，最大化P，使得能量E最小，最大化似然函数方法是 <strong>梯度上升法</strong>。<br>$$<br>\theta = \theta + \mu \frac{\partial \ln P(v^t)}{\partial \theta}<br>$$<br>其中$v^t$表示输入数据，对原来$\theta$进行修改，迭代使得似然函数$P$最大。<br>$$<br>\frac{\partial \ln P(v^t)}{\partial w_{i,j}} = P(h_j =1|v^t)v_i^t - \sum\limits_v P(v)P(h_j = 1|v)v_i<br>$$</p><p>$$<br>\frac{\partial \ln P(v^t)}{\partial a_i} = v_i^t - \sum\limits_v P(v)v_i<br>$$</p><p>$$<br>\frac{\partial \ln P(v^t)}{\partial b_j} =P(h_j = 1|v^t) - \sum\limits_v P(v)P(h_j = 1|v)<br>$$</p><p>式中第二项$P(v)$仍然含有参数，$P(v)$表示可见层节点的联合概率，很多提出通过<strong>采样逼近</strong>的方法来求。</p><h3 id="模型训练算法"><a href="#模型训练算法" class="headerlink" title="模型训练算法"></a>模型训练算法</h3><h4 id="1、Gibbs采样算法"><a href="#1、Gibbs采样算法" class="headerlink" title="1、Gibbs采样算法"></a>1、Gibbs采样算法</h4><p>求解可见层节点的联合概率$P(v)$，逼近其近似值。</p><p>Gibbs采样思想：</p><p>不知道一个样本数据$\pmb x = (x_1,x_2,\dots,x_N)$的联合概率$P(x)$，但是知道样本中的每一个数据的条件概率$p(x_i|\pmb x)$（假设每一个变量都服从一种概率分布），可以先求出每一个数据的条件概率值，得到$x$的任一状态$[x_1(0),\dots,x_i(0),\dots,x_N(0)]$，然后用条件概率公式迭代对每一个数据求条件概率，最终，迭代$k$次，$x$的某一个状态$[x_1(k),\dots,x_i(k),\dots,x_{N}(k)]$将收敛于$x$的联合概率分布$P(x)$。</p><p>假设一个训练样本$v_0$，根据公式$P(h_j=1 |v)$求$h_0$中每个节点的条件概率，再由$P(v_i = 1|h)$，求$v_1$中每个节点的条件概率，依次迭代，直到执行$K$步（足够大），此时$P(v|h)$的概率将收敛于$P(v)$的概率：<br>$$<br>h_0 \sim P(h|v_0) \ v_1 \sim P(v|h_0) \ h_1 \sim P(h|v_1) \ v_2 \sim P(v|h_1) \ \dots \ v_{k+1} \sim P(v|h_k)<br>$$</p><p>对于RBM执行过程如下：</p><img src="/blog/2020/04/20/RBM&DBN/2.jpg" title="RBM执行过程"><h4 id="2、CD-K算法"><a href="#2、CD-K算法" class="headerlink" title="2、CD-K算法"></a>2、CD-K算法</h4><p>CD算法是需要K次Gibbs采样对可见层节点进行重构得到可见层节点的概率分布。</p><p>算法思想：假设给模型一个样本$v_0$，通过$P(h_j =1| v) = \sigma (b_j + \sum\limits_i v_i W_{ij} )$，求出所有隐藏层节点的概率值，然后每一个概率值和随机数进行比较得到每一个隐藏层节点的状态，然后通过:<br>$$<br>P(v_i=1 | h) =  \sigma (a_i + \sum\limits_j W_{ijh_j})<br>$$<br>求出每一个可见层节点的概率值，再由：<br>$$<br>P(h_j =1|v) = \sigma(b_j + \sum\limits_i v_iW_{ij})<br>$$<br>求出每一个隐含层节点的概率值，最后参梯度的计算公式变为：<br>$$<br>\Delta W_{ij} = \mu(&lt;v_ih_j&gt;_{data} - &lt;v_ih_j&gt;_{recon}) \ \Delta a_i = \mu (&lt;v_i&gt; _{data} - &lt;v_i&gt; _{recon}) \ \Delta b_j =\mu(&lt;h_j&gt;_{data} - &lt;h_j&gt;_{recon})<br>$$<br>其中，$\mu$是学习率，data和recon分别表示训练数据的概率分布和重构后的概率分布。</p><p>依此求出参数的梯度，由每一个参数的梯度对原参数进行修改来使得模型的能量减小。</p><h4 id="3、模型的评估"><a href="#3、模型的评估" class="headerlink" title="3、模型的评估"></a>3、模型的评估</h4><p>一般采用近似的方法对模型进行评估，常用的近似方法是<strong>重构误差</strong>，即以训练样本作为初始状态，经过RBM模型的分布进行一次Gibbs采样后与原数据的差异值。</p><img src="/blog/2020/04/20/RBM&DBN/3.jpg" title="模型评估伪代码"><p>对于一个给定样本$P(h_j =1 |v) = \sigma (b_j + \sum\limits_i v_i W_{ij})$，通过$P(v_i = 1|h) = \sigma(a_i + \sum\limits_j W_{ij}h_j)$对所有隐含层节点的条件概率进行采样，再通过对所有可见层节点的条件概率进行采样，最后由样本值和采样出的可见层概率值做差取绝对值，作为该模型的评估。</p><h4 id="4、节点状态确定"><a href="#4、节点状态确定" class="headerlink" title="4、节点状态确定"></a>4、节点状态确定</h4><p>对于每一层节点状态(0 or 1)的确定采用与随机数（0-1之间）进行比较的方法，如果节点被激活的概率值大于一个随机产生的数，则认为该节点被激活。</p><p>原理：给定可见层节点$v$，隐含层第$j$个节点状态为1的激活概率为$p_j^v$，此时，在区间$[0,1]$上产生一个随机数$r_j$落在子区间$[0,p_j^v)$的概率也是$p_j^v$，两个事件的概率是相等的，若随机数$r_j$落在子区间$[0,p_j^v)$，认为第$j$个节点的状态为1，否则为0。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>RBM网络模型的最大的目的是最大可能的拟合输入数据，最大化$P(v)$，Hinton提出一种快速训练算法contrastive divergence（CD）算法，需要迭代K次，一般K=1。</p><p>CD算法开始用训练数据去初始化可见层，然后用条件分布计算隐藏层，再根据隐藏层状态，同样，用条件分布计算可见层，这样产生的结果就是对训练数据的一个重构。</p><p>根据CD算法可得模型对网络权值的梯度：<br>$$<br>\Delta W_{ij} = \mu (&lt;v_ih_j&gt;_{data} - &lt;v_ih_j&gt;_{recon})<br>$$<br>其中，$\mu$为学习率，$&lt;v_ih_j&gt;_{data}$是样本数据的期望，$&lt;v_ih_j&gt;_{recon}$是重构后可见层数据的期望。</p><h2 id="深度置信网络"><a href="#深度置信网络" class="headerlink" title="深度置信网络"></a>深度置信网络</h2><p>深度置信网络(Deep Belief Network,DBN)是由RBM堆叠而成的，从而作为DBN预训练的基础模型。</p><p>不是只有RBM可以堆叠为一个深度生成式（或判别式）网络，其他类型的网络也可以使用相同的方法来生成网络，比如自动编码器(autoencoder)的变形。</p><img src="/blog/2020/04/20/RBM&DBN/4.jpg" title="深度置信网络结构"><p>将一定的数量的RBM堆叠成一个DBN，然后从底向上逐层预训练，堆叠过程如下：</p><p>训练一个高斯-伯努利RBM（对于语音应用使用连续的特征）或伯努利-伯努利RBM（对于正态分布或二项式分布特征应用，如黑白图像或者编码后的文本）</p><p>将隐单元的激活概率（activation probabilities）作为下一层伯努利-伯努利RBM的输入数据。</p><p>第二层伯努利-伯努利RBM的激活概率作为第三层伯努利-伯努利RBM的可见层输入数居，以后各层以此类推。</p><p>关于这种有效的<strong>逐层贪婪学习</strong>策略达到了近似的最大似然学习。这个学习过程是无监督的，所以不需要标签信息。</p><p>当应用到分类任务时，生成式预训练可以和其他算法结合使用，典型的是判别式方法，他通过有效地调整所有权值来改善网络的性能。</p><p>判别式精调（fine-tune）通常是在现有网络的最后一层上在增加一层节点，用来表示想要的输出或者训练数据提供的标签，它与标准的前馈神经网络（feed-forward neural network）一样，可以使用反向传播算法（back-propagation algorithm）来调整或精调网络的权值。DBN最后一层即标签层的内容，根据不同的任务和应用来确定。</p><p>研究已经表明其他种类的预训练策略的有效性。比如，在执行逐层贪婪训练时，可以在每一层的生成损失函数中增加一项判别项。</p><p>如果不适用生成式预训练，只使用随机梯度下降方法来对随机初始化DBN进行判别式训练，研究结果表明，当非常仔细的选取初始权值并且谨慎的选取适合于随机梯度下降的“迷你批量”（mini-batch）的大小（例如，随着训练轮数增加大小），也将会获得很好的效果。</p><p>“迷你批量”用于在收敛速度和噪声梯度之间进行折中。同时，在建立“迷你批量”时，对数据进行充分的随机化也是至关重要的。</p><p>另外，从一个只含有一层的浅层神经网络开始学习一个DBN是非常有效的。当折中方法用于训练区分式模型时（使用提前结束训练的策略以防止过拟合的出现），在第一个隐藏层和标签的softmax输出层之间插入第二个隐藏层，然后对整个网络应用反向传播来微调网络的权值。这种判别式预训练在实践中取得了比较好的效果，特别是在有大量的训练数据的情况下效果较好。当训练数据不断增多时，即使不使用上述预训练，一些特别设计的随机初始化方法也能够取得很好的效果。</p><p>将隐单元的激活概率（activation probabilities）作为下一层伯努利-伯努利RBM的输入数据。</p><p>第二层伯努利-伯努利RBM的激活概率作为第三层伯努利-伯努利RBM的可见层输入数据</p><p><a href="https://www.cnblogs.com/jhding/p/5687696.html" target="_blank" rel="noopener">RBM和深度置信网络原理</a></p>]]></content>
    
    <summary type="html">
    
      RBM &amp; DBN原理简介
    
    </summary>
    
      <category term="笔记" scheme="https://jiangxj.top/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
